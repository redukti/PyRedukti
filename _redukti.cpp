/* Generated by Cython 0.29.10 */

/* BEGIN: Cython Metadata
{
    "distutils": {
        "depends": [
            "/home/dylan/Software/redukti/include/redukti/allocators.h",
            "/home/dylan/Software/redukti/include/redukti/autodiff.h",
            "/home/dylan/Software/redukti/include/redukti/calendars.h",
            "/home/dylan/Software/redukti/include/redukti/curve.h",
            "/home/dylan/Software/redukti/include/redukti/curve.pb.h",
            "/home/dylan/Software/redukti/include/redukti/date.h",
            "/home/dylan/Software/redukti/include/redukti/dayfractions.h",
            "/home/dylan/Software/redukti/include/redukti/enums.pb.h",
            "/home/dylan/Software/redukti/include/redukti/index.h",
            "/home/dylan/Software/redukti/include/redukti/index.pb.h",
            "/home/dylan/Software/redukti/include/redukti/interpolators.h",
            "/home/dylan/Software/redukti/include/redukti/request_processor.h",
            "/home/dylan/Software/redukti/include/redukti/schedule.h",
            "/home/dylan/Software/redukti/include/redukti/schedule.pb.h",
            "/home/dylan/Software/redukti/include/redukti/services.pb.h"
        ],
        "include_dirs": [
            "/home/dylan/Software/redukti/include/redukti",
            "/home/dylan/Software/redukti/include",
            "/home/dylan/Software/protobuf/include"
        ],
        "language": "c++",
        "libraries": [
            "openredukti"
        ],
        "library_dirs": [
            "/home/dylan/Software/redukti/lib"
        ],
        "name": "_redukti",
        "sources": [
            "_redukti.pyx"
        ]
    },
    "module_name": "_redukti"
}
END: Cython Metadata */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
    #error Cython requires Python 2.6+ or Python 3.3+.
#else
#define CYTHON_ABI "0_29_10"
#define CYTHON_HEX_VERSION 0x001D0AF0
#define CYTHON_FUTURE_DIVISION 1
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#define __PYX_COMMA ,
#ifndef HAVE_LONG_LONG
  #if PY_VERSION_HEX >= 0x02070000
    #define HAVE_LONG_LONG
  #endif
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #undef CYTHON_USE_TYPE_SLOTS
  #define CYTHON_USE_TYPE_SLOTS 0
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #if PY_VERSION_HEX < 0x03050000
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #undef CYTHON_USE_UNICODE_INTERNALS
  #define CYTHON_USE_UNICODE_INTERNALS 0
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #undef CYTHON_AVOID_BORROWED_REFS
  #define CYTHON_AVOID_BORROWED_REFS 1
  #undef CYTHON_ASSUME_SAFE_MACROS
  #define CYTHON_ASSUME_SAFE_MACROS 0
  #undef CYTHON_UNPACK_METHODS
  #define CYTHON_UNPACK_METHODS 0
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#elif defined(PYSTON_VERSION)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYTYPE_LOOKUP
    #define CYTHON_USE_PYTYPE_LOOKUP 0
  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
    #define CYTHON_USE_PYTYPE_LOOKUP 1
  #endif
  #if PY_MAJOR_VERSION < 3
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYLONG_INTERNALS
    #define CYTHON_USE_PYLONG_INTERNALS 0
  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
    #define CYTHON_USE_PYLONG_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_PYLIST_INTERNALS
    #define CYTHON_USE_PYLIST_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #if PY_VERSION_HEX < 0x030300F0
    #undef CYTHON_USE_UNICODE_WRITER
    #define CYTHON_USE_UNICODE_WRITER 0
  #elif !defined(CYTHON_USE_UNICODE_WRITER)
    #define CYTHON_USE_UNICODE_WRITER 1
  #endif
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #ifndef CYTHON_FAST_THREAD_STATE
    #define CYTHON_FAST_THREAD_STATE 1
  #endif
  #ifndef CYTHON_FAST_PYCALL
    #define CYTHON_FAST_PYCALL 1
  #endif
  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
  #endif
  #ifndef CYTHON_USE_TP_FINALIZE
    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
  #endif
  #ifndef CYTHON_USE_DICT_VERSIONS
    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
  #endif
  #ifndef CYTHON_USE_EXC_INFO_STACK
    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
  #endif
#endif
#if !defined(CYTHON_FAST_PYCCALL)
#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
  #undef SHIFT
  #undef BASE
  #undef MASK
  #ifdef SIZEOF_VOID_P
    enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
  #endif
#endif
#ifndef __has_attribute
  #define __has_attribute(x) 0
#endif
#ifndef __has_cpp_attribute
  #define __has_cpp_attribute(x) 0
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_MAYBE_UNUSED_VAR
#  if defined(__cplusplus)
     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
#  else
#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
#  endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
#ifdef _MSC_VER
    #ifndef _MSC_STDINT_H_
        #if _MSC_VER < 1300
           typedef unsigned char     uint8_t;
           typedef unsigned int      uint32_t;
        #else
           typedef unsigned __int8   uint8_t;
           typedef unsigned __int32  uint32_t;
        #endif
    #endif
#else
   #include <stdint.h>
#endif
#ifndef CYTHON_FALLTHROUGH
  #if defined(__cplusplus) && __cplusplus >= 201103L
    #if __has_cpp_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH [[fallthrough]]
    #elif __has_cpp_attribute(clang::fallthrough)
      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
    #elif __has_cpp_attribute(gnu::fallthrough)
      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
    #endif
  #endif
  #ifndef CYTHON_FALLTHROUGH
    #if __has_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
    #else
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
  #if defined(__clang__ ) && defined(__apple_build_version__)
    #if __apple_build_version__ < 7000000
      #undef  CYTHON_FALLTHROUGH
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
#endif

#ifndef __cplusplus
  #error "Cython files generated with the C++ option must be compiled with a C++ compiler."
#endif
#ifndef CYTHON_INLINE
  #if defined(__clang__)
    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
  #else
    #define CYTHON_INLINE inline
  #endif
#endif
template<typename T>
void __Pyx_call_destructor(T& x) {
    x.~T();
}
template<typename T>
class __Pyx_FakeReference {
  public:
    __Pyx_FakeReference() : ptr(NULL) { }
    __Pyx_FakeReference(const T& ref) : ptr(const_cast<T*>(&ref)) { }
    T *operator->() { return ptr; }
    T *operator&() { return ptr; }
    operator T&() { return *ptr; }
    template<typename U> bool operator ==(U other) { return *ptr == other; }
    template<typename U> bool operator !=(U other) { return *ptr != other; }
  private:
    T *ptr;
};

#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
#if PY_VERSION_HEX < 0x030800A4
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#else
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, 0, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#endif
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#ifndef METH_STACKLESS
  #define METH_STACKLESS 0
#endif
#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
  #ifndef METH_FASTCALL
     #define METH_FASTCALL 0x80
  #endif
  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                          Py_ssize_t nargs, PyObject *kwnames);
#else
  #define __Pyx_PyCFunctionFast _PyCFunctionFast
  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
#endif
#if CYTHON_FAST_PYCCALL
#define __Pyx_PyFastCFunction_Check(func)\
    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
#else
#define __Pyx_PyFastCFunction_Check(func) 0
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
  #define PyMem_RawFree(p)             PyMem_Free(p)
#endif
#if CYTHON_COMPILING_IN_PYSTON
  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
#else
  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
#endif
#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#elif PY_VERSION_HEX >= 0x03060000
  #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
#elif PY_VERSION_HEX >= 0x03000000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#else
  #define __Pyx_PyThreadState_Current _PyThreadState_Current
#endif
#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
#include "pythread.h"
#define Py_tss_NEEDS_INIT 0
typedef int Py_tss_t;
static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
  *key = PyThread_create_key();
  return 0;
}
static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
  *key = Py_tss_NEEDS_INIT;
  return key;
}
static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
  PyObject_Free(key);
}
static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
  return *key != Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
  PyThread_delete_key(*key);
  *key = Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
  return PyThread_set_key_value(*key, value);
}
static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
  return PyThread_get_key_value(*key);
}
#endif
#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
#define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
#else
#define __Pyx_PyDict_NewPresized(n)  PyDict_New()
#endif
#if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
#else
#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
#else
  #define CYTHON_PEP393_ENABLED 0
  #define PyUnicode_1BYTE_KIND  1
  #define PyUnicode_2BYTE_KIND  2
  #define PyUnicode_4BYTE_KIND  4
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
  #define PyObject_Unicode             PyObject_Str
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#if CYTHON_ASSUME_SAFE_MACROS
  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
#else
  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : (Py_INCREF(func), func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if CYTHON_USE_ASYNC_SLOTS
  #if PY_VERSION_HEX >= 0x030500B1
    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
  #else
    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
  #endif
#else
  #define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef __Pyx_PyAsyncMethodsStruct
    typedef struct {
        unaryfunc am_await;
        unaryfunc am_aiter;
        unaryfunc am_anext;
    } __Pyx_PyAsyncMethodsStruct;
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif


#define __PYX_ERR(f_index, lineno, Ln_error) \
{ \
  __pyx_filename = __pyx_f[f_index]; __pyx_lineno = lineno; __pyx_clineno = __LINE__; goto Ln_error; \
}

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE___redukti
#define __PYX_HAVE_API___redukti
/* Early includes */
#include "autodiff.h"
#include "enums.pb.h"
#include "date.h"
#include <string.h>
#include "ios"
#include "new"
#include "stdexcept"
#include "typeinfo"
#include <string>
#include "schedule.pb.h"
#include "schedule.h"
#include "calendars.h"
#include "dayfractions.h"
#include "index.pb.h"
#include "index.h"
#include "allocators.h"
#include <memory>
#include "interpolators.h"
#include "curve.pb.h"
#include "curve.h"
#include "services.pb.h"
#include "request_processor.h"
#include <stdio.h>
#include "pythread.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
#define CYTHON_WITHOUT_ASSERTIONS
#endif

typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_UTF8 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT (PY_MAJOR_VERSION >= 3 && __PYX_DEFAULT_STRING_ENCODING_IS_UTF8)
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
    return (size_t) i < (size_t) limit;
}
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER)
    #define __Pyx_sst_abs(value) ((Py_ssize_t)_abs64(value))
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
#define __Pyx_PySequence_Tuple(obj)\
    (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_ASSUME_SAFE_MACROS
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }

static PyObject *__pyx_m = NULL;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_cython_runtime = NULL;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "_redukti.pyx",
  "stringsource",
  "array.pxd",
  "type.pxd",
  "bool.pxd",
  "complex.pxd",
};

/*--- Type declarations ---*/
#ifndef _ARRAYARRAY_H
struct arrayobject;
typedef struct arrayobject arrayobject;
#endif
struct __pyx_obj_8_redukti_ADVar;
struct __pyx_obj_8_redukti_Date;
struct __pyx_obj_8_redukti_ScheduleGenerator;
struct __pyx_obj_8_redukti_Calendar;
struct __pyx_obj_8_redukti_DayFraction;
struct __pyx_obj_8_redukti_InterestRateIndex;
struct __pyx_obj_8_redukti_Interpolator;
struct __pyx_obj_8_redukti_CurveId;
struct __pyx_obj_8_redukti_InterpolatedYieldCurve;
struct __pyx_obj_8_redukti_SvenssonCurve;
struct __pyx_obj_8_redukti_YieldCurve;
struct __pyx_obj_8_redukti_InMemoryRequestProcessor;

/* "_redukti.pyx":30
 * cimport cython
 * 
 * cdef class ADVar:             # <<<<<<<<<<<<<<
 *     """
 *     ADVar represents an automatically differentiated variable.
 */
struct __pyx_obj_8_redukti_ADVar {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_ADVar *__pyx_vtab;
  redukti_adouble_t *_ad;
  int _vars;
  int _order;
};


/* "_redukti.pyx":154
 *         raise TypeError("Could not convert to bytes.")
 * 
 * cdef class Date:             # <<<<<<<<<<<<<<
 *     """
 *     Holds a date value as the number of days since civil 1899-12-31.
 */
struct __pyx_obj_8_redukti_Date {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_Date *__pyx_vtab;
  int _serial;
  struct redukti::YearMonthDay _ymd;
};


/* "_redukti.pyx":240
 *         return Date(d)
 * 
 * cdef class ScheduleGenerator:             # <<<<<<<<<<<<<<
 *     """
 *     Utilities for generating schedules for interest rate products.
 */
struct __pyx_obj_8_redukti_ScheduleGenerator {
  PyObject_HEAD
};


/* "_redukti.pyx":290
 *     return date_array
 * 
 * cdef class Calendar:             # <<<<<<<<<<<<<<
 *     """
 *     Represents a Business/Holiday Calendar for a business center or a combination of business centers.
 */
struct __pyx_obj_8_redukti_Calendar {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_Calendar *__pyx_vtab;
  redukti::Calendar const *_calendar;
};


/* "_redukti.pyx":412
 *         raise ValueError('Invalid DayCountFraction specified')
 * 
 * cdef class DayFraction:             # <<<<<<<<<<<<<<
 *     """
 *     Day Count Fraction calculator.
 */
struct __pyx_obj_8_redukti_DayFraction {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_DayFraction *__pyx_vtab;
  redukti::DayFraction const *_dayfraction;
};


/* "_redukti.pyx":496
 *         raise ValueError('Invalid InterpolatorType specified')
 * 
 * cdef class InterestRateIndex:             # <<<<<<<<<<<<<<
 *     """
 *     An interest rate index representation.
 */
struct __pyx_obj_8_redukti_InterestRateIndex {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_InterestRateIndex *__pyx_vtab;
  redukti::InterestRateIndex const *_index;
};


/* "_redukti.pyx":591
 *             self._index.fixing_calendar().advance(unadjusted.serial(), days, enums.DAYS, self._index.day_convention()))
 * 
 * cdef class Interpolator:             # <<<<<<<<<<<<<<
 *     """
 *     An Interpolator computes values between ranges based upon an interpolation method.
 */
struct __pyx_obj_8_redukti_Interpolator {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_Interpolator *__pyx_vtab;
  arrayobject *_x;
  arrayobject *_y;
  redukti::InterpolatorPointerType _interpolator;
  redukti::Interpolator *_interpolator_ptr;
};


/* "_redukti.pyx":652
 *             fixed_region_allocator.pos(pos)
 * 
 * cdef class CurveId:             # <<<<<<<<<<<<<<
 *     cdef long long _id
 * 
 */
struct __pyx_obj_8_redukti_CurveId {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_CurveId *__pyx_vtab;
  PY_LONG_LONG _id;
};


/* "_redukti.pyx":664
 *         return self._id
 * 
 * cdef class InterpolatedYieldCurve:             # <<<<<<<<<<<<<<
 *     """
 *     YieldCurve that operates on top of an interpolator.
 */
struct __pyx_obj_8_redukti_InterpolatedYieldCurve {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_InterpolatedYieldCurve *__pyx_vtab;
  arrayobject *_maturities;
  arrayobject *_values;
  redukti::YieldCurvePointerType _yield_curve;
  redukti::YieldCurve *_yield_curve_ptr;
};


/* "_redukti.pyx":778
 *             fixed_region_allocator.pos(pos)
 * 
 * cdef class SvenssonCurve:             # <<<<<<<<<<<<<<
 *     """
 *     Svensson YieldCurve - this is a parametric yield curve.
 */
struct __pyx_obj_8_redukti_SvenssonCurve {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_SvenssonCurve *__pyx_vtab;
  arrayobject *_parameters;
  redukti::YieldCurvePointerType _yield_curve;
  redukti::YieldCurve *_yield_curve_ptr;
};


/* "_redukti.pyx":864
 *         return self._yield_curve_ptr.time_from_reference(d.serial())
 * 
 * cdef class YieldCurve:             # <<<<<<<<<<<<<<
 *     """
 *     """
 */
struct __pyx_obj_8_redukti_YieldCurve {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_YieldCurve *__pyx_vtab;
  redukti::IRCurveDefinition _definition;
  redukti::ZeroCurve _underlying_curve;
  redukti::YieldCurvePointerType _yield_curve;
  redukti::YieldCurve *_yield_curve_ptr;
};


/* "_redukti.pyx":973
 *             fixed_region_allocator.pos(pos)
 * 
 * cdef class InMemoryRequestProcessor:             # <<<<<<<<<<<<<<
 *     """
 *     The InMemoryRequestProcessor creates internal instance of the OpenRedukti RequestProcessor
 */
struct __pyx_obj_8_redukti_InMemoryRequestProcessor {
  PyObject_HEAD
  struct __pyx_vtabstruct_8_redukti_InMemoryRequestProcessor *__pyx_vtab;
  std::unique_ptr<redukti::RequestProcessor>  _request_processor;
  redukti::RequestProcessor *_request_processor_ptr;
};



/* "_redukti.pyx":30
 * cimport cython
 * 
 * cdef class ADVar:             # <<<<<<<<<<<<<<
 *     """
 *     ADVar represents an automatically differentiated variable.
 */

struct __pyx_vtabstruct_8_redukti_ADVar {
  PyObject *(*dup)(redukti_adouble_t *);
};
static struct __pyx_vtabstruct_8_redukti_ADVar *__pyx_vtabptr_8_redukti_ADVar;


/* "_redukti.pyx":154
 *         raise TypeError("Could not convert to bytes.")
 * 
 * cdef class Date:             # <<<<<<<<<<<<<<
 *     """
 *     Holds a date value as the number of days since civil 1899-12-31.
 */

struct __pyx_vtabstruct_8_redukti_Date {
  int (*day)(struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  int (*month)(struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  int (*year)(struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  int (*serial)(struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_Date *__pyx_vtabptr_8_redukti_Date;


/* "_redukti.pyx":290
 *     return date_array
 * 
 * cdef class Calendar:             # <<<<<<<<<<<<<<
 *     """
 *     Represents a Business/Holiday Calendar for a business center or a combination of business centers.
 */

struct __pyx_vtabstruct_8_redukti_Calendar {
  int (*is_holiday)(struct __pyx_obj_8_redukti_Calendar *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_Calendar *__pyx_vtabptr_8_redukti_Calendar;


/* "_redukti.pyx":412
 *         raise ValueError('Invalid DayCountFraction specified')
 * 
 * cdef class DayFraction:             # <<<<<<<<<<<<<<
 *     """
 *     Day Count Fraction calculator.
 */

struct __pyx_vtabstruct_8_redukti_DayFraction {
  double (*year_fraction)(struct __pyx_obj_8_redukti_DayFraction *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*year_fraction_with_finalperiod)(struct __pyx_obj_8_redukti_DayFraction *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int, int __pyx_skip_dispatch);
  double (*year_fraction_with_refdates)(struct __pyx_obj_8_redukti_DayFraction *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_DayFraction *__pyx_vtabptr_8_redukti_DayFraction;


/* "_redukti.pyx":496
 *         raise ValueError('Invalid InterpolatorType specified')
 * 
 * cdef class InterestRateIndex:             # <<<<<<<<<<<<<<
 *     """
 *     An interest rate index representation.
 */

struct __pyx_vtabstruct_8_redukti_InterestRateIndex {
  struct __pyx_obj_8_redukti_Date *(*value_date)(struct __pyx_obj_8_redukti_InterestRateIndex *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  struct __pyx_obj_8_redukti_Date *(*fixing_date)(struct __pyx_obj_8_redukti_InterestRateIndex *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  struct __pyx_obj_8_redukti_Date *(*maturity_date)(struct __pyx_obj_8_redukti_InterestRateIndex *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  struct __pyx_obj_8_redukti_Date *(*adjust_date)(struct __pyx_obj_8_redukti_InterestRateIndex *, struct __pyx_obj_8_redukti_Date *, int, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_InterestRateIndex *__pyx_vtabptr_8_redukti_InterestRateIndex;


/* "_redukti.pyx":591
 *             self._index.fixing_calendar().advance(unadjusted.serial(), days, enums.DAYS, self._index.day_convention()))
 * 
 * cdef class Interpolator:             # <<<<<<<<<<<<<<
 *     """
 *     An Interpolator computes values between ranges based upon an interpolation method.
 */

struct __pyx_vtabstruct_8_redukti_Interpolator {
  double (*interpolate)(struct __pyx_obj_8_redukti_Interpolator *, double, int __pyx_skip_dispatch);
  struct __pyx_obj_8_redukti_ADVar *(*interpolate_with_sensitivities_)(struct __pyx_obj_8_redukti_Interpolator *, double, redukti::FixedRegionAllocator *);
  struct __pyx_obj_8_redukti_ADVar *(*interpolate_with_sensitivities)(struct __pyx_obj_8_redukti_Interpolator *, double, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_Interpolator *__pyx_vtabptr_8_redukti_Interpolator;


/* "_redukti.pyx":652
 *             fixed_region_allocator.pos(pos)
 * 
 * cdef class CurveId:             # <<<<<<<<<<<<<<
 *     cdef long long _id
 * 
 */

struct __pyx_vtabstruct_8_redukti_CurveId {
  PY_LONG_LONG (*id)(struct __pyx_obj_8_redukti_CurveId *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_CurveId *__pyx_vtabptr_8_redukti_CurveId;


/* "_redukti.pyx":664
 *         return self._id
 * 
 * cdef class InterpolatedYieldCurve:             # <<<<<<<<<<<<<<
 *     """
 *     YieldCurve that operates on top of an interpolator.
 */

struct __pyx_vtabstruct_8_redukti_InterpolatedYieldCurve {
  double (*discount)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*zero_rate)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*forward_rate)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*time_from_reference)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  struct __pyx_obj_8_redukti_ADVar *(*get_sensitivities_)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, double, redukti::FixedRegionAllocator *);
  struct __pyx_obj_8_redukti_ADVar *(*get_sensitivities)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, double, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_InterpolatedYieldCurve *__pyx_vtabptr_8_redukti_InterpolatedYieldCurve;


/* "_redukti.pyx":778
 *             fixed_region_allocator.pos(pos)
 * 
 * cdef class SvenssonCurve:             # <<<<<<<<<<<<<<
 *     """
 *     Svensson YieldCurve - this is a parametric yield curve.
 */

struct __pyx_vtabstruct_8_redukti_SvenssonCurve {
  double (*discount)(struct __pyx_obj_8_redukti_SvenssonCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*zero_rate)(struct __pyx_obj_8_redukti_SvenssonCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*forward_rate)(struct __pyx_obj_8_redukti_SvenssonCurve *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*time_from_reference)(struct __pyx_obj_8_redukti_SvenssonCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_SvenssonCurve *__pyx_vtabptr_8_redukti_SvenssonCurve;


/* "_redukti.pyx":864
 *         return self._yield_curve_ptr.time_from_reference(d.serial())
 * 
 * cdef class YieldCurve:             # <<<<<<<<<<<<<<
 *     """
 *     """
 */

struct __pyx_vtabstruct_8_redukti_YieldCurve {
  double (*discount)(struct __pyx_obj_8_redukti_YieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*zero_rate)(struct __pyx_obj_8_redukti_YieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*forward_rate)(struct __pyx_obj_8_redukti_YieldCurve *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  double (*time_from_reference)(struct __pyx_obj_8_redukti_YieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch);
  struct __pyx_obj_8_redukti_ADVar *(*get_sensitivities_)(struct __pyx_obj_8_redukti_YieldCurve *, double, redukti::FixedRegionAllocator *);
  struct __pyx_obj_8_redukti_ADVar *(*get_sensitivities)(struct __pyx_obj_8_redukti_YieldCurve *, double, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_YieldCurve *__pyx_vtabptr_8_redukti_YieldCurve;


/* "_redukti.pyx":973
 *             fixed_region_allocator.pos(pos)
 * 
 * cdef class InMemoryRequestProcessor:             # <<<<<<<<<<<<<<
 *     """
 *     The InMemoryRequestProcessor creates internal instance of the OpenRedukti RequestProcessor
 */

struct __pyx_vtabstruct_8_redukti_InMemoryRequestProcessor {
  PyObject *(*serve)(struct __pyx_obj_8_redukti_InMemoryRequestProcessor *, PyObject *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_8_redukti_InMemoryRequestProcessor *__pyx_vtabptr_8_redukti_InMemoryRequestProcessor;

/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyThreadStateGet.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
#else
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#endif
#else
#define __Pyx_PyErr_Clear() PyErr_Clear()
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* ArgTypeTest.proto */
#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
    ((likely((Py_TYPE(obj) == type) | (none_allowed && (obj == Py_None)))) ? 1 :\
        __Pyx__ArgTypeTest(obj, type, name, exact))
static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);

/* ListAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

/* PyCFunctionFastCall.proto */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
#else
#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
#endif

/* PyFunctionFastCall.proto */
#if CYTHON_FAST_PYCALL
#define __Pyx_PyFunction_FastCall(func, args, nargs)\
    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs);
#else
#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
#endif
#define __Pyx_BUILD_ASSERT_EXPR(cond)\
    (sizeof(char [1 - 2*!(cond)]) - 1)
#ifndef Py_MEMBER_SIZE
#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
#endif
  static size_t __pyx_pyframe_localsplus_offset = 0;
  #include "frameobject.h"
  #define __Pxy_PyFrame_Initialize_Offsets()\
    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
  #define __Pyx_PyFrame_GetLocalsplus(frame)\
    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
#endif

/* PyObjectCall2Args.proto */
static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* PyDictVersioning.proto */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
    (version_var) = __PYX_GET_DICT_VERSION(dict);\
    (cache_var) = (value);
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
        (VAR) = __pyx_dict_cached_value;\
    } else {\
        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
    }\
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
#else
#define __PYX_GET_DICT_VERSION(dict)  (0)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
#endif

/* PyObjectCallNoArg.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

/* WriteUnraisableException.proto */
static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback, int nogil);

/* GetModuleGlobalName.proto */
#if CYTHON_USE_DICT_VERSIONS
#define __Pyx_GetModuleGlobalName(var, name)  {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
}
#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
    PY_UINT64_T __pyx_dict_version;\
    PyObject *__pyx_dict_cached_value;\
    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
}
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
#else
#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
#endif

/* PyErrExceptionMatches.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
#else
#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
#endif

/* GetAttr.proto */
static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);

/* GetAttr3.proto */
static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);

/* PyObjectGetMethod.proto */
static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);

/* PyObjectCallMethod1.proto */
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);

/* append.proto */
static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x);

/* GetItemInt.proto */
#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

/* ExtTypeTest.proto */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

/* KeywordStringCheck.proto */
static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);

/* IncludeStringH.proto */
#include <string.h>

/* BytesEquals.proto */
static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);

/* UnicodeEquals.proto */
static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);

/* GetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* SwapException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* GetTopmostException.proto */
#if CYTHON_USE_EXC_INFO_STACK
static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
#endif

/* SaveResetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
#else
#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
#endif

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* ImportFrom.proto */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

/* HasAttr.proto */
static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);

/* PyObject_GenericGetAttrNoDict.proto */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
#endif

/* PyObject_GenericGetAttr.proto */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
#endif

/* SetVTable.proto */
static int __Pyx_SetVtable(PyObject *dict, void *vtable);

/* SetupReduce.proto */
static int __Pyx_setup_reduce(PyObject* type_obj);

/* TypeImport.proto */
#ifndef __PYX_HAVE_RT_ImportType_proto
#define __PYX_HAVE_RT_ImportType_proto
enum __Pyx_ImportType_CheckSize {
   __Pyx_ImportType_CheckSize_Error = 0,
   __Pyx_ImportType_CheckSize_Warn = 1,
   __Pyx_ImportType_CheckSize_Ignore = 2
};
static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
#endif

/* GetNameInClass.proto */
#define __Pyx_GetNameInClass(var, nmspace, name)  (var) = __Pyx__GetNameInClass(nmspace, name)
static PyObject *__Pyx__GetNameInClass(PyObject *nmspace, PyObject *name);

/* CLineInTraceback.proto */
#ifdef CYTHON_CLINE_IN_TRACEBACK
#define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
#else
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
#endif

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* ArrayAPI.proto */
#ifndef _ARRAYARRAY_H
#define _ARRAYARRAY_H
typedef struct arraydescr {
    int typecode;
    int itemsize;
    PyObject * (*getitem)(struct arrayobject *, Py_ssize_t);
    int (*setitem)(struct arrayobject *, Py_ssize_t, PyObject *);
#if PY_MAJOR_VERSION >= 3
    char *formats;
#endif
} arraydescr;
struct arrayobject {
    PyObject_HEAD
    Py_ssize_t ob_size;
    union {
        char *ob_item;
        float *as_floats;
        double *as_doubles;
        int *as_ints;
        unsigned int *as_uints;
        unsigned char *as_uchars;
        signed char *as_schars;
        char *as_chars;
        unsigned long *as_ulongs;
        long *as_longs;
#if PY_MAJOR_VERSION >= 3
        unsigned long long *as_ulonglongs;
        long long *as_longlongs;
#endif
        short *as_shorts;
        unsigned short *as_ushorts;
        Py_UNICODE *as_pyunicodes;
        void *as_voidptr;
    } data;
    Py_ssize_t allocated;
    struct arraydescr *ob_descr;
    PyObject *weakreflist;
#if PY_MAJOR_VERSION >= 3
        int ob_exports;
#endif
};
#ifndef NO_NEWARRAY_INLINE
static CYTHON_INLINE PyObject * newarrayobject(PyTypeObject *type, Py_ssize_t size,
    struct arraydescr *descr) {
    arrayobject *op;
    size_t nbytes;
    if (size < 0) {
        PyErr_BadInternalCall();
        return NULL;
    }
    nbytes = size * descr->itemsize;
    if (nbytes / descr->itemsize != (size_t)size) {
        return PyErr_NoMemory();
    }
    op = (arrayobject *) type->tp_alloc(type, 0);
    if (op == NULL) {
        return NULL;
    }
    op->ob_descr = descr;
    op->allocated = size;
    op->weakreflist = NULL;
    op->ob_size = size;
    if (size <= 0) {
        op->data.ob_item = NULL;
    }
    else {
        op->data.ob_item = PyMem_NEW(char, nbytes);
        if (op->data.ob_item == NULL) {
            Py_DECREF(op);
            return PyErr_NoMemory();
        }
    }
    return (PyObject *) op;
}
#else
PyObject* newarrayobject(PyTypeObject *type, Py_ssize_t size,
    struct arraydescr *descr);
#endif
static CYTHON_INLINE int resize(arrayobject *self, Py_ssize_t n) {
    void *items = (void*) self->data.ob_item;
    PyMem_Resize(items, char, (size_t)(n * self->ob_descr->itemsize));
    if (items == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    self->data.ob_item = (char*) items;
    self->ob_size = n;
    self->allocated = n;
    return 0;
}
static CYTHON_INLINE int resize_smart(arrayobject *self, Py_ssize_t n) {
    void *items = (void*) self->data.ob_item;
    Py_ssize_t newsize;
    if (n < self->allocated && n*4 > self->allocated) {
        self->ob_size = n;
        return 0;
    }
    newsize = n + (n / 2) + 1;
    if (newsize <= n) {
        PyErr_NoMemory();
        return -1;
    }
    PyMem_Resize(items, char, (size_t)(newsize * self->ob_descr->itemsize));
    if (items == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    self->data.ob_item = (char*) items;
    self->ob_size = n;
    self->allocated = newsize;
    return 0;
}
#endif

/* None.proto */
#include <new>

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__redukti_3a__3a_BusinessCenter(enum redukti::BusinessCenter value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_PY_LONG_LONG(PY_LONG_LONG value);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::PeriodUnit __Pyx_PyInt_As_enum__redukti_3a__3a_PeriodUnit(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::BusinessDayConvention __Pyx_PyInt_As_enum__redukti_3a__3a_BusinessDayConvention(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::BusinessCenter __Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::DayCountFraction __Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::IsdaIndex __Pyx_PyInt_As_enum__redukti_3a__3a_IsdaIndex(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::Tenor __Pyx_PyInt_As_enum__redukti_3a__3a_Tenor(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::Currency __Pyx_PyInt_As_enum__redukti_3a__3a_Currency(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::IndexFamily __Pyx_PyInt_As_enum__redukti_3a__3a_IndexFamily(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::InterpolatorType __Pyx_PyInt_As_enum__redukti_3a__3a_InterpolatorType(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::PricingCurveType __Pyx_PyInt_As_enum__redukti_3a__3a_PricingCurveType(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::MarketDataQualifier __Pyx_PyInt_As_enum__redukti_3a__3a_MarketDataQualifier(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_As_PY_LONG_LONG(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE enum redukti::IRRateType __Pyx_PyInt_As_enum__redukti_3a__3a_IRRateType(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* FastTypeChecks.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
#else
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
#endif
#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);

static PyObject *__pyx_f_8_redukti_5ADVar_dup(redukti_adouble_t *__pyx_v_value); /* proto*/
static int __pyx_f_8_redukti_4Date_day(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static int __pyx_f_8_redukti_4Date_month(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static int __pyx_f_8_redukti_4Date_year(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static int __pyx_f_8_redukti_4Date_serial(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static int __pyx_f_8_redukti_8Calendar_is_holiday(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_11DayFraction_year_fraction(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_11DayFraction_year_fraction_with_finalperiod(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_v_final_period, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_11DayFraction_year_fraction_with_refdates(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date1, struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date2, int __pyx_skip_dispatch); /* proto*/
static struct __pyx_obj_8_redukti_Date *__pyx_f_8_redukti_17InterestRateIndex_value_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_fixing_date, int __pyx_skip_dispatch); /* proto*/
static struct __pyx_obj_8_redukti_Date *__pyx_f_8_redukti_17InterestRateIndex_fixing_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_accrual_start_date, int __pyx_skip_dispatch); /* proto*/
static struct __pyx_obj_8_redukti_Date *__pyx_f_8_redukti_17InterestRateIndex_maturity_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_value_date, int __pyx_skip_dispatch); /* proto*/
static struct __pyx_obj_8_redukti_Date *__pyx_f_8_redukti_17InterestRateIndex_adjust_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_unadjusted, int __pyx_v_days, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_12Interpolator_interpolate(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x, int __pyx_skip_dispatch); /* proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_12Interpolator_interpolate_with_sensitivities_(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x, redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator); /* proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_12Interpolator_interpolate_with_sensitivities(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x, int __pyx_skip_dispatch); /* proto*/
static PY_LONG_LONG __pyx_f_8_redukti_7CurveId_id(struct __pyx_obj_8_redukti_CurveId *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_22InterpolatedYieldCurve_discount(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_22InterpolatedYieldCurve_zero_rate(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_22InterpolatedYieldCurve_forward_rate(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_22InterpolatedYieldCurve_time_from_reference(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_22InterpolatedYieldCurve_get_sensitivities_(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, double __pyx_v_x, redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator); /* proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_22InterpolatedYieldCurve_get_sensitivities(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, double __pyx_v_x, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_13SvenssonCurve_discount(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_13SvenssonCurve_zero_rate(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_13SvenssonCurve_forward_rate(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_13SvenssonCurve_time_from_reference(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_10YieldCurve_discount(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_10YieldCurve_zero_rate(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_10YieldCurve_forward_rate(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_skip_dispatch); /* proto*/
static double __pyx_f_8_redukti_10YieldCurve_time_from_reference(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch); /* proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_10YieldCurve_get_sensitivities_(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, double __pyx_v_x, redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator); /* proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_10YieldCurve_get_sensitivities(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, double __pyx_v_x, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_8_redukti_24InMemoryRequestProcessor_serve(struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, PyObject *__pyx_v_request, int __pyx_skip_dispatch); /* proto*/

/* Module declarations from 'cpython.mem' */

/* Module declarations from 'autodiff' */

/* Module declarations from 'enums' */

/* Module declarations from 'date' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libcpp.string' */

/* Module declarations from 'schedule' */

/* Module declarations from 'calendar' */

/* Module declarations from 'dayfraction' */

/* Module declarations from 'index' */

/* Module declarations from 'allocator' */

/* Module declarations from 'libcpp' */

/* Module declarations from 'libcpp.memory' */

/* Module declarations from 'interpolator' */

/* Module declarations from 'curve' */

/* Module declarations from 'request_processor' */

/* Module declarations from 'cpython.version' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.type' */
static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;

/* Module declarations from 'libc.stdio' */

/* Module declarations from 'cpython.object' */

/* Module declarations from 'cpython.ref' */

/* Module declarations from 'cpython.exc' */

/* Module declarations from 'cpython.module' */

/* Module declarations from 'cpython.tuple' */

/* Module declarations from 'cpython.list' */

/* Module declarations from 'cpython.sequence' */

/* Module declarations from 'cpython.mapping' */

/* Module declarations from 'cpython.iterator' */

/* Module declarations from 'cpython.number' */

/* Module declarations from 'cpython.int' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.bool' */
static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;

/* Module declarations from 'cpython.long' */

/* Module declarations from 'cpython.float' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.complex' */
static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;

/* Module declarations from 'cpython.string' */

/* Module declarations from 'cpython.unicode' */

/* Module declarations from 'cpython.dict' */

/* Module declarations from 'cpython.instance' */

/* Module declarations from 'cpython.function' */

/* Module declarations from 'cpython.method' */

/* Module declarations from 'cpython.weakref' */

/* Module declarations from 'cpython.getargs' */

/* Module declarations from 'cpython.pythread' */

/* Module declarations from 'cpython.pystate' */

/* Module declarations from 'cpython.cobject' */

/* Module declarations from 'cpython.oldbuffer' */

/* Module declarations from 'cpython.set' */

/* Module declarations from 'cpython.buffer' */

/* Module declarations from 'cpython.bytes' */

/* Module declarations from 'cpython.pycapsule' */

/* Module declarations from 'cpython' */

/* Module declarations from 'array' */

/* Module declarations from 'cpython.array' */
static PyTypeObject *__pyx_ptype_7cpython_5array_array = 0;
static CYTHON_INLINE int __pyx_f_7cpython_5array_extend_buffer(arrayobject *, char *, Py_ssize_t); /*proto*/

/* Module declarations from 'cython' */

/* Module declarations from '_redukti' */
static PyTypeObject *__pyx_ptype_8_redukti_ADVar = 0;
static PyTypeObject *__pyx_ptype_8_redukti_Date = 0;
static PyTypeObject *__pyx_ptype_8_redukti_ScheduleGenerator = 0;
static PyTypeObject *__pyx_ptype_8_redukti_Calendar = 0;
static PyTypeObject *__pyx_ptype_8_redukti_DayFraction = 0;
static PyTypeObject *__pyx_ptype_8_redukti_InterestRateIndex = 0;
static PyTypeObject *__pyx_ptype_8_redukti_Interpolator = 0;
static PyTypeObject *__pyx_ptype_8_redukti_CurveId = 0;
static PyTypeObject *__pyx_ptype_8_redukti_InterpolatedYieldCurve = 0;
static PyTypeObject *__pyx_ptype_8_redukti_SvenssonCurve = 0;
static PyTypeObject *__pyx_ptype_8_redukti_YieldCurve = 0;
static PyTypeObject *__pyx_ptype_8_redukti_InMemoryRequestProcessor = 0;
static PyObject *__pyx_f_8_redukti_validate_periodunit(enum redukti::PeriodUnit); /*proto*/
static PyObject *__pyx_f_8_redukti_to_bytes(PyObject *); /*proto*/
static PyObject *__pyx_f_8_redukti_validate_business_centers(PyObject *); /*proto*/
static PyObject *__pyx_f_8_redukti_validate_daycountfraction(enum redukti::DayCountFraction); /*proto*/
static PyObject *__pyx_f_8_redukti_validate_isda_index(enum redukti::IsdaIndex); /*proto*/
static PyObject *__pyx_f_8_redukti_validate_index_family(enum redukti::IndexFamily); /*proto*/
static PyObject *__pyx_f_8_redukti_validate_tenor(enum redukti::Tenor); /*proto*/
static PyObject *__pyx_f_8_redukti_validate_currency(enum redukti::Currency); /*proto*/
static PyObject *__pyx_f_8_redukti_validate_interpolator_type(enum redukti::InterpolatorType); /*proto*/
static PyObject *__pyx_f_8_redukti___pyx_unpickle_ScheduleGenerator__set_state(struct __pyx_obj_8_redukti_ScheduleGenerator *, PyObject *); /*proto*/
static std::string __pyx_convert_string_from_py_std__in_string(PyObject *); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &); /*proto*/
#define __Pyx_MODULE_NAME "_redukti"
extern int __pyx_module_is_main__redukti;
int __pyx_module_is_main__redukti = 0;

/* Implementation of '_redukti' */
static PyObject *__pyx_builtin_staticmethod;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_TypeError;
static PyObject *__pyx_builtin_MemoryError;
static const char __pyx_k_d[] = "d";
static const char __pyx_k_i[] = "i";
static const char __pyx_k_m[] = "m";
static const char __pyx_k_n[] = "n";
static const char __pyx_k_s[] = "s";
static const char __pyx_k_v[] = "v";
static const char __pyx_k_x[] = "x";
static const char __pyx_k_y[] = "y";
static const char __pyx_k_d1[] = "d1";
static const char __pyx_k_d2[] = "d2";
static const char __pyx_k_id[] = "id";
static const char __pyx_k_ccy[] = "ccy";
static const char __pyx_k_day[] = "day";
static const char __pyx_k_dfc[] = "dfc";
static const char __pyx_k_dmy[] = "dmy";
static const char __pyx_k_idx[] = "idx";
static const char __pyx_k_mdq[] = "mdq";
static const char __pyx_k_new[] = "__new__";
static const char __pyx_k_obj[] = "obj";
static const char __pyx_k_str[] = "str";
static const char __pyx_k_Date[] = "Date";
static const char __pyx_k_date[] = "date";
static const char __pyx_k_days[] = "days";
static const char __pyx_k_dict[] = "__dict__";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_name[] = "__name__";
static const char __pyx_k_qual[] = "qual";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_type[] = "type";
static const char __pyx_k_unit[] = "unit";
static const char __pyx_k_year[] = "year";
static const char __pyx_k_ADVar[] = "ADVar";
static const char __pyx_k_UTF_8[] = "UTF-8";
static const char __pyx_k_array[] = "array";
static const char __pyx_k_cycle[] = "cycle";
static const char __pyx_k_dates[] = "dates";
static const char __pyx_k_month[] = "month";
static const char __pyx_k_order[] = "order";
static const char __pyx_k_parse[] = "parse";
static const char __pyx_k_range[] = "range";
static const char __pyx_k_serve[] = "serve";
static const char __pyx_k_tenor[] = "tenor";
static const char __pyx_k_value[] = "value";
static const char __pyx_k_xdata[] = "xdata";
static const char __pyx_k_append[] = "append";
static const char __pyx_k_byte_s[] = "byte_s";
static const char __pyx_k_encode[] = "encode";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_is_eom[] = "is_eom";
static const char __pyx_k_n_vars[] = "n_vars";
static const char __pyx_k_pickle[] = "pickle";
static const char __pyx_k_reduce[] = "__reduce__";
static const char __pyx_k_result[] = "result";
static const char __pyx_k_serial[] = "serial";
static const char __pyx_k_status[] = "status";
static const char __pyx_k_update[] = "update";
static const char __pyx_k_values[] = "values";
static const char __pyx_k_CurveId[] = "CurveId";
static const char __pyx_k_Request[] = "Request";
static const char __pyx_k_redukti[] = "redukti";
static const char __pyx_k_Calendar[] = "Calendar";
static const char __pyx_k_Response[] = "Response";
static const char __pyx_k_Schedule[] = "Schedule";
static const char __pyx_k_c_string[] = "c_string";
static const char __pyx_k_currency[] = "currency";
static const char __pyx_k_discount[] = "discount";
static const char __pyx_k_fraction[] = "fraction";
static const char __pyx_k_getstate[] = "__getstate__";
static const char __pyx_k_holidays[] = "holidays";
static const char __pyx_k_pyx_type[] = "__pyx_type";
static const char __pyx_k_scenario[] = "scenario";
static const char __pyx_k_schedule[] = "_schedule";
static const char __pyx_k_setstate[] = "__setstate__";
static const char __pyx_k_typecode[] = "typecode";
static const char __pyx_k_variable[] = "variable";
static const char __pyx_k_TypeError[] = "TypeError";
static const char __pyx_k_get_index[] = "get_index";
static const char __pyx_k_pyx_state[] = "__pyx_state";
static const char __pyx_k_rate_type[] = "rate_type";
static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
static const char __pyx_k_redukti_2[] = "_redukti";
static const char __pyx_k_ref_date1[] = "ref_date1";
static const char __pyx_k_ref_date2[] = "ref_date2";
static const char __pyx_k_zero_rate[] = "zero_rate";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_YieldCurve[] = "YieldCurve";
static const char __pyx_k_as_of_date[] = "as_of_date";
static const char __pyx_k_convention[] = "convention";
static const char __pyx_k_curve_defn[] = "curve_defn";
static const char __pyx_k_date_array[] = "date_array";
static const char __pyx_k_is_holiday[] = "is_holiday";
static const char __pyx_k_isda_index[] = "isda_index";
static const char __pyx_k_maturities[] = "maturities";
static const char __pyx_k_parameters[] = "parameters";
static const char __pyx_k_pyx_result[] = "__pyx_result";
static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
static const char __pyx_k_result_str[] = "result_str";
static const char __pyx_k_unadjusted[] = "unadjusted";
static const char __pyx_k_value_date[] = "value_date";
static const char __pyx_k_zero_curve[] = "zero_curve";
static const char __pyx_k_DayFraction[] = "DayFraction";
static const char __pyx_k_MemoryError[] = "MemoryError";
static const char __pyx_k_PickleError[] = "PickleError";
static const char __pyx_k_adjust_date[] = "adjust_date";
static const char __pyx_k_deriv_order[] = "deriv_order";
static const char __pyx_k_fixing_date[] = "fixing_date";
static const char __pyx_k_interpolate[] = "interpolate";
static const char __pyx_k_redukti_pyx[] = "_redukti.pyx";
static const char __pyx_k_Interpolator[] = "Interpolator";
static const char __pyx_k_final_period[] = "final_period";
static const char __pyx_k_forward_rate[] = "forward_rate";
static const char __pyx_k_index_family[] = "index_family";
static const char __pyx_k_parameters_2[] = "_parameters";
static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
static const char __pyx_k_schedule_pb2[] = "schedule_pb2";
static const char __pyx_k_services_pb2[] = "services_pb2";
static const char __pyx_k_staticmethod[] = "staticmethod";
static const char __pyx_k_stringsource[] = "stringsource";
static const char __pyx_k_Invalid_state[] = "Invalid state";
static const char __pyx_k_SvenssonCurve[] = "SvenssonCurve";
static const char __pyx_k_business_date[] = "business_date";
static const char __pyx_k_initial_value[] = "initial_value";
static const char __pyx_k_maturity_date[] = "maturity_date";
static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
static const char __pyx_k_year_fraction[] = "year_fraction";
static const char __pyx_k_pricing_script[] = "pricing_script";
static const char __pyx_k_ParseFromString[] = "ParseFromString";
static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
static const char __pyx_k_business_centres[] = "business_centres";
static const char __pyx_k_InterestRateIndex[] = "InterestRateIndex";
static const char __pyx_k_ScheduleGenerator[] = "ScheduleGenerator";
static const char __pyx_k_SerializeToString[] = "SerializeToString";
static const char __pyx_k_generate_schedule[] = "generate_schedule";
static const char __pyx_k_get_sensitivities[] = "get_sensitivities";
static const char __pyx_k_interpolator_type[] = "interpolator_type";
static const char __pyx_k_register_calendar[] = "register_calendar";
static const char __pyx_k_ScheduleParameters[] = "ScheduleParameters";
static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
static const char __pyx_k_pricing_curve_type[] = "pricing_curve_type";
static const char __pyx_k_NULL_value_supplied[] = "NULL value supplied";
static const char __pyx_k_schedule_parameters[] = "schedule_parameters";
static const char __pyx_k_time_from_reference[] = "time_from_reference";
static const char __pyx_k_convert_to_date_array[] = "convert_to_date_array";
static const char __pyx_k_InterpolatedYieldCurve[] = "InterpolatedYieldCurve";
static const char __pyx_k_get_index_by_isdaindex[] = "get_index_by_isdaindex";
static const char __pyx_k_Invalid_Tenor_specified[] = "Invalid Tenor specified";
static const char __pyx_k_Invalid_business_center[] = "Invalid business center";
static const char __pyx_k_InMemoryRequestProcessor[] = "InMemoryRequestProcessor";
static const char __pyx_k_Invalid_date_cannot_parse[] = "Invalid date: cannot parse";
static const char __pyx_k_Cannot_parse_the_ZeroCurve[] = "Cannot parse the ZeroCurve";
static const char __pyx_k_Could_not_convert_to_bytes[] = "Could not convert to bytes.";
static const char __pyx_k_Invalid_Currency_specified[] = "Invalid Currency specified";
static const char __pyx_k_Failed_to_generate_schedule[] = "Failed to generate schedule";
static const char __pyx_k_Invalid_IsdaIndex_specified[] = "Invalid IsdaIndex specified";
static const char __pyx_k_year_fraction_with_refdates[] = "year_fraction_with_refdates";
static const char __pyx_k_Invalid_PeriodUnit_specified[] = "Invalid PeriodUnit specified";
static const char __pyx_k_Invalid_IndexFamily_specified[] = "Invalid IndexFamily specified";
static const char __pyx_k_Order_must_be_between_0_and_2[] = "Order must be between 0 and 2";
static const char __pyx_k_Variable_index_is_out_of_range[] = "Variable index is out of range";
static const char __pyx_k_interpolate_with_sensitivities[] = "interpolate_with_sensitivities";
static const char __pyx_k_pyx_unpickle_ScheduleGenerator[] = "__pyx_unpickle_ScheduleGenerator";
static const char __pyx_k_year_fraction_with_finalperiod[] = "year_fraction_with_finalperiod";
static const char __pyx_k_Cannot_parse_the_Request_object[] = "Cannot parse the Request object";
static const char __pyx_k_Expected_values_of_redukti_Date[] = "Expected values of redukti.Date type in list";
static const char __pyx_k_Failed_to_parse_result_from_api[] = "Failed to parse result from api call";
static const char __pyx_k_Implements_the_interface_to_Ope[] = "\nImplements the interface to OpenRedukti classes and functions\n";
static const char __pyx_k_Index_object_is_not_initialized[] = "Index object is not initialized";
static const char __pyx_k_Supplied_arrays_must_be_of_type[] = "Supplied arrays must be of type double";
static const char __pyx_k_Beta0_tau1_and_tau2_must_be_posi[] = "Beta0, tau1 and tau2 must be positive";
static const char __pyx_k_Business_centers_must_be_specifi[] = "Business centers must be specified";
static const char __pyx_k_Cannot_parse_the_IRCurveDefiniti[] = "Cannot parse the IRCurveDefinition";
static const char __pyx_k_Cannot_parse_the_schedule_parame[] = "Cannot parse the schedule parameters";
static const char __pyx_k_Failed_to_create_instance_of_Int[] = "Failed to create instance of InterpolatedYieldCurve: please check inputs are correct";
static const char __pyx_k_Failed_to_create_instance_of_Sve[] = "Failed to create instance of SvenssonCurve: please check inputs are correct";
static const char __pyx_k_Failed_to_parse_response_from_ap[] = "Failed to parse response from api call";
static const char __pyx_k_Incompatible_checksums_s_vs_0xd4[] = "Incompatible checksums (%s vs 0xd41d8cd = ())";
static const char __pyx_k_Incorrect_number_of_values_in_bu[] = "Incorrect number of values in business centres list, max of 4 allowed";
static const char __pyx_k_Index_not_defined_for_given_Curr[] = "Index not defined for given Currency, IndexFamily and Tenor";
static const char __pyx_k_Index_not_defined_for_given_Isda[] = "Index not defined for given IsdaIndex and Tenor";
static const char __pyx_k_Input_must_be_an_instance_of_sch[] = "Input must be an instance of schedule_pb2.ScheduleParameters";
static const char __pyx_k_Input_must_be_an_instance_of_ser[] = "Input must be an instance of services_pb2.Request";
static const char __pyx_k_Invalid_DayCountFraction_specifi[] = "Invalid DayCountFraction specified";
static const char __pyx_k_Invalid_InterpolatorType_specifi[] = "Invalid InterpolatorType specified";
static const char __pyx_k_Invalid_size_of_maturities_or_va[] = "Invalid size of maturities or values: minimum 4 elements required and len(maturies) must be == len(values)";
static const char __pyx_k_Invalid_size_of_parameters_six_p[] = "Invalid size of parameters: six parameters required";
static const char __pyx_k_Invalid_size_of_x_or_y_minimum_4[] = "Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)";
static const char __pyx_k_Number_of_variables_in_ADVar_mus[] = "Number of variables in ADVar must be > 0";
static const char __pyx_k_Supplied_values_are_not_of_the_s[] = "Supplied values are not of the same order or size";
static const char __pyx_k_Unable_to_construct_a_calendar_f[] = "Unable to construct a calendar from given parameters";
static const char __pyx_k_failed_to_create_instance_of_InM[] = "failed to create instance of InMemoryRequestProcessor";
static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
static PyObject *__pyx_n_s_ADVar;
static PyObject *__pyx_kp_u_Beta0_tau1_and_tau2_must_be_posi;
static PyObject *__pyx_kp_u_Business_centers_must_be_specifi;
static PyObject *__pyx_n_s_Calendar;
static PyObject *__pyx_kp_u_Cannot_parse_the_IRCurveDefiniti;
static PyObject *__pyx_kp_u_Cannot_parse_the_Request_object;
static PyObject *__pyx_kp_u_Cannot_parse_the_ZeroCurve;
static PyObject *__pyx_kp_u_Cannot_parse_the_schedule_parame;
static PyObject *__pyx_kp_u_Could_not_convert_to_bytes;
static PyObject *__pyx_n_s_CurveId;
static PyObject *__pyx_n_s_Date;
static PyObject *__pyx_n_s_DayFraction;
static PyObject *__pyx_kp_u_Expected_values_of_redukti_Date;
static PyObject *__pyx_kp_u_Failed_to_create_instance_of_Int;
static PyObject *__pyx_kp_u_Failed_to_create_instance_of_Sve;
static PyObject *__pyx_kp_u_Failed_to_generate_schedule;
static PyObject *__pyx_kp_u_Failed_to_parse_response_from_ap;
static PyObject *__pyx_kp_u_Failed_to_parse_result_from_api;
static PyObject *__pyx_n_s_InMemoryRequestProcessor;
static PyObject *__pyx_kp_s_Incompatible_checksums_s_vs_0xd4;
static PyObject *__pyx_kp_u_Incorrect_number_of_values_in_bu;
static PyObject *__pyx_kp_u_Index_not_defined_for_given_Curr;
static PyObject *__pyx_kp_u_Index_not_defined_for_given_Isda;
static PyObject *__pyx_kp_u_Index_object_is_not_initialized;
static PyObject *__pyx_kp_u_Input_must_be_an_instance_of_sch;
static PyObject *__pyx_kp_u_Input_must_be_an_instance_of_ser;
static PyObject *__pyx_n_s_InterestRateIndex;
static PyObject *__pyx_n_s_InterpolatedYieldCurve;
static PyObject *__pyx_n_s_Interpolator;
static PyObject *__pyx_kp_u_Invalid_Currency_specified;
static PyObject *__pyx_kp_u_Invalid_DayCountFraction_specifi;
static PyObject *__pyx_kp_u_Invalid_IndexFamily_specified;
static PyObject *__pyx_kp_u_Invalid_InterpolatorType_specifi;
static PyObject *__pyx_kp_u_Invalid_IsdaIndex_specified;
static PyObject *__pyx_kp_u_Invalid_PeriodUnit_specified;
static PyObject *__pyx_kp_u_Invalid_Tenor_specified;
static PyObject *__pyx_kp_u_Invalid_business_center;
static PyObject *__pyx_kp_u_Invalid_date_cannot_parse;
static PyObject *__pyx_kp_u_Invalid_size_of_maturities_or_va;
static PyObject *__pyx_kp_u_Invalid_size_of_parameters_six_p;
static PyObject *__pyx_kp_u_Invalid_size_of_x_or_y_minimum_4;
static PyObject *__pyx_kp_u_Invalid_state;
static PyObject *__pyx_n_s_MemoryError;
static PyObject *__pyx_kp_u_NULL_value_supplied;
static PyObject *__pyx_kp_u_Number_of_variables_in_ADVar_mus;
static PyObject *__pyx_kp_u_Order_must_be_between_0_and_2;
static PyObject *__pyx_n_s_ParseFromString;
static PyObject *__pyx_n_s_PickleError;
static PyObject *__pyx_n_s_Request;
static PyObject *__pyx_n_s_Response;
static PyObject *__pyx_n_s_Schedule;
static PyObject *__pyx_n_s_ScheduleGenerator;
static PyObject *__pyx_n_s_ScheduleParameters;
static PyObject *__pyx_n_s_SerializeToString;
static PyObject *__pyx_kp_u_Supplied_arrays_must_be_of_type;
static PyObject *__pyx_kp_u_Supplied_values_are_not_of_the_s;
static PyObject *__pyx_n_s_SvenssonCurve;
static PyObject *__pyx_n_s_TypeError;
static PyObject *__pyx_kp_u_UTF_8;
static PyObject *__pyx_kp_u_Unable_to_construct_a_calendar_f;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_kp_u_Variable_index_is_out_of_range;
static PyObject *__pyx_n_s_YieldCurve;
static PyObject *__pyx_n_s_adjust_date;
static PyObject *__pyx_n_s_append;
static PyObject *__pyx_n_s_array;
static PyObject *__pyx_n_s_as_of_date;
static PyObject *__pyx_n_s_business_centres;
static PyObject *__pyx_n_s_business_date;
static PyObject *__pyx_n_s_byte_s;
static PyObject *__pyx_n_s_c_string;
static PyObject *__pyx_n_s_ccy;
static PyObject *__pyx_n_s_cline_in_traceback;
static PyObject *__pyx_n_s_convention;
static PyObject *__pyx_n_s_convert_to_date_array;
static PyObject *__pyx_n_s_currency;
static PyObject *__pyx_n_s_curve_defn;
static PyObject *__pyx_n_s_cycle;
static PyObject *__pyx_n_s_d;
static PyObject *__pyx_n_u_d;
static PyObject *__pyx_n_s_d1;
static PyObject *__pyx_n_s_d2;
static PyObject *__pyx_n_s_date;
static PyObject *__pyx_n_s_date_array;
static PyObject *__pyx_n_s_dates;
static PyObject *__pyx_n_s_day;
static PyObject *__pyx_n_s_days;
static PyObject *__pyx_n_s_deriv_order;
static PyObject *__pyx_n_s_dfc;
static PyObject *__pyx_n_s_dict;
static PyObject *__pyx_n_s_discount;
static PyObject *__pyx_n_s_dmy;
static PyObject *__pyx_n_s_encode;
static PyObject *__pyx_kp_u_failed_to_create_instance_of_InM;
static PyObject *__pyx_n_s_final_period;
static PyObject *__pyx_n_s_fixing_date;
static PyObject *__pyx_n_s_forward_rate;
static PyObject *__pyx_n_s_fraction;
static PyObject *__pyx_n_s_generate_schedule;
static PyObject *__pyx_n_s_get_index;
static PyObject *__pyx_n_s_get_index_by_isdaindex;
static PyObject *__pyx_n_s_get_sensitivities;
static PyObject *__pyx_n_s_getstate;
static PyObject *__pyx_n_s_holidays;
static PyObject *__pyx_n_u_i;
static PyObject *__pyx_n_s_id;
static PyObject *__pyx_n_s_idx;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_index_family;
static PyObject *__pyx_n_s_initial_value;
static PyObject *__pyx_n_s_interpolate;
static PyObject *__pyx_n_s_interpolate_with_sensitivities;
static PyObject *__pyx_n_s_interpolator_type;
static PyObject *__pyx_n_s_is_eom;
static PyObject *__pyx_n_s_is_holiday;
static PyObject *__pyx_n_s_isda_index;
static PyObject *__pyx_n_s_m;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_maturities;
static PyObject *__pyx_n_s_maturity_date;
static PyObject *__pyx_n_s_mdq;
static PyObject *__pyx_n_s_month;
static PyObject *__pyx_n_s_n;
static PyObject *__pyx_n_s_n_vars;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_new;
static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
static PyObject *__pyx_n_s_obj;
static PyObject *__pyx_n_s_order;
static PyObject *__pyx_n_s_parameters;
static PyObject *__pyx_n_s_parameters_2;
static PyObject *__pyx_n_s_parse;
static PyObject *__pyx_n_s_pickle;
static PyObject *__pyx_n_s_pricing_curve_type;
static PyObject *__pyx_n_s_pricing_script;
static PyObject *__pyx_n_s_pyx_PickleError;
static PyObject *__pyx_n_s_pyx_checksum;
static PyObject *__pyx_n_s_pyx_result;
static PyObject *__pyx_n_s_pyx_state;
static PyObject *__pyx_n_s_pyx_type;
static PyObject *__pyx_n_s_pyx_unpickle_ScheduleGenerator;
static PyObject *__pyx_n_s_pyx_vtable;
static PyObject *__pyx_n_s_qual;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_rate_type;
static PyObject *__pyx_n_s_reduce;
static PyObject *__pyx_n_s_reduce_cython;
static PyObject *__pyx_n_s_reduce_ex;
static PyObject *__pyx_n_s_redukti;
static PyObject *__pyx_n_s_redukti_2;
static PyObject *__pyx_kp_s_redukti_pyx;
static PyObject *__pyx_n_s_ref_date1;
static PyObject *__pyx_n_s_ref_date2;
static PyObject *__pyx_n_s_register_calendar;
static PyObject *__pyx_n_s_result;
static PyObject *__pyx_n_s_result_str;
static PyObject *__pyx_n_s_s;
static PyObject *__pyx_n_s_scenario;
static PyObject *__pyx_n_s_schedule;
static PyObject *__pyx_n_s_schedule_parameters;
static PyObject *__pyx_n_s_schedule_pb2;
static PyObject *__pyx_n_s_serial;
static PyObject *__pyx_n_s_serve;
static PyObject *__pyx_n_s_services_pb2;
static PyObject *__pyx_n_s_setstate;
static PyObject *__pyx_n_s_setstate_cython;
static PyObject *__pyx_n_s_staticmethod;
static PyObject *__pyx_n_s_status;
static PyObject *__pyx_n_s_str;
static PyObject *__pyx_kp_s_stringsource;
static PyObject *__pyx_n_s_tenor;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_time_from_reference;
static PyObject *__pyx_n_s_type;
static PyObject *__pyx_n_s_typecode;
static PyObject *__pyx_n_s_unadjusted;
static PyObject *__pyx_n_s_unit;
static PyObject *__pyx_n_s_update;
static PyObject *__pyx_n_s_v;
static PyObject *__pyx_n_s_value;
static PyObject *__pyx_n_s_value_date;
static PyObject *__pyx_n_s_values;
static PyObject *__pyx_n_s_variable;
static PyObject *__pyx_n_s_x;
static PyObject *__pyx_n_s_xdata;
static PyObject *__pyx_n_s_y;
static PyObject *__pyx_n_s_year;
static PyObject *__pyx_n_s_year_fraction;
static PyObject *__pyx_n_s_year_fraction_with_finalperiod;
static PyObject *__pyx_n_s_year_fraction_with_refdates;
static PyObject *__pyx_n_s_zero_curve;
static PyObject *__pyx_n_s_zero_rate;
static int __pyx_pf_8_redukti_5ADVar___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_ADVar *__pyx_v_self, CYTHON_UNUSED int __pyx_v_n_vars, CYTHON_UNUSED int __pyx_v_order, CYTHON_UNUSED int __pyx_v_variable, CYTHON_UNUSED double __pyx_v_initial_value); /* proto */
static int __pyx_pf_8_redukti_5ADVar_2__cinit__(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self, int __pyx_v_n_vars, int __pyx_v_order, int __pyx_v_variable, double __pyx_v_initial_value); /* proto */
static void __pyx_pf_8_redukti_5ADVar_4__dealloc__(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_5ADVar_6assign(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self, struct __pyx_obj_8_redukti_ADVar *__pyx_v_other); /* proto */
static PyObject *__pyx_pf_8_redukti_5ADVar_8value(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_5ADVar_10gradient(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_5ADVar_12hessian(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_5ADVar_14__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_ADVar *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_5ADVar_16__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_ADVar *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_4Date___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_self, CYTHON_UNUSED int __pyx_v_value); /* proto */
static int __pyx_pf_8_redukti_4Date_2__cinit__(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_v_value); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_4day(struct __pyx_obj_8_redukti_Date *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_6month(struct __pyx_obj_8_redukti_Date *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_8year(struct __pyx_obj_8_redukti_Date *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_10serial(struct __pyx_obj_8_redukti_Date *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_12dmy(unsigned int __pyx_v_d, unsigned int __pyx_v_m, int __pyx_v_y); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_14advance(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_v_n, enum redukti::PeriodUnit __pyx_v_unit); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_16parse(PyObject *__pyx_v_s); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_18__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_4Date_20__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static PyObject *__pyx_pf_8_redukti_17ScheduleGenerator_generate_schedule(PyObject *__pyx_v_schedule_parameters); /* proto */
static PyObject *__pyx_pf_8_redukti_17ScheduleGenerator_2__reduce_cython__(struct __pyx_obj_8_redukti_ScheduleGenerator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_17ScheduleGenerator_4__setstate_cython__(struct __pyx_obj_8_redukti_ScheduleGenerator *__pyx_v_self, PyObject *__pyx_v___pyx_state); /* proto */
static PyObject *__pyx_pf_8_redukti_convert_to_date_array(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_values); /* proto */
static int __pyx_pf_8_redukti_8Calendar___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_business_centres); /* proto */
static int __pyx_pf_8_redukti_8Calendar_2__cinit__(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, PyObject *__pyx_v_business_centres); /* proto */
static PyObject *__pyx_pf_8_redukti_8Calendar_4is_holiday(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_8Calendar_6last_day_of_month(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_8Calendar_8advance(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_date, int __pyx_v_n, enum redukti::PeriodUnit __pyx_v_unit, enum redukti::BusinessDayConvention __pyx_v_convention, int __pyx_v_is_eom); /* proto */
static PyObject *__pyx_pf_8_redukti_8Calendar_10adjust(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_date, enum redukti::BusinessDayConvention __pyx_v_convention); /* proto */
static PyObject *__pyx_pf_8_redukti_8Calendar_12register_calendar(enum redukti::BusinessCenter __pyx_v_id, PyObject *__pyx_v_holidays); /* proto */
static PyObject *__pyx_pf_8_redukti_8Calendar_14__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Calendar *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_8Calendar_16__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_11DayFraction___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_dfc); /* proto */
static int __pyx_pf_8_redukti_11DayFraction_2__cinit__(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, enum redukti::DayCountFraction __pyx_v_dfc); /* proto */
static PyObject *__pyx_pf_8_redukti_11DayFraction_4year_fraction(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2); /* proto */
static PyObject *__pyx_pf_8_redukti_11DayFraction_6year_fraction_with_finalperiod(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_v_final_period); /* proto */
static PyObject *__pyx_pf_8_redukti_11DayFraction_8year_fraction_with_refdates(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date1, struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date2); /* proto */
static PyObject *__pyx_pf_8_redukti_11DayFraction_10__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_11DayFraction_12__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_17InterestRateIndex___cinit__(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_2get_index_by_isdaindex(enum redukti::IsdaIndex __pyx_v_isda_index, enum redukti::Tenor __pyx_v_tenor); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_4get_index(enum redukti::Currency __pyx_v_currency, enum redukti::IndexFamily __pyx_v_index_family, enum redukti::Tenor __pyx_v_tenor); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_6value_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_fixing_date); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_8fixing_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_accrual_start_date); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_10maturity_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_value_date); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_12date_components(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_accrual_start_date); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_14adjust_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_unadjusted, int __pyx_v_days); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_16__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_18__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_12Interpolator___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, CYTHON_UNUSED enum redukti::InterpolatorType __pyx_v_interpolator_type, CYTHON_UNUSED arrayobject *__pyx_v_x, CYTHON_UNUSED arrayobject *__pyx_v_y, CYTHON_UNUSED int __pyx_v_order); /* proto */
static int __pyx_pf_8_redukti_12Interpolator_2__cinit__(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, enum redukti::InterpolatorType __pyx_v_interpolator_type, arrayobject *__pyx_v_x, arrayobject *__pyx_v_y, int __pyx_v_order); /* proto */
static void __pyx_pf_8_redukti_12Interpolator_4__dealloc__(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_12Interpolator_6interpolate(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x); /* proto */
static PyObject *__pyx_pf_8_redukti_12Interpolator_8interpolate_with_sensitivities(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x); /* proto */
static PyObject *__pyx_pf_8_redukti_12Interpolator_10__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_12Interpolator_12__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_7CurveId___cinit__(struct __pyx_obj_8_redukti_CurveId *__pyx_v_self, enum redukti::PricingCurveType __pyx_v_pricing_curve_type, enum redukti::Currency __pyx_v_ccy, enum redukti::IndexFamily __pyx_v_index_family, enum redukti::Tenor __pyx_v_tenor, struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, int __pyx_v_cycle, enum redukti::MarketDataQualifier __pyx_v_qual, int __pyx_v_scenario); /* proto */
static PyObject *__pyx_pf_8_redukti_7CurveId_2id(struct __pyx_obj_8_redukti_CurveId *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_7CurveId_4__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_CurveId *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_7CurveId_6__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_CurveId *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_22InterpolatedYieldCurve___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, CYTHON_UNUSED PY_LONG_LONG __pyx_v_id, CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, CYTHON_UNUSED PyObject *__pyx_v_maturities, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED enum redukti::InterpolatorType __pyx_v_interpolator_type, CYTHON_UNUSED enum redukti::IRRateType __pyx_v_rate_type, CYTHON_UNUSED int __pyx_v_deriv_order, CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_fraction); /* proto */
static int __pyx_pf_8_redukti_22InterpolatedYieldCurve_2__cinit__(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, PY_LONG_LONG __pyx_v_id, struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, PyObject *__pyx_v_maturities, PyObject *__pyx_v_values, enum redukti::InterpolatorType __pyx_v_interpolator_type, enum redukti::IRRateType __pyx_v_rate_type, int __pyx_v_deriv_order, enum redukti::DayCountFraction __pyx_v_fraction); /* proto */
static void __pyx_pf_8_redukti_22InterpolatedYieldCurve_4__dealloc__(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_6discount(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_8zero_rate(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_10forward_rate(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2); /* proto */
static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_12time_from_reference(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_14get_sensitivities(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, double __pyx_v_x); /* proto */
static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_16__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_18__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_13SvenssonCurve___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, CYTHON_UNUSED PY_LONG_LONG __pyx_v_id, CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, CYTHON_UNUSED PyObject *__pyx_v_parameters, CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_fraction); /* proto */
static int __pyx_pf_8_redukti_13SvenssonCurve_2__cinit__(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, PY_LONG_LONG __pyx_v_id, struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, PyObject *__pyx_v_parameters, enum redukti::DayCountFraction __pyx_v_fraction); /* proto */
static void __pyx_pf_8_redukti_13SvenssonCurve_4__dealloc__(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_6discount(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_8zero_rate(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_10forward_rate(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2); /* proto */
static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_12time_from_reference(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_14__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_16__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_10YieldCurve___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_business_date, CYTHON_UNUSED PyObject *__pyx_v_curve_defn, CYTHON_UNUSED PyObject *__pyx_v_zero_curve, CYTHON_UNUSED int __pyx_v_deriv_order, CYTHON_UNUSED enum redukti::PricingCurveType __pyx_v_type, CYTHON_UNUSED enum redukti::MarketDataQualifier __pyx_v_mdq, CYTHON_UNUSED int __pyx_v_cycle, CYTHON_UNUSED int __pyx_v_scenario); /* proto */
static int __pyx_pf_8_redukti_10YieldCurve_2__cinit__(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_business_date, PyObject *__pyx_v_curve_defn, PyObject *__pyx_v_zero_curve, int __pyx_v_deriv_order, enum redukti::PricingCurveType __pyx_v_type, enum redukti::MarketDataQualifier __pyx_v_mdq, int __pyx_v_cycle, int __pyx_v_scenario); /* proto */
static void __pyx_pf_8_redukti_10YieldCurve_4__dealloc__(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_10YieldCurve_6discount(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_10YieldCurve_8zero_rate(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_10YieldCurve_10forward_rate(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2); /* proto */
static PyObject *__pyx_pf_8_redukti_10YieldCurve_12time_from_reference(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d); /* proto */
static PyObject *__pyx_pf_8_redukti_10YieldCurve_14get_sensitivities(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, double __pyx_v_x); /* proto */
static PyObject *__pyx_pf_8_redukti_10YieldCurve_16__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_10YieldCurve_18__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_8_redukti_24InMemoryRequestProcessor___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_pricing_script); /* proto */
static int __pyx_pf_8_redukti_24InMemoryRequestProcessor_2__cinit__(struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, PyObject *__pyx_v_pricing_script); /* proto */
static PyObject *__pyx_pf_8_redukti_24InMemoryRequestProcessor_4serve(struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, PyObject *__pyx_v_request); /* proto */
static PyObject *__pyx_pf_8_redukti_24InMemoryRequestProcessor_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_8_redukti_24InMemoryRequestProcessor_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
static PyObject *__pyx_pf_8_redukti_2__pyx_unpickle_ScheduleGenerator(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
static int __pyx_pf_7cpython_5array_5array___getbuffer__(arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info, CYTHON_UNUSED int __pyx_v_flags); /* proto */
static void __pyx_pf_7cpython_5array_5array_2__releasebuffer__(CYTHON_UNUSED arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info); /* proto */
static PyObject *__pyx_tp_new_8_redukti_ADVar(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_Date(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_ScheduleGenerator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_Calendar(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_DayFraction(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_InterestRateIndex(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_Interpolator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_CurveId(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_InterpolatedYieldCurve(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_SvenssonCurve(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_YieldCurve(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_8_redukti_InMemoryRequestProcessor(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_float_0_0;
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_222419149;
static enum redukti::BusinessDayConvention __pyx_k__22;
static enum redukti::BusinessDayConvention __pyx_k__23;
static enum redukti::MarketDataQualifier __pyx_k__43;
static enum redukti::PricingCurveType __pyx_k__55;
static enum redukti::MarketDataQualifier __pyx_k__56;
static enum redukti::PricingCurveType __pyx_k__57;
static enum redukti::MarketDataQualifier __pyx_k__58;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__7;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_tuple__10;
static PyObject *__pyx_tuple__11;
static PyObject *__pyx_tuple__12;
static PyObject *__pyx_tuple__13;
static PyObject *__pyx_tuple__14;
static PyObject *__pyx_tuple__15;
static PyObject *__pyx_tuple__16;
static PyObject *__pyx_tuple__17;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__19;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__21;
static PyObject *__pyx_tuple__24;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__26;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__29;
static PyObject *__pyx_tuple__30;
static PyObject *__pyx_tuple__31;
static PyObject *__pyx_tuple__32;
static PyObject *__pyx_tuple__33;
static PyObject *__pyx_tuple__34;
static PyObject *__pyx_tuple__35;
static PyObject *__pyx_tuple__36;
static PyObject *__pyx_tuple__37;
static PyObject *__pyx_tuple__38;
static PyObject *__pyx_tuple__39;
static PyObject *__pyx_tuple__40;
static PyObject *__pyx_tuple__41;
static PyObject *__pyx_tuple__42;
static PyObject *__pyx_tuple__44;
static PyObject *__pyx_tuple__45;
static PyObject *__pyx_tuple__46;
static PyObject *__pyx_tuple__47;
static PyObject *__pyx_tuple__48;
static PyObject *__pyx_tuple__49;
static PyObject *__pyx_tuple__50;
static PyObject *__pyx_tuple__51;
static PyObject *__pyx_tuple__52;
static PyObject *__pyx_tuple__53;
static PyObject *__pyx_tuple__54;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__60;
static PyObject *__pyx_tuple__61;
static PyObject *__pyx_tuple__62;
static PyObject *__pyx_tuple__63;
static PyObject *__pyx_tuple__64;
static PyObject *__pyx_tuple__65;
static PyObject *__pyx_tuple__66;
static PyObject *__pyx_tuple__67;
static PyObject *__pyx_tuple__68;
static PyObject *__pyx_tuple__69;
static PyObject *__pyx_tuple__70;
static PyObject *__pyx_tuple__72;
static PyObject *__pyx_tuple__74;
static PyObject *__pyx_tuple__76;
static PyObject *__pyx_tuple__78;
static PyObject *__pyx_tuple__80;
static PyObject *__pyx_tuple__82;
static PyObject *__pyx_tuple__84;
static PyObject *__pyx_codeobj__71;
static PyObject *__pyx_codeobj__73;
static PyObject *__pyx_codeobj__75;
static PyObject *__pyx_codeobj__77;
static PyObject *__pyx_codeobj__79;
static PyObject *__pyx_codeobj__81;
static PyObject *__pyx_codeobj__83;
static PyObject *__pyx_codeobj__85;
/* Late includes */

/* "_redukti.pyx":48
 *     cdef int _order
 * 
 *     def __init__(self, int n_vars, int order, int variable, double initial_value):             # <<<<<<<<<<<<<<
 *         """
 *         Construct a new ADVar variable.
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_5ADVar_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_5ADVar___init__[] = "\n        Construct a new ADVar variable.\n\n        Args:\n            n_vars: Number of variables in the function\n            order: The order can be ``0``, ``1``, or ``2`` and says whether 1st order and 2nd order derivatives should be computed\n            variable: This variable's id in the function's set of variables, ``-1`` can be used signify no position\n            initial_value: The value assigned to the variable initailly\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_8_redukti_5ADVar___init__;
#endif
static int __pyx_pw_8_redukti_5ADVar_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED int __pyx_v_n_vars;
  CYTHON_UNUSED int __pyx_v_order;
  CYTHON_UNUSED int __pyx_v_variable;
  CYTHON_UNUSED double __pyx_v_initial_value;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n_vars,&__pyx_n_s_order,&__pyx_n_s_variable,&__pyx_n_s_initial_value,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n_vars)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 4, 4, 1); __PYX_ERR(0, 48, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_variable)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 4, 4, 2); __PYX_ERR(0, 48, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_initial_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 4, 4, 3); __PYX_ERR(0, 48, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 48, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_n_vars = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_n_vars == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L3_error)
    __pyx_v_order = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L3_error)
    __pyx_v_variable = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_variable == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L3_error)
    __pyx_v_initial_value = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_initial_value == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 48, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 48, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.ADVar.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_5ADVar___init__(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self), __pyx_v_n_vars, __pyx_v_order, __pyx_v_variable, __pyx_v_initial_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_5ADVar___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_ADVar *__pyx_v_self, CYTHON_UNUSED int __pyx_v_n_vars, CYTHON_UNUSED int __pyx_v_order, CYTHON_UNUSED int __pyx_v_variable, CYTHON_UNUSED double __pyx_v_initial_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":60
 *         pass
 * 
 *     def __cinit__(self, int n_vars, int order, int variable, double initial_value):             # <<<<<<<<<<<<<<
 *         if n_vars <= 0:
 *             raise ValueError('Number of variables in ADVar must be > 0')
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_5ADVar_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_5ADVar_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_n_vars;
  int __pyx_v_order;
  int __pyx_v_variable;
  double __pyx_v_initial_value;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n_vars,&__pyx_n_s_order,&__pyx_n_s_variable,&__pyx_n_s_initial_value,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n_vars)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 4, 4, 1); __PYX_ERR(0, 60, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_variable)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 4, 4, 2); __PYX_ERR(0, 60, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_initial_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 4, 4, 3); __PYX_ERR(0, 60, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 60, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_n_vars = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_n_vars == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 60, __pyx_L3_error)
    __pyx_v_order = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 60, __pyx_L3_error)
    __pyx_v_variable = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_variable == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 60, __pyx_L3_error)
    __pyx_v_initial_value = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_initial_value == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 60, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 60, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.ADVar.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_5ADVar_2__cinit__(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self), __pyx_v_n_vars, __pyx_v_order, __pyx_v_variable, __pyx_v_initial_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_5ADVar_2__cinit__(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self, int __pyx_v_n_vars, int __pyx_v_order, int __pyx_v_variable, double __pyx_v_initial_value) {
  size_t __pyx_v_size;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":61
 * 
 *     def __cinit__(self, int n_vars, int order, int variable, double initial_value):
 *         if n_vars <= 0:             # <<<<<<<<<<<<<<
 *             raise ValueError('Number of variables in ADVar must be > 0')
 *         if order < 0 or order > 2:
 */
  __pyx_t_1 = ((__pyx_v_n_vars <= 0) != 0);
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":62
 *     def __cinit__(self, int n_vars, int order, int variable, double initial_value):
 *         if n_vars <= 0:
 *             raise ValueError('Number of variables in ADVar must be > 0')             # <<<<<<<<<<<<<<
 *         if order < 0 or order > 2:
 *             raise ValueError('Order must be between 0 and 2')
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 62, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 62, __pyx_L1_error)

    /* "_redukti.pyx":61
 * 
 *     def __cinit__(self, int n_vars, int order, int variable, double initial_value):
 *         if n_vars <= 0:             # <<<<<<<<<<<<<<
 *             raise ValueError('Number of variables in ADVar must be > 0')
 *         if order < 0 or order > 2:
 */
  }

  /* "_redukti.pyx":63
 *         if n_vars <= 0:
 *             raise ValueError('Number of variables in ADVar must be > 0')
 *         if order < 0 or order > 2:             # <<<<<<<<<<<<<<
 *             raise ValueError('Order must be between 0 and 2')
 *         if variable < -1 or variable >= n_vars:
 */
  __pyx_t_3 = ((__pyx_v_order < 0) != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_3 = ((__pyx_v_order > 2) != 0);
  __pyx_t_1 = __pyx_t_3;
  __pyx_L5_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":64
 *             raise ValueError('Number of variables in ADVar must be > 0')
 *         if order < 0 or order > 2:
 *             raise ValueError('Order must be between 0 and 2')             # <<<<<<<<<<<<<<
 *         if variable < -1 or variable >= n_vars:
 *             raise ValueError('Variable index is out of range')
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 64, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 64, __pyx_L1_error)

    /* "_redukti.pyx":63
 *         if n_vars <= 0:
 *             raise ValueError('Number of variables in ADVar must be > 0')
 *         if order < 0 or order > 2:             # <<<<<<<<<<<<<<
 *             raise ValueError('Order must be between 0 and 2')
 *         if variable < -1 or variable >= n_vars:
 */
  }

  /* "_redukti.pyx":65
 *         if order < 0 or order > 2:
 *             raise ValueError('Order must be between 0 and 2')
 *         if variable < -1 or variable >= n_vars:             # <<<<<<<<<<<<<<
 *             raise ValueError('Variable index is out of range')
 *         cdef size_t size = autodiff.redukti_adouble_alloc_size(n_vars, order)
 */
  __pyx_t_3 = ((__pyx_v_variable < -1L) != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_3 = ((__pyx_v_variable >= __pyx_v_n_vars) != 0);
  __pyx_t_1 = __pyx_t_3;
  __pyx_L8_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":66
 *             raise ValueError('Order must be between 0 and 2')
 *         if variable < -1 or variable >= n_vars:
 *             raise ValueError('Variable index is out of range')             # <<<<<<<<<<<<<<
 *         cdef size_t size = autodiff.redukti_adouble_alloc_size(n_vars, order)
 *         self._ad = <autodiff.redukti_adouble_t*> PyMem_Malloc(size)
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 66, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 66, __pyx_L1_error)

    /* "_redukti.pyx":65
 *         if order < 0 or order > 2:
 *             raise ValueError('Order must be between 0 and 2')
 *         if variable < -1 or variable >= n_vars:             # <<<<<<<<<<<<<<
 *             raise ValueError('Variable index is out of range')
 *         cdef size_t size = autodiff.redukti_adouble_alloc_size(n_vars, order)
 */
  }

  /* "_redukti.pyx":67
 *         if variable < -1 or variable >= n_vars:
 *             raise ValueError('Variable index is out of range')
 *         cdef size_t size = autodiff.redukti_adouble_alloc_size(n_vars, order)             # <<<<<<<<<<<<<<
 *         self._ad = <autodiff.redukti_adouble_t*> PyMem_Malloc(size)
 *         self._vars = n_vars
 */
  __pyx_v_size = redukti_adouble_alloc_size(__pyx_v_n_vars, __pyx_v_order);

  /* "_redukti.pyx":68
 *             raise ValueError('Variable index is out of range')
 *         cdef size_t size = autodiff.redukti_adouble_alloc_size(n_vars, order)
 *         self._ad = <autodiff.redukti_adouble_t*> PyMem_Malloc(size)             # <<<<<<<<<<<<<<
 *         self._vars = n_vars
 *         self._order = order
 */
  __pyx_v_self->_ad = ((redukti_adouble_t *)PyMem_Malloc(__pyx_v_size));

  /* "_redukti.pyx":69
 *         cdef size_t size = autodiff.redukti_adouble_alloc_size(n_vars, order)
 *         self._ad = <autodiff.redukti_adouble_t*> PyMem_Malloc(size)
 *         self._vars = n_vars             # <<<<<<<<<<<<<<
 *         self._order = order
 *         autodiff.redukti_adouble_init(self._ad, n_vars, order, variable, initial_value)
 */
  __pyx_v_self->_vars = __pyx_v_n_vars;

  /* "_redukti.pyx":70
 *         self._ad = <autodiff.redukti_adouble_t*> PyMem_Malloc(size)
 *         self._vars = n_vars
 *         self._order = order             # <<<<<<<<<<<<<<
 *         autodiff.redukti_adouble_init(self._ad, n_vars, order, variable, initial_value)
 * 
 */
  __pyx_v_self->_order = __pyx_v_order;

  /* "_redukti.pyx":71
 *         self._vars = n_vars
 *         self._order = order
 *         autodiff.redukti_adouble_init(self._ad, n_vars, order, variable, initial_value)             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  redukti_adouble_init(__pyx_v_self->_ad, __pyx_v_n_vars, __pyx_v_order, __pyx_v_variable, __pyx_v_initial_value);

  /* "_redukti.pyx":60
 *         pass
 * 
 *     def __cinit__(self, int n_vars, int order, int variable, double initial_value):             # <<<<<<<<<<<<<<
 *         if n_vars <= 0:
 *             raise ValueError('Number of variables in ADVar must be > 0')
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.ADVar.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":73
 *         autodiff.redukti_adouble_init(self._ad, n_vars, order, variable, initial_value)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         PyMem_Free(self._ad)
 * 
 */

/* Python wrapper */
static void __pyx_pw_8_redukti_5ADVar_5__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_8_redukti_5ADVar_5__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_8_redukti_5ADVar_4__dealloc__(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_8_redukti_5ADVar_4__dealloc__(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "_redukti.pyx":74
 * 
 *     def __dealloc__(self):
 *         PyMem_Free(self._ad)             # <<<<<<<<<<<<<<
 * 
 *     def assign(self, ADVar other):
 */
  PyMem_Free(__pyx_v_self->_ad);

  /* "_redukti.pyx":73
 *         autodiff.redukti_adouble_init(self._ad, n_vars, order, variable, initial_value)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         PyMem_Free(self._ad)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "_redukti.pyx":76
 *         PyMem_Free(self._ad)
 * 
 *     def assign(self, ADVar other):             # <<<<<<<<<<<<<<
 *         """
 *         Sets this variables data to be the same as the ``other``.
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_5ADVar_7assign(PyObject *__pyx_v_self, PyObject *__pyx_v_other); /*proto*/
static char __pyx_doc_8_redukti_5ADVar_6assign[] = "ADVar.assign(self, ADVar other)\n\n        Sets this variables data to be the same as the ``other``.\n\n        Args:\n            other: The variable to be copied from\n\n        Note that the ``other`` variable must be the same size and order\n        ";
static PyObject *__pyx_pw_8_redukti_5ADVar_7assign(PyObject *__pyx_v_self, PyObject *__pyx_v_other) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("assign (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_other), __pyx_ptype_8_redukti_ADVar, 1, "other", 0))) __PYX_ERR(0, 76, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_5ADVar_6assign(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self), ((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_other));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_5ADVar_6assign(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self, struct __pyx_obj_8_redukti_ADVar *__pyx_v_other) {
  PyObject *__pyx_v_is_compatible = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("assign", 0);

  /* "_redukti.pyx":85
 *         Note that the ``other`` variable must be the same size and order
 *         """
 *         is_compatible = self._vars == other._vars and self._order == other._order             # <<<<<<<<<<<<<<
 *         if not is_compatible:
 *             raise ValueError('Supplied values are not of the same order or size')
 */
  __pyx_t_2 = (__pyx_v_self->_vars == __pyx_v_other->_vars);
  if (__pyx_t_2) {
  } else {
    __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 85, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L3_bool_binop_done;
  }
  __pyx_t_2 = (__pyx_v_self->_order == __pyx_v_other->_order);
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 85, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __pyx_t_3;
  __pyx_t_3 = 0;
  __pyx_L3_bool_binop_done:;
  __pyx_v_is_compatible = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_redukti.pyx":86
 *         """
 *         is_compatible = self._vars == other._vars and self._order == other._order
 *         if not is_compatible:             # <<<<<<<<<<<<<<
 *             raise ValueError('Supplied values are not of the same order or size')
 *         autodiff.redukti_adouble_assign(self._ad, other._ad)
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_is_compatible); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 86, __pyx_L1_error)
  __pyx_t_4 = ((!__pyx_t_2) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "_redukti.pyx":87
 *         is_compatible = self._vars == other._vars and self._order == other._order
 *         if not is_compatible:
 *             raise ValueError('Supplied values are not of the same order or size')             # <<<<<<<<<<<<<<
 *         autodiff.redukti_adouble_assign(self._ad, other._ad)
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 87, __pyx_L1_error)

    /* "_redukti.pyx":86
 *         """
 *         is_compatible = self._vars == other._vars and self._order == other._order
 *         if not is_compatible:             # <<<<<<<<<<<<<<
 *             raise ValueError('Supplied values are not of the same order or size')
 *         autodiff.redukti_adouble_assign(self._ad, other._ad)
 */
  }

  /* "_redukti.pyx":88
 *         if not is_compatible:
 *             raise ValueError('Supplied values are not of the same order or size')
 *         autodiff.redukti_adouble_assign(self._ad, other._ad)             # <<<<<<<<<<<<<<
 * 
 *     @staticmethod
 */
  redukti_adouble_assign(__pyx_v_self->_ad, __pyx_v_other->_ad);

  /* "_redukti.pyx":76
 *         PyMem_Free(self._ad)
 * 
 *     def assign(self, ADVar other):             # <<<<<<<<<<<<<<
 *         """
 *         Sets this variables data to be the same as the ``other``.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.ADVar.assign", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_is_compatible);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":91
 * 
 *     @staticmethod
 *     cdef dup(autodiff.redukti_adouble_t *value):             # <<<<<<<<<<<<<<
 *         """
 *         Duplicates an autodiff value
 */

static PyObject *__pyx_f_8_redukti_5ADVar_dup(redukti_adouble_t *__pyx_v_value) {
  int __pyx_v_n_vars;
  int __pyx_v_order;
  struct __pyx_obj_8_redukti_ADVar *__pyx_v_copy = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("dup", 0);

  /* "_redukti.pyx":101
 *             New ADVar object that is a copy
 *         """
 *         if value is NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError('NULL value supplied')
 *         cdef int n_vars = autodiff.redukti_adouble_get_nvars(value)
 */
  __pyx_t_1 = ((__pyx_v_value == NULL) != 0);
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":102
 *         """
 *         if value is NULL:
 *             raise ValueError('NULL value supplied')             # <<<<<<<<<<<<<<
 *         cdef int n_vars = autodiff.redukti_adouble_get_nvars(value)
 *         cdef int order = autodiff.redukti_adouble_get_order(value)
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 102, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 102, __pyx_L1_error)

    /* "_redukti.pyx":101
 *             New ADVar object that is a copy
 *         """
 *         if value is NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError('NULL value supplied')
 *         cdef int n_vars = autodiff.redukti_adouble_get_nvars(value)
 */
  }

  /* "_redukti.pyx":103
 *         if value is NULL:
 *             raise ValueError('NULL value supplied')
 *         cdef int n_vars = autodiff.redukti_adouble_get_nvars(value)             # <<<<<<<<<<<<<<
 *         cdef int order = autodiff.redukti_adouble_get_order(value)
 *         cdef ADVar copy = ADVar(n_vars, order, 0, 0.0)
 */
  __pyx_v_n_vars = redukti_adouble_get_nvars(__pyx_v_value);

  /* "_redukti.pyx":104
 *             raise ValueError('NULL value supplied')
 *         cdef int n_vars = autodiff.redukti_adouble_get_nvars(value)
 *         cdef int order = autodiff.redukti_adouble_get_order(value)             # <<<<<<<<<<<<<<
 *         cdef ADVar copy = ADVar(n_vars, order, 0, 0.0)
 *         autodiff.redukti_adouble_assign(copy._ad, value)
 */
  __pyx_v_order = redukti_adouble_get_order(__pyx_v_value);

  /* "_redukti.pyx":105
 *         cdef int n_vars = autodiff.redukti_adouble_get_nvars(value)
 *         cdef int order = autodiff.redukti_adouble_get_order(value)
 *         cdef ADVar copy = ADVar(n_vars, order, 0, 0.0)             # <<<<<<<<<<<<<<
 *         autodiff.redukti_adouble_assign(copy._ad, value)
 *         return copy
 */
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_n_vars); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 105, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_order); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 105, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyTuple_New(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 105, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
  __Pyx_INCREF(__pyx_int_0);
  __Pyx_GIVEREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_int_0);
  __Pyx_INCREF(__pyx_float_0_0);
  __Pyx_GIVEREF(__pyx_float_0_0);
  PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_float_0_0);
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_8_redukti_ADVar), __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 105, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_copy = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "_redukti.pyx":106
 *         cdef int order = autodiff.redukti_adouble_get_order(value)
 *         cdef ADVar copy = ADVar(n_vars, order, 0, 0.0)
 *         autodiff.redukti_adouble_assign(copy._ad, value)             # <<<<<<<<<<<<<<
 *         return copy
 * 
 */
  redukti_adouble_assign(__pyx_v_copy->_ad, __pyx_v_value);

  /* "_redukti.pyx":107
 *         cdef ADVar copy = ADVar(n_vars, order, 0, 0.0)
 *         autodiff.redukti_adouble_assign(copy._ad, value)
 *         return copy             # <<<<<<<<<<<<<<
 * 
 *     def value(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_copy));
  __pyx_r = ((PyObject *)__pyx_v_copy);
  goto __pyx_L0;

  /* "_redukti.pyx":91
 * 
 *     @staticmethod
 *     cdef dup(autodiff.redukti_adouble_t *value):             # <<<<<<<<<<<<<<
 *         """
 *         Duplicates an autodiff value
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_redukti.ADVar.dup", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_copy);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":109
 *         return copy
 * 
 *     def value(self):             # <<<<<<<<<<<<<<
 *         """
 *         Returns the value of the variable.
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_5ADVar_9value(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_5ADVar_8value[] = "ADVar.value(self)\n\n        Returns the value of the variable.\n        ";
static PyObject *__pyx_pw_8_redukti_5ADVar_9value(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("value (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_5ADVar_8value(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_5ADVar_8value(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("value", 0);

  /* "_redukti.pyx":113
 *         Returns the value of the variable.
 *         """
 *         return autodiff.redukti_adouble_get_value(self._ad)             # <<<<<<<<<<<<<<
 * 
 *     def gradient(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(redukti_adouble_get_value(__pyx_v_self->_ad)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 113, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":109
 *         return copy
 * 
 *     def value(self):             # <<<<<<<<<<<<<<
 *         """
 *         Returns the value of the variable.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.ADVar.value", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":115
 *         return autodiff.redukti_adouble_get_value(self._ad)
 * 
 *     def gradient(self):             # <<<<<<<<<<<<<<
 *         """
 *         Returns the first order derivatives if available else empty list
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_5ADVar_11gradient(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_5ADVar_10gradient[] = "ADVar.gradient(self)\n\n        Returns the first order derivatives if available else empty list\n        ";
static PyObject *__pyx_pw_8_redukti_5ADVar_11gradient(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("gradient (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_5ADVar_10gradient(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_5ADVar_10gradient(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self) {
  PyObject *__pyx_v_g = NULL;
  long __pyx_v_i;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  long __pyx_t_5;
  int __pyx_t_6;
  __Pyx_RefNannySetupContext("gradient", 0);

  /* "_redukti.pyx":119
 *         Returns the first order derivatives if available else empty list
 *         """
 *         g = []             # <<<<<<<<<<<<<<
 *         if self._order == 0:
 *             return g
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 119, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_g = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":120
 *         """
 *         g = []
 *         if self._order == 0:             # <<<<<<<<<<<<<<
 *             return g
 *         for i in range(0, self._vars):
 */
  __pyx_t_2 = ((__pyx_v_self->_order == 0) != 0);
  if (__pyx_t_2) {

    /* "_redukti.pyx":121
 *         g = []
 *         if self._order == 0:
 *             return g             # <<<<<<<<<<<<<<
 *         for i in range(0, self._vars):
 *             list.append(g, autodiff.redukti_adouble_get_derivative1(self._ad, i))
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_g);
    __pyx_r = __pyx_v_g;
    goto __pyx_L0;

    /* "_redukti.pyx":120
 *         """
 *         g = []
 *         if self._order == 0:             # <<<<<<<<<<<<<<
 *             return g
 *         for i in range(0, self._vars):
 */
  }

  /* "_redukti.pyx":122
 *         if self._order == 0:
 *             return g
 *         for i in range(0, self._vars):             # <<<<<<<<<<<<<<
 *             list.append(g, autodiff.redukti_adouble_get_derivative1(self._ad, i))
 *         return g
 */
  __pyx_t_3 = __pyx_v_self->_vars;
  __pyx_t_4 = __pyx_t_3;
  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
    __pyx_v_i = __pyx_t_5;

    /* "_redukti.pyx":123
 *             return g
 *         for i in range(0, self._vars):
 *             list.append(g, autodiff.redukti_adouble_get_derivative1(self._ad, i))             # <<<<<<<<<<<<<<
 *         return g
 * 
 */
    __pyx_t_1 = PyFloat_FromDouble(redukti_adouble_get_derivative1(__pyx_v_self->_ad, __pyx_v_i)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 123, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = __Pyx_PyList_Append(__pyx_v_g, __pyx_t_1); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 123, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "_redukti.pyx":124
 *         for i in range(0, self._vars):
 *             list.append(g, autodiff.redukti_adouble_get_derivative1(self._ad, i))
 *         return g             # <<<<<<<<<<<<<<
 * 
 *     def hessian(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_g);
  __pyx_r = __pyx_v_g;
  goto __pyx_L0;

  /* "_redukti.pyx":115
 *         return autodiff.redukti_adouble_get_value(self._ad)
 * 
 *     def gradient(self):             # <<<<<<<<<<<<<<
 *         """
 *         Returns the first order derivatives if available else empty list
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.ADVar.gradient", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_g);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":126
 *         return g
 * 
 *     def hessian(self):             # <<<<<<<<<<<<<<
 *         """
 *         Returns the second order derivatives if available else empty list
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_5ADVar_13hessian(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_5ADVar_12hessian[] = "ADVar.hessian(self)\n\n        Returns the second order derivatives if available else empty list\n        ";
static PyObject *__pyx_pw_8_redukti_5ADVar_13hessian(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hessian (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_5ADVar_12hessian(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_5ADVar_12hessian(struct __pyx_obj_8_redukti_ADVar *__pyx_v_self) {
  PyObject *__pyx_v_h = NULL;
  long __pyx_v_i;
  PyObject *__pyx_v_g = NULL;
  long __pyx_v_j;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  long __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  long __pyx_t_9;
  __Pyx_RefNannySetupContext("hessian", 0);

  /* "_redukti.pyx":130
 *         Returns the second order derivatives if available else empty list
 *         """
 *         h = []             # <<<<<<<<<<<<<<
 *         if self._order < 2:
 *             return h
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_h = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":131
 *         """
 *         h = []
 *         if self._order < 2:             # <<<<<<<<<<<<<<
 *             return h
 *         for i in range(0, self._vars):
 */
  __pyx_t_2 = ((__pyx_v_self->_order < 2) != 0);
  if (__pyx_t_2) {

    /* "_redukti.pyx":132
 *         h = []
 *         if self._order < 2:
 *             return h             # <<<<<<<<<<<<<<
 *         for i in range(0, self._vars):
 *             g = []
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_h);
    __pyx_r = __pyx_v_h;
    goto __pyx_L0;

    /* "_redukti.pyx":131
 *         """
 *         h = []
 *         if self._order < 2:             # <<<<<<<<<<<<<<
 *             return h
 *         for i in range(0, self._vars):
 */
  }

  /* "_redukti.pyx":133
 *         if self._order < 2:
 *             return h
 *         for i in range(0, self._vars):             # <<<<<<<<<<<<<<
 *             g = []
 *             h.append(g)
 */
  __pyx_t_3 = __pyx_v_self->_vars;
  __pyx_t_4 = __pyx_t_3;
  for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
    __pyx_v_i = __pyx_t_5;

    /* "_redukti.pyx":134
 *             return h
 *         for i in range(0, self._vars):
 *             g = []             # <<<<<<<<<<<<<<
 *             h.append(g)
 *             for j in range(0, self._vars):
 */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 134, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_XDECREF_SET(__pyx_v_g, ((PyObject*)__pyx_t_1));
    __pyx_t_1 = 0;

    /* "_redukti.pyx":135
 *         for i in range(0, self._vars):
 *             g = []
 *             h.append(g)             # <<<<<<<<<<<<<<
 *             for j in range(0, self._vars):
 *                 list.append(g, autodiff.redukti_adouble_get_derivative2(self._ad, i, j))
 */
    __pyx_t_6 = __Pyx_PyList_Append(__pyx_v_h, __pyx_v_g); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 135, __pyx_L1_error)

    /* "_redukti.pyx":136
 *             g = []
 *             h.append(g)
 *             for j in range(0, self._vars):             # <<<<<<<<<<<<<<
 *                 list.append(g, autodiff.redukti_adouble_get_derivative2(self._ad, i, j))
 *         return h
 */
    __pyx_t_7 = __pyx_v_self->_vars;
    __pyx_t_8 = __pyx_t_7;
    for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
      __pyx_v_j = __pyx_t_9;

      /* "_redukti.pyx":137
 *             h.append(g)
 *             for j in range(0, self._vars):
 *                 list.append(g, autodiff.redukti_adouble_get_derivative2(self._ad, i, j))             # <<<<<<<<<<<<<<
 *         return h
 * 
 */
      __pyx_t_1 = PyFloat_FromDouble(redukti_adouble_get_derivative2(__pyx_v_self->_ad, __pyx_v_i, __pyx_v_j)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = __Pyx_PyList_Append(__pyx_v_g, __pyx_t_1); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 137, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    }
  }

  /* "_redukti.pyx":138
 *             for j in range(0, self._vars):
 *                 list.append(g, autodiff.redukti_adouble_get_derivative2(self._ad, i, j))
 *         return h             # <<<<<<<<<<<<<<
 * 
 * cdef validate_periodunit(enums.PeriodUnit unit):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_h);
  __pyx_r = __pyx_v_h;
  goto __pyx_L0;

  /* "_redukti.pyx":126
 *         return g
 * 
 *     def hessian(self):             # <<<<<<<<<<<<<<
 *         """
 *         Returns the second order derivatives if available else empty list
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.ADVar.hessian", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_h);
  __Pyx_XDECREF(__pyx_v_g);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_5ADVar_15__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_5ADVar_14__reduce_cython__[] = "ADVar.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_5ADVar_15__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_5ADVar_14__reduce_cython__(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_5ADVar_14__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_ADVar *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.ADVar.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_5ADVar_17__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_5ADVar_16__setstate_cython__[] = "ADVar.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_5ADVar_17__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_5ADVar_16__setstate_cython__(((struct __pyx_obj_8_redukti_ADVar *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_5ADVar_16__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_ADVar *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.ADVar.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":140
 *         return h
 * 
 * cdef validate_periodunit(enums.PeriodUnit unit):             # <<<<<<<<<<<<<<
 *     if unit < 1 or unit > enums.YEARS:
 *         raise ValueError('Invalid PeriodUnit specified')
 */

static PyObject *__pyx_f_8_redukti_validate_periodunit(enum redukti::PeriodUnit __pyx_v_unit) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("validate_periodunit", 0);

  /* "_redukti.pyx":141
 * 
 * cdef validate_periodunit(enums.PeriodUnit unit):
 *     if unit < 1 or unit > enums.YEARS:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid PeriodUnit specified')
 * 
 */
  __pyx_t_2 = ((__pyx_v_unit < 1) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((__pyx_v_unit > redukti::YEARS) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":142
 * cdef validate_periodunit(enums.PeriodUnit unit):
 *     if unit < 1 or unit > enums.YEARS:
 *         raise ValueError('Invalid PeriodUnit specified')             # <<<<<<<<<<<<<<
 * 
 * cdef bytes to_bytes(s):
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 142, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 142, __pyx_L1_error)

    /* "_redukti.pyx":141
 * 
 * cdef validate_periodunit(enums.PeriodUnit unit):
 *     if unit < 1 or unit > enums.YEARS:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid PeriodUnit specified')
 * 
 */
  }

  /* "_redukti.pyx":140
 *         return h
 * 
 * cdef validate_periodunit(enums.PeriodUnit unit):             # <<<<<<<<<<<<<<
 *     if unit < 1 or unit > enums.YEARS:
 *         raise ValueError('Invalid PeriodUnit specified')
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.validate_periodunit", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":144
 *         raise ValueError('Invalid PeriodUnit specified')
 * 
 * cdef bytes to_bytes(s):             # <<<<<<<<<<<<<<
 *     if type(s) is unicode:
 *         return s.encode('UTF-8')
 */

static PyObject *__pyx_f_8_redukti_to_bytes(PyObject *__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("to_bytes", 0);

  /* "_redukti.pyx":145
 * 
 * cdef bytes to_bytes(s):
 *     if type(s) is unicode:             # <<<<<<<<<<<<<<
 *         return s.encode('UTF-8')
 *     elif isinstance(s, bytes):
 */
  __pyx_t_1 = (((PyObject *)Py_TYPE(__pyx_v_s)) == ((PyObject *)(&PyUnicode_Type)));
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "_redukti.pyx":146
 * cdef bytes to_bytes(s):
 *     if type(s) is unicode:
 *         return s.encode('UTF-8')             # <<<<<<<<<<<<<<
 *     elif isinstance(s, bytes):
 *         return s
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_encode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 146, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_kp_u_UTF_8) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_kp_u_UTF_8);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 146, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (!(likely(PyBytes_CheckExact(__pyx_t_3))||((__pyx_t_3) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_3)->tp_name), 0))) __PYX_ERR(0, 146, __pyx_L1_error)
    __pyx_r = ((PyObject*)__pyx_t_3);
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "_redukti.pyx":145
 * 
 * cdef bytes to_bytes(s):
 *     if type(s) is unicode:             # <<<<<<<<<<<<<<
 *         return s.encode('UTF-8')
 *     elif isinstance(s, bytes):
 */
  }

  /* "_redukti.pyx":147
 *     if type(s) is unicode:
 *         return s.encode('UTF-8')
 *     elif isinstance(s, bytes):             # <<<<<<<<<<<<<<
 *         return s
 *     elif isinstance(s, unicode):
 */
  __pyx_t_2 = PyBytes_Check(__pyx_v_s); 
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "_redukti.pyx":148
 *         return s.encode('UTF-8')
 *     elif isinstance(s, bytes):
 *         return s             # <<<<<<<<<<<<<<
 *     elif isinstance(s, unicode):
 *         return bytes(s)
 */
    __Pyx_XDECREF(__pyx_r);
    if (!(likely(PyBytes_CheckExact(__pyx_v_s))||((__pyx_v_s) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_v_s)->tp_name), 0))) __PYX_ERR(0, 148, __pyx_L1_error)
    __Pyx_INCREF(__pyx_v_s);
    __pyx_r = ((PyObject*)__pyx_v_s);
    goto __pyx_L0;

    /* "_redukti.pyx":147
 *     if type(s) is unicode:
 *         return s.encode('UTF-8')
 *     elif isinstance(s, bytes):             # <<<<<<<<<<<<<<
 *         return s
 *     elif isinstance(s, unicode):
 */
  }

  /* "_redukti.pyx":149
 *     elif isinstance(s, bytes):
 *         return s
 *     elif isinstance(s, unicode):             # <<<<<<<<<<<<<<
 *         return bytes(s)
 *     else:
 */
  __pyx_t_1 = PyUnicode_Check(__pyx_v_s); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (likely(__pyx_t_2)) {

    /* "_redukti.pyx":150
 *         return s
 *     elif isinstance(s, unicode):
 *         return bytes(s)             # <<<<<<<<<<<<<<
 *     else:
 *         raise TypeError("Could not convert to bytes.")
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyBytes_Type)), __pyx_v_s); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = ((PyObject*)__pyx_t_3);
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "_redukti.pyx":149
 *     elif isinstance(s, bytes):
 *         return s
 *     elif isinstance(s, unicode):             # <<<<<<<<<<<<<<
 *         return bytes(s)
 *     else:
 */
  }

  /* "_redukti.pyx":152
 *         return bytes(s)
 *     else:
 *         raise TypeError("Could not convert to bytes.")             # <<<<<<<<<<<<<<
 * 
 * cdef class Date:
 */
  /*else*/ {
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 152, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 152, __pyx_L1_error)
  }

  /* "_redukti.pyx":144
 *         raise ValueError('Invalid PeriodUnit specified')
 * 
 * cdef bytes to_bytes(s):             # <<<<<<<<<<<<<<
 *     if type(s) is unicode:
 *         return s.encode('UTF-8')
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_redukti.to_bytes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":165
 *     cdef date.YearMonthDay _ymd
 * 
 *     def __init__(self, int value):             # <<<<<<<<<<<<<<
 *         """
 *         Constructs a Date object from a serial number
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_4Date_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_4Date___init__[] = "\n        Constructs a Date object from a serial number\n        Args:\n            value: serial number\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_8_redukti_4Date___init__;
#endif
static int __pyx_pw_8_redukti_4Date_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED int __pyx_v_value;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_value,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 165, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_value = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_value == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 165, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 165, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Date.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_4Date___init__(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self), __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_4Date___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_self, CYTHON_UNUSED int __pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":173
 *         pass
 * 
 *     def __cinit__(self, int value):             # <<<<<<<<<<<<<<
 *         self._serial = value
 *         self._ymd = date.date_components(value)
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_4Date_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_4Date_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_value;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_value,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 173, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_value = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_value == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 173, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 173, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Date.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_4Date_2__cinit__(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self), __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_4Date_2__cinit__(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_v_value) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":174
 * 
 *     def __cinit__(self, int value):
 *         self._serial = value             # <<<<<<<<<<<<<<
 *         self._ymd = date.date_components(value)
 * 
 */
  __pyx_v_self->_serial = __pyx_v_value;

  /* "_redukti.pyx":175
 *     def __cinit__(self, int value):
 *         self._serial = value
 *         self._ymd = date.date_components(value)             # <<<<<<<<<<<<<<
 * 
 *     cpdef int day(self):
 */
  __pyx_v_self->_ymd = redukti::date_components(__pyx_v_value);

  /* "_redukti.pyx":173
 *         pass
 * 
 *     def __cinit__(self, int value):             # <<<<<<<<<<<<<<
 *         self._serial = value
 *         self._ymd = date.date_components(value)
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":177
 *         self._ymd = date.date_components(value)
 * 
 *     cpdef int day(self):             # <<<<<<<<<<<<<<
 *         return self._ymd.d
 * 
 */

static PyObject *__pyx_pw_8_redukti_4Date_5day(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static int __pyx_f_8_redukti_4Date_day(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_skip_dispatch) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("day", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_day); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 177, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_4Date_5day)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 177, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 177, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":178
 * 
 *     cpdef int day(self):
 *         return self._ymd.d             # <<<<<<<<<<<<<<
 * 
 *     cpdef int month(self):
 */
  __pyx_r = __pyx_v_self->_ymd.d;
  goto __pyx_L0;

  /* "_redukti.pyx":177
 *         self._ymd = date.date_components(value)
 * 
 *     cpdef int day(self):             # <<<<<<<<<<<<<<
 *         return self._ymd.d
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.Date.day", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_5day(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_4Date_4day[] = "Date.day(self) -> int";
static PyObject *__pyx_pw_8_redukti_4Date_5day(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("day (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_4Date_4day(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_4day(struct __pyx_obj_8_redukti_Date *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("day", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_f_8_redukti_4Date_day(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 177, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Date.day", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":180
 *         return self._ymd.d
 * 
 *     cpdef int month(self):             # <<<<<<<<<<<<<<
 *         return self._ymd.m
 * 
 */

static PyObject *__pyx_pw_8_redukti_4Date_7month(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static int __pyx_f_8_redukti_4Date_month(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_skip_dispatch) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("month", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_month); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_4Date_7month)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 180, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 180, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":181
 * 
 *     cpdef int month(self):
 *         return self._ymd.m             # <<<<<<<<<<<<<<
 * 
 *     cpdef int year(self):
 */
  __pyx_r = __pyx_v_self->_ymd.m;
  goto __pyx_L0;

  /* "_redukti.pyx":180
 *         return self._ymd.d
 * 
 *     cpdef int month(self):             # <<<<<<<<<<<<<<
 *         return self._ymd.m
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.Date.month", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_7month(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_4Date_6month[] = "Date.month(self) -> int";
static PyObject *__pyx_pw_8_redukti_4Date_7month(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("month (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_4Date_6month(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_6month(struct __pyx_obj_8_redukti_Date *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("month", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_f_8_redukti_4Date_month(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Date.month", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":183
 *         return self._ymd.m
 * 
 *     cpdef int year(self):             # <<<<<<<<<<<<<<
 *         return self._ymd.y
 * 
 */

static PyObject *__pyx_pw_8_redukti_4Date_9year(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static int __pyx_f_8_redukti_4Date_year(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_skip_dispatch) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("year", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_year); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 183, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_4Date_9year)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 183, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 183, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":184
 * 
 *     cpdef int year(self):
 *         return self._ymd.y             # <<<<<<<<<<<<<<
 * 
 *     cpdef int serial(self):
 */
  __pyx_r = __pyx_v_self->_ymd.y;
  goto __pyx_L0;

  /* "_redukti.pyx":183
 *         return self._ymd.m
 * 
 *     cpdef int year(self):             # <<<<<<<<<<<<<<
 *         return self._ymd.y
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.Date.year", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_9year(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_4Date_8year[] = "Date.year(self) -> int";
static PyObject *__pyx_pw_8_redukti_4Date_9year(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("year (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_4Date_8year(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_8year(struct __pyx_obj_8_redukti_Date *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("year", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_f_8_redukti_4Date_year(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Date.year", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":186
 *         return self._ymd.y
 * 
 *     cpdef int serial(self):             # <<<<<<<<<<<<<<
 *         return self._serial
 * 
 */

static PyObject *__pyx_pw_8_redukti_4Date_11serial(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static int __pyx_f_8_redukti_4Date_serial(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_skip_dispatch) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("serial", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_serial); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 186, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_4Date_11serial)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 186, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":187
 * 
 *     cpdef int serial(self):
 *         return self._serial             # <<<<<<<<<<<<<<
 * 
 *     @staticmethod
 */
  __pyx_r = __pyx_v_self->_serial;
  goto __pyx_L0;

  /* "_redukti.pyx":186
 *         return self._ymd.y
 * 
 *     cpdef int serial(self):             # <<<<<<<<<<<<<<
 *         return self._serial
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.Date.serial", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_11serial(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_4Date_10serial[] = "Date.serial(self) -> int";
static PyObject *__pyx_pw_8_redukti_4Date_11serial(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("serial (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_4Date_10serial(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_10serial(struct __pyx_obj_8_redukti_Date *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("serial", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_f_8_redukti_4Date_serial(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Date.serial", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":190
 * 
 *     @staticmethod
 *     def dmy(unsigned d, unsigned m, int y):             # <<<<<<<<<<<<<<
 *         """
 *         Constructs a Date object from day, month, year.
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_13dmy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_4Date_12dmy[] = "Date.dmy(unsigned int d, unsigned int m, int y)\n\n        Constructs a Date object from day, month, year.\n        ";
static PyMethodDef __pyx_mdef_8_redukti_4Date_13dmy = {"dmy", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_4Date_13dmy, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_4Date_12dmy};
static PyObject *__pyx_pw_8_redukti_4Date_13dmy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  unsigned int __pyx_v_d;
  unsigned int __pyx_v_m;
  int __pyx_v_y;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dmy (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_d,&__pyx_n_s_m,&__pyx_n_s_y,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_m)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("dmy", 1, 3, 3, 1); __PYX_ERR(0, 190, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("dmy", 1, 3, 3, 2); __PYX_ERR(0, 190, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "dmy") < 0)) __PYX_ERR(0, 190, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_d = __Pyx_PyInt_As_unsigned_int(values[0]); if (unlikely((__pyx_v_d == (unsigned int)-1) && PyErr_Occurred())) __PYX_ERR(0, 190, __pyx_L3_error)
    __pyx_v_m = __Pyx_PyInt_As_unsigned_int(values[1]); if (unlikely((__pyx_v_m == (unsigned int)-1) && PyErr_Occurred())) __PYX_ERR(0, 190, __pyx_L3_error)
    __pyx_v_y = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_y == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 190, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("dmy", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 190, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Date.dmy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_4Date_12dmy(__pyx_v_d, __pyx_v_m, __pyx_v_y);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_12dmy(unsigned int __pyx_v_d, unsigned int __pyx_v_m, int __pyx_v_y) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("dmy", 0);

  /* "_redukti.pyx":194
 *         Constructs a Date object from day, month, year.
 *         """
 *         return Date(date.make_date(d, m, y))             # <<<<<<<<<<<<<<
 * 
 *     def advance(self, int n, enums.PeriodUnit unit):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(redukti::make_date(__pyx_v_d, __pyx_v_m, __pyx_v_y)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":190
 * 
 *     @staticmethod
 *     def dmy(unsigned d, unsigned m, int y):             # <<<<<<<<<<<<<<
 *         """
 *         Constructs a Date object from day, month, year.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.Date.dmy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":196
 *         return Date(date.make_date(d, m, y))
 * 
 *     def advance(self, int n, enums.PeriodUnit unit):             # <<<<<<<<<<<<<<
 *         """
 *         Adds or subtracts a period from a date.
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_15advance(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_4Date_14advance[] = "Date.advance(self, int n, PeriodUnit unit)\n\n        Adds or subtracts a period from a date.\n\n        When handling month periods it ensures that the day stays the same if possible,\n        but if not (e.g. no 29th Feb in final date) then the day is adjusted to fit in the month\n        When handling year periods, the day and month are kept the same if possible\n        or adjusted as above.\n\n        Args:\n            d: Input date\n            n: quantity\n            unit: The unit of ``n``\n\n        Returns:\n            New Date object\n        ";
static PyObject *__pyx_pw_8_redukti_4Date_15advance(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_n;
  enum redukti::PeriodUnit __pyx_v_unit;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("advance (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n,&__pyx_n_s_unit,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_unit)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("advance", 1, 2, 2, 1); __PYX_ERR(0, 196, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "advance") < 0)) __PYX_ERR(0, 196, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_n = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_n == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 196, __pyx_L3_error)
    __pyx_v_unit = ((enum redukti::PeriodUnit)__Pyx_PyInt_As_enum__redukti_3a__3a_PeriodUnit(values[1])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 196, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("advance", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 196, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Date.advance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_4Date_14advance(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self), __pyx_v_n, __pyx_v_unit);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_14advance(struct __pyx_obj_8_redukti_Date *__pyx_v_self, int __pyx_v_n, enum redukti::PeriodUnit __pyx_v_unit) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("advance", 0);

  /* "_redukti.pyx":213
 *             New Date object
 *         """
 *         validate_periodunit(unit)             # <<<<<<<<<<<<<<
 *         return Date(date.advance(self.serial(), n, unit))
 * 
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_periodunit(__pyx_v_unit); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":214
 *         """
 *         validate_periodunit(unit)
 *         return Date(date.advance(self.serial(), n, unit))             # <<<<<<<<<<<<<<
 * 
 *     @staticmethod
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(redukti::advance(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_self->__pyx_vtab)->serial(__pyx_v_self, 0), __pyx_v_n, __pyx_v_unit)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":196
 *         return Date(date.make_date(d, m, y))
 * 
 *     def advance(self, int n, enums.PeriodUnit unit):             # <<<<<<<<<<<<<<
 *         """
 *         Adds or subtracts a period from a date.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.Date.advance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":217
 * 
 *     @staticmethod
 *     def parse(s):             # <<<<<<<<<<<<<<
 *         """
 *         Parses a string representation of date.
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_17parse(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_4Date_16parse[] = "Date.parse(s)\n\n        Parses a string representation of date.\n        \n        The parser will detect seperator character '/' or '-'.\n        The formats acceptable are 'yyyy/mm/dd', 'dd/mm/yyyy', 'yyyy-mm-dd', or 'dd-mm-yyyy'\n\n        Args:\n            s: Input string containing a date value in supported format\n\n        Returns:\n            Date object if parsing is successful\n\n        Raises:\n            ValueError: if input cannot be parsed\n        ";
static PyMethodDef __pyx_mdef_8_redukti_4Date_17parse = {"parse", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_4Date_17parse, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_4Date_16parse};
static PyObject *__pyx_pw_8_redukti_4Date_17parse(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_s = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("parse (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_s,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_s)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "parse") < 0)) __PYX_ERR(0, 217, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_s = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("parse", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 217, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Date.parse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_4Date_16parse(__pyx_v_s);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_16parse(PyObject *__pyx_v_s) {
  int __pyx_v_d;
  PyObject *__pyx_v_byte_s = NULL;
  char const *__pyx_v_c_string;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  char const *__pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("parse", 0);

  /* "_redukti.pyx":234
 *         """
 *         cdef int d
 *         byte_s = to_bytes(s)             # <<<<<<<<<<<<<<
 *         cdef const char*c_string = byte_s
 *         if not date.parse_date(c_string, &d):
 */
  __pyx_t_1 = __pyx_f_8_redukti_to_bytes(__pyx_v_s); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 234, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_byte_s = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":235
 *         cdef int d
 *         byte_s = to_bytes(s)
 *         cdef const char*c_string = byte_s             # <<<<<<<<<<<<<<
 *         if not date.parse_date(c_string, &d):
 *             raise ValueError('Invalid date: cannot parse')
 */
  if (unlikely(__pyx_v_byte_s == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
    __PYX_ERR(0, 235, __pyx_L1_error)
  }
  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_v_byte_s); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 235, __pyx_L1_error)
  __pyx_v_c_string = __pyx_t_2;

  /* "_redukti.pyx":236
 *         byte_s = to_bytes(s)
 *         cdef const char*c_string = byte_s
 *         if not date.parse_date(c_string, &d):             # <<<<<<<<<<<<<<
 *             raise ValueError('Invalid date: cannot parse')
 *         return Date(d)
 */
  __pyx_t_3 = ((!(redukti::parse_date(__pyx_v_c_string, (&__pyx_v_d)) != 0)) != 0);
  if (unlikely(__pyx_t_3)) {

    /* "_redukti.pyx":237
 *         cdef const char*c_string = byte_s
 *         if not date.parse_date(c_string, &d):
 *             raise ValueError('Invalid date: cannot parse')             # <<<<<<<<<<<<<<
 *         return Date(d)
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 237, __pyx_L1_error)

    /* "_redukti.pyx":236
 *         byte_s = to_bytes(s)
 *         cdef const char*c_string = byte_s
 *         if not date.parse_date(c_string, &d):             # <<<<<<<<<<<<<<
 *             raise ValueError('Invalid date: cannot parse')
 *         return Date(d)
 */
  }

  /* "_redukti.pyx":238
 *         if not date.parse_date(c_string, &d):
 *             raise ValueError('Invalid date: cannot parse')
 *         return Date(d)             # <<<<<<<<<<<<<<
 * 
 * cdef class ScheduleGenerator:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_d); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":217
 * 
 *     @staticmethod
 *     def parse(s):             # <<<<<<<<<<<<<<
 *         """
 *         Parses a string representation of date.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_redukti.Date.parse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_byte_s);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_19__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_4Date_18__reduce_cython__[] = "Date.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_4Date_19__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_4Date_18__reduce_cython__(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_18__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Date.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_4Date_21__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_4Date_20__setstate_cython__[] = "Date.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_4Date_21__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_4Date_20__setstate_cython__(((struct __pyx_obj_8_redukti_Date *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_4Date_20__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Date.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":247
 * 
 *     @staticmethod
 *     def generate_schedule(schedule_parameters):             # <<<<<<<<<<<<<<
 *         """
 *         Generates a schedule
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17ScheduleGenerator_1generate_schedule(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_17ScheduleGenerator_generate_schedule[] = "ScheduleGenerator.generate_schedule(schedule_parameters)\n\n        Generates a schedule\n\n        Args:\n            schedule_parameters (schedule_pb2.ScheduleParameters): parameters for schedule generation  \n\n        Returns:\n            An instance of schedule_pb2.Schedule\n        ";
static PyMethodDef __pyx_mdef_8_redukti_17ScheduleGenerator_1generate_schedule = {"generate_schedule", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_17ScheduleGenerator_1generate_schedule, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_17ScheduleGenerator_generate_schedule};
static PyObject *__pyx_pw_8_redukti_17ScheduleGenerator_1generate_schedule(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_schedule_parameters = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("generate_schedule (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_schedule_parameters,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_schedule_parameters)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "generate_schedule") < 0)) __PYX_ERR(0, 247, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_schedule_parameters = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("generate_schedule", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 247, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.ScheduleGenerator.generate_schedule", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_17ScheduleGenerator_generate_schedule(__pyx_v_schedule_parameters);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17ScheduleGenerator_generate_schedule(PyObject *__pyx_v_schedule_parameters) {
  std::string __pyx_v_str;
  redukti::ScheduleParameters __pyx_v__parameters;
  redukti::Schedule __pyx_v__schedule;
  enum redukti::ResponseSubCode __pyx_v_status;
  PyObject *__pyx_v_result = NULL;
  std::string __pyx_v_result_str;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  std::string __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("generate_schedule", 0);

  /* "_redukti.pyx":257
 *             An instance of schedule_pb2.Schedule
 *         """
 *         if not isinstance(schedule_parameters, schedule_pb2.ScheduleParameters):             # <<<<<<<<<<<<<<
 *             raise ValueError('Input must be an instance of schedule_pb2.ScheduleParameters')
 *         cdef string str = schedule_parameters.SerializeToString()
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_schedule_pb2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ScheduleParameters); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = PyObject_IsInstance(__pyx_v_schedule_parameters, __pyx_t_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 257, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = ((!(__pyx_t_3 != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "_redukti.pyx":258
 *         """
 *         if not isinstance(schedule_parameters, schedule_pb2.ScheduleParameters):
 *             raise ValueError('Input must be an instance of schedule_pb2.ScheduleParameters')             # <<<<<<<<<<<<<<
 *         cdef string str = schedule_parameters.SerializeToString()
 *         cdef schedule.ScheduleParameters _parameters
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 258, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 258, __pyx_L1_error)

    /* "_redukti.pyx":257
 *             An instance of schedule_pb2.Schedule
 *         """
 *         if not isinstance(schedule_parameters, schedule_pb2.ScheduleParameters):             # <<<<<<<<<<<<<<
 *             raise ValueError('Input must be an instance of schedule_pb2.ScheduleParameters')
 *         cdef string str = schedule_parameters.SerializeToString()
 */
  }

  /* "_redukti.pyx":259
 *         if not isinstance(schedule_parameters, schedule_pb2.ScheduleParameters):
 *             raise ValueError('Input must be an instance of schedule_pb2.ScheduleParameters')
 *         cdef string str = schedule_parameters.SerializeToString()             # <<<<<<<<<<<<<<
 *         cdef schedule.ScheduleParameters _parameters
 *         if not _parameters.ParseFromString(str):
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_schedule_parameters, __pyx_n_s_SerializeToString); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_t_2); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 259, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_str = __pyx_t_6;

  /* "_redukti.pyx":261
 *         cdef string str = schedule_parameters.SerializeToString()
 *         cdef schedule.ScheduleParameters _parameters
 *         if not _parameters.ParseFromString(str):             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot parse the schedule parameters")
 *         cdef schedule.Schedule _schedule
 */
  __pyx_t_4 = ((!(__pyx_v__parameters.ParseFromString(__pyx_v_str) != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "_redukti.pyx":262
 *         cdef schedule.ScheduleParameters _parameters
 *         if not _parameters.ParseFromString(str):
 *             raise ValueError("Cannot parse the schedule parameters")             # <<<<<<<<<<<<<<
 *         cdef schedule.Schedule _schedule
 *         status = schedule.build_schedule(_parameters, _schedule)
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 262, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 262, __pyx_L1_error)

    /* "_redukti.pyx":261
 *         cdef string str = schedule_parameters.SerializeToString()
 *         cdef schedule.ScheduleParameters _parameters
 *         if not _parameters.ParseFromString(str):             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot parse the schedule parameters")
 *         cdef schedule.Schedule _schedule
 */
  }

  /* "_redukti.pyx":264
 *             raise ValueError("Cannot parse the schedule parameters")
 *         cdef schedule.Schedule _schedule
 *         status = schedule.build_schedule(_parameters, _schedule)             # <<<<<<<<<<<<<<
 *         if not status == enums.ResponseSubCode.kOk:
 *             raise Exception('Failed to generate schedule')
 */
  __pyx_v_status = redukti::build_schedule(__pyx_v__parameters, __pyx_v__schedule);

  /* "_redukti.pyx":265
 *         cdef schedule.Schedule _schedule
 *         status = schedule.build_schedule(_parameters, _schedule)
 *         if not status == enums.ResponseSubCode.kOk:             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to generate schedule')
 *         result = schedule_pb2.Schedule()
 */
  __pyx_t_4 = ((!((__pyx_v_status == redukti::kOk) != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "_redukti.pyx":266
 *         status = schedule.build_schedule(_parameters, _schedule)
 *         if not status == enums.ResponseSubCode.kOk:
 *             raise Exception('Failed to generate schedule')             # <<<<<<<<<<<<<<
 *         result = schedule_pb2.Schedule()
 *         cdef string result_str
 */
    __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 266, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 266, __pyx_L1_error)

    /* "_redukti.pyx":265
 *         cdef schedule.Schedule _schedule
 *         status = schedule.build_schedule(_parameters, _schedule)
 *         if not status == enums.ResponseSubCode.kOk:             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to generate schedule')
 *         result = schedule_pb2.Schedule()
 */
  }

  /* "_redukti.pyx":267
 *         if not status == enums.ResponseSubCode.kOk:
 *             raise Exception('Failed to generate schedule')
 *         result = schedule_pb2.Schedule()             # <<<<<<<<<<<<<<
 *         cdef string result_str
 *         if not _schedule.SerializeToString(&result_str):
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_schedule_pb2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Schedule); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_1) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_v_result = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "_redukti.pyx":269
 *         result = schedule_pb2.Schedule()
 *         cdef string result_str
 *         if not _schedule.SerializeToString(&result_str):             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to parse result from api call')
 *         result.ParseFromString(result_str)
 */
  __pyx_t_4 = ((!(__pyx_v__schedule.SerializeToString((&__pyx_v_result_str)) != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "_redukti.pyx":270
 *         cdef string result_str
 *         if not _schedule.SerializeToString(&result_str):
 *             raise Exception('Failed to parse result from api call')             # <<<<<<<<<<<<<<
 *         result.ParseFromString(result_str)
 *         return result
 */
    __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 270, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 270, __pyx_L1_error)

    /* "_redukti.pyx":269
 *         result = schedule_pb2.Schedule()
 *         cdef string result_str
 *         if not _schedule.SerializeToString(&result_str):             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to parse result from api call')
 *         result.ParseFromString(result_str)
 */
  }

  /* "_redukti.pyx":271
 *         if not _schedule.SerializeToString(&result_str):
 *             raise Exception('Failed to parse result from api call')
 *         result.ParseFromString(result_str)             # <<<<<<<<<<<<<<
 *         return result
 * 
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_result, __pyx_n_s_ParseFromString); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_1 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_v_result_str); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_7 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_7, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_1);
  __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 271, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "_redukti.pyx":272
 *             raise Exception('Failed to parse result from api call')
 *         result.ParseFromString(result_str)
 *         return result             # <<<<<<<<<<<<<<
 * 
 * cdef validate_business_centers(list business_centres):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  /* "_redukti.pyx":247
 * 
 *     @staticmethod
 *     def generate_schedule(schedule_parameters):             # <<<<<<<<<<<<<<
 *         """
 *         Generates a schedule
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("_redukti.ScheduleGenerator.generate_schedule", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     cdef tuple state
 *     cdef object _dict
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17ScheduleGenerator_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_17ScheduleGenerator_2__reduce_cython__[] = "ScheduleGenerator.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_17ScheduleGenerator_3__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_17ScheduleGenerator_2__reduce_cython__(((struct __pyx_obj_8_redukti_ScheduleGenerator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17ScheduleGenerator_2__reduce_cython__(struct __pyx_obj_8_redukti_ScheduleGenerator *__pyx_v_self) {
  PyObject *__pyx_v_state = 0;
  PyObject *__pyx_v__dict = 0;
  int __pyx_v_use_setstate;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":5
 *     cdef object _dict
 *     cdef bint use_setstate
 *     state = ()             # <<<<<<<<<<<<<<
 *     _dict = getattr(self, '__dict__', None)
 *     if _dict is not None:
 */
  __Pyx_INCREF(__pyx_empty_tuple);
  __pyx_v_state = __pyx_empty_tuple;

  /* "(tree fragment)":6
 *     cdef bint use_setstate
 *     state = ()
 *     _dict = getattr(self, '__dict__', None)             # <<<<<<<<<<<<<<
 *     if _dict is not None:
 *         state += (_dict,)
 */
  __pyx_t_1 = __Pyx_GetAttr3(((PyObject *)__pyx_v_self), __pyx_n_s_dict, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 6, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v__dict = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "(tree fragment)":7
 *     state = ()
 *     _dict = getattr(self, '__dict__', None)
 *     if _dict is not None:             # <<<<<<<<<<<<<<
 *         state += (_dict,)
 *         use_setstate = True
 */
  __pyx_t_2 = (__pyx_v__dict != Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "(tree fragment)":8
 *     _dict = getattr(self, '__dict__', None)
 *     if _dict is not None:
 *         state += (_dict,)             # <<<<<<<<<<<<<<
 *         use_setstate = True
 *     else:
 */
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 8, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_v__dict);
    __Pyx_GIVEREF(__pyx_v__dict);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v__dict);
    __pyx_t_4 = PyNumber_InPlaceAdd(__pyx_v_state, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 8, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_state, ((PyObject*)__pyx_t_4));
    __pyx_t_4 = 0;

    /* "(tree fragment)":9
 *     if _dict is not None:
 *         state += (_dict,)
 *         use_setstate = True             # <<<<<<<<<<<<<<
 *     else:
 *         use_setstate = False
 */
    __pyx_v_use_setstate = 1;

    /* "(tree fragment)":7
 *     state = ()
 *     _dict = getattr(self, '__dict__', None)
 *     if _dict is not None:             # <<<<<<<<<<<<<<
 *         state += (_dict,)
 *         use_setstate = True
 */
    goto __pyx_L3;
  }

  /* "(tree fragment)":11
 *         use_setstate = True
 *     else:
 *         use_setstate = False             # <<<<<<<<<<<<<<
 *     if use_setstate:
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, None), state
 */
  /*else*/ {
    __pyx_v_use_setstate = 0;
  }
  __pyx_L3:;

  /* "(tree fragment)":12
 *     else:
 *         use_setstate = False
 *     if use_setstate:             # <<<<<<<<<<<<<<
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, None), state
 *     else:
 */
  __pyx_t_3 = (__pyx_v_use_setstate != 0);
  if (__pyx_t_3) {

    /* "(tree fragment)":13
 *         use_setstate = False
 *     if use_setstate:
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, None), state             # <<<<<<<<<<<<<<
 *     else:
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, state)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pyx_unpickle_ScheduleGenerator); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 13, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 13, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
    PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
    __Pyx_INCREF(__pyx_int_222419149);
    __Pyx_GIVEREF(__pyx_int_222419149);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_222419149);
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    PyTuple_SET_ITEM(__pyx_t_1, 2, Py_None);
    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 13, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
    __Pyx_INCREF(__pyx_v_state);
    __Pyx_GIVEREF(__pyx_v_state);
    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_v_state);
    __pyx_t_4 = 0;
    __pyx_t_1 = 0;
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "(tree fragment)":12
 *     else:
 *         use_setstate = False
 *     if use_setstate:             # <<<<<<<<<<<<<<
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, None), state
 *     else:
 */
  }

  /* "(tree fragment)":15
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, None), state
 *     else:
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, state)             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     __pyx_unpickle_ScheduleGenerator__set_state(self, __pyx_state)
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pyx_unpickle_ScheduleGenerator); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 15, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
    __Pyx_GIVEREF(((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
    PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)Py_TYPE(((PyObject *)__pyx_v_self))));
    __Pyx_INCREF(__pyx_int_222419149);
    __Pyx_GIVEREF(__pyx_int_222419149);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_222419149);
    __Pyx_INCREF(__pyx_v_state);
    __Pyx_GIVEREF(__pyx_v_state);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_state);
    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 15, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
    __pyx_t_5 = 0;
    __pyx_t_1 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;
  }

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     cdef tuple state
 *     cdef object _dict
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_redukti.ScheduleGenerator.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_state);
  __Pyx_XDECREF(__pyx_v__dict);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":16
 *     else:
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, state)
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     __pyx_unpickle_ScheduleGenerator__set_state(self, __pyx_state)
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17ScheduleGenerator_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_17ScheduleGenerator_4__setstate_cython__[] = "ScheduleGenerator.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_17ScheduleGenerator_5__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_17ScheduleGenerator_4__setstate_cython__(((struct __pyx_obj_8_redukti_ScheduleGenerator *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17ScheduleGenerator_4__setstate_cython__(struct __pyx_obj_8_redukti_ScheduleGenerator *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":17
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, state)
 * def __setstate_cython__(self, __pyx_state):
 *     __pyx_unpickle_ScheduleGenerator__set_state(self, __pyx_state)             # <<<<<<<<<<<<<<
 */
  if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 17, __pyx_L1_error)
  __pyx_t_1 = __pyx_f_8_redukti___pyx_unpickle_ScheduleGenerator__set_state(__pyx_v_self, ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 17, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "(tree fragment)":16
 *     else:
 *         return __pyx_unpickle_ScheduleGenerator, (type(self), 0xd41d8cd, state)
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     __pyx_unpickle_ScheduleGenerator__set_state(self, __pyx_state)
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.ScheduleGenerator.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":274
 *         return result
 * 
 * cdef validate_business_centers(list business_centres):             # <<<<<<<<<<<<<<
 *     if len(business_centres) == 0:
 *         raise ValueError('Business centers must be specified')
 */

static PyObject *__pyx_f_8_redukti_validate_business_centers(PyObject *__pyx_v_business_centres) {
  PyObject *__pyx_v_center = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  Py_ssize_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("validate_business_centers", 0);

  /* "_redukti.pyx":275
 * 
 * cdef validate_business_centers(list business_centres):
 *     if len(business_centres) == 0:             # <<<<<<<<<<<<<<
 *         raise ValueError('Business centers must be specified')
 *     for center in business_centres:
 */
  if (unlikely(__pyx_v_business_centres == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 275, __pyx_L1_error)
  }
  __pyx_t_1 = PyList_GET_SIZE(__pyx_v_business_centres); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 275, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_t_1 == 0) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":276
 * cdef validate_business_centers(list business_centres):
 *     if len(business_centres) == 0:
 *         raise ValueError('Business centers must be specified')             # <<<<<<<<<<<<<<
 *     for center in business_centres:
 *         if center < 1 or center > enums.BRSP:
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 276, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 276, __pyx_L1_error)

    /* "_redukti.pyx":275
 * 
 * cdef validate_business_centers(list business_centres):
 *     if len(business_centres) == 0:             # <<<<<<<<<<<<<<
 *         raise ValueError('Business centers must be specified')
 *     for center in business_centres:
 */
  }

  /* "_redukti.pyx":277
 *     if len(business_centres) == 0:
 *         raise ValueError('Business centers must be specified')
 *     for center in business_centres:             # <<<<<<<<<<<<<<
 *         if center < 1 or center > enums.BRSP:
 *             raise ValueError('Invalid business center')
 */
  if (unlikely(__pyx_v_business_centres == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    __PYX_ERR(0, 277, __pyx_L1_error)
  }
  __pyx_t_3 = __pyx_v_business_centres; __Pyx_INCREF(__pyx_t_3); __pyx_t_1 = 0;
  for (;;) {
    if (__pyx_t_1 >= PyList_GET_SIZE(__pyx_t_3)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_1); __Pyx_INCREF(__pyx_t_4); __pyx_t_1++; if (unlikely(0 < 0)) __PYX_ERR(0, 277, __pyx_L1_error)
    #else
    __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_1); __pyx_t_1++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 277, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    #endif
    __Pyx_XDECREF_SET(__pyx_v_center, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "_redukti.pyx":278
 *         raise ValueError('Business centers must be specified')
 *     for center in business_centres:
 *         if center < 1 or center > enums.BRSP:             # <<<<<<<<<<<<<<
 *             raise ValueError('Invalid business center')
 * 
 */
    __pyx_t_4 = PyObject_RichCompare(__pyx_v_center, __pyx_int_1, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 278, __pyx_L1_error)
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 278, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (!__pyx_t_5) {
    } else {
      __pyx_t_2 = __pyx_t_5;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_4 = __Pyx_PyInt_From_enum__redukti_3a__3a_BusinessCenter(redukti::BRSP); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 278, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = PyObject_RichCompare(__pyx_v_center, __pyx_t_4, Py_GT); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 278, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 278, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_2 = __pyx_t_5;
    __pyx_L7_bool_binop_done:;
    if (unlikely(__pyx_t_2)) {

      /* "_redukti.pyx":279
 *     for center in business_centres:
 *         if center < 1 or center > enums.BRSP:
 *             raise ValueError('Invalid business center')             # <<<<<<<<<<<<<<
 * 
 * def convert_to_date_array(list values):
 */
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 279, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 279, __pyx_L1_error)

      /* "_redukti.pyx":278
 *         raise ValueError('Business centers must be specified')
 *     for center in business_centres:
 *         if center < 1 or center > enums.BRSP:             # <<<<<<<<<<<<<<
 *             raise ValueError('Invalid business center')
 * 
 */
    }

    /* "_redukti.pyx":277
 *     if len(business_centres) == 0:
 *         raise ValueError('Business centers must be specified')
 *     for center in business_centres:             # <<<<<<<<<<<<<<
 *         if center < 1 or center > enums.BRSP:
 *             raise ValueError('Invalid business center')
 */
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "_redukti.pyx":274
 *         return result
 * 
 * cdef validate_business_centers(list business_centres):             # <<<<<<<<<<<<<<
 *     if len(business_centres) == 0:
 *         raise ValueError('Business centers must be specified')
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("_redukti.validate_business_centers", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_center);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":281
 *             raise ValueError('Invalid business center')
 * 
 * def convert_to_date_array(list values):             # <<<<<<<<<<<<<<
 *     cdef array.array date_array = array.array('i', [])
 *     for v in values:
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_1convert_to_date_array(PyObject *__pyx_self, PyObject *__pyx_v_values); /*proto*/
static char __pyx_doc_8_redukti_convert_to_date_array[] = "convert_to_date_array(list values)";
static PyMethodDef __pyx_mdef_8_redukti_1convert_to_date_array = {"convert_to_date_array", (PyCFunction)__pyx_pw_8_redukti_1convert_to_date_array, METH_O, __pyx_doc_8_redukti_convert_to_date_array};
static PyObject *__pyx_pw_8_redukti_1convert_to_date_array(PyObject *__pyx_self, PyObject *__pyx_v_values) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("convert_to_date_array (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_values), (&PyList_Type), 1, "values", 1))) __PYX_ERR(0, 281, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_convert_to_date_array(__pyx_self, ((PyObject*)__pyx_v_values));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_convert_to_date_array(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_values) {
  arrayobject *__pyx_v_date_array = 0;
  PyObject *__pyx_v_v = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  __Pyx_RefNannySetupContext("convert_to_date_array", 0);

  /* "_redukti.pyx":282
 * 
 * def convert_to_date_array(list values):
 *     cdef array.array date_array = array.array('i', [])             # <<<<<<<<<<<<<<
 *     for v in values:
 *         if isinstance(v, Date):
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_u_i);
  __Pyx_GIVEREF(__pyx_n_u_i);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_n_u_i);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_7cpython_5array_array), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_date_array = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":283
 * def convert_to_date_array(list values):
 *     cdef array.array date_array = array.array('i', [])
 *     for v in values:             # <<<<<<<<<<<<<<
 *         if isinstance(v, Date):
 *             date_array.append(v.serial())
 */
  if (unlikely(__pyx_v_values == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    __PYX_ERR(0, 283, __pyx_L1_error)
  }
  __pyx_t_1 = __pyx_v_values; __Pyx_INCREF(__pyx_t_1); __pyx_t_3 = 0;
  for (;;) {
    if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_2); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 283, __pyx_L1_error)
    #else
    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 283, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    #endif
    __Pyx_XDECREF_SET(__pyx_v_v, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "_redukti.pyx":284
 *     cdef array.array date_array = array.array('i', [])
 *     for v in values:
 *         if isinstance(v, Date):             # <<<<<<<<<<<<<<
 *             date_array.append(v.serial())
 *         else:
 */
    __pyx_t_4 = __Pyx_TypeCheck(__pyx_v_v, __pyx_ptype_8_redukti_Date); 
    __pyx_t_5 = (__pyx_t_4 != 0);
    if (likely(__pyx_t_5)) {

      /* "_redukti.pyx":285
 *     for v in values:
 *         if isinstance(v, Date):
 *             date_array.append(v.serial())             # <<<<<<<<<<<<<<
 *         else:
 *             raise ValueError('Expected values of redukti.Date type in list')
 */
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_v, __pyx_n_s_serial); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 285, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 285, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_8 = __Pyx_PyObject_Append(((PyObject *)__pyx_v_date_array), __pyx_t_2); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 285, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

      /* "_redukti.pyx":284
 *     cdef array.array date_array = array.array('i', [])
 *     for v in values:
 *         if isinstance(v, Date):             # <<<<<<<<<<<<<<
 *             date_array.append(v.serial())
 *         else:
 */
      goto __pyx_L5;
    }

    /* "_redukti.pyx":287
 *             date_array.append(v.serial())
 *         else:
 *             raise ValueError('Expected values of redukti.Date type in list')             # <<<<<<<<<<<<<<
 *     return date_array
 * 
 */
    /*else*/ {
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 287, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 287, __pyx_L1_error)
    }
    __pyx_L5:;

    /* "_redukti.pyx":283
 * def convert_to_date_array(list values):
 *     cdef array.array date_array = array.array('i', [])
 *     for v in values:             # <<<<<<<<<<<<<<
 *         if isinstance(v, Date):
 *             date_array.append(v.serial())
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":288
 *         else:
 *             raise ValueError('Expected values of redukti.Date type in list')
 *     return date_array             # <<<<<<<<<<<<<<
 * 
 * cdef class Calendar:
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_date_array));
  __pyx_r = ((PyObject *)__pyx_v_date_array);
  goto __pyx_L0;

  /* "_redukti.pyx":281
 *             raise ValueError('Invalid business center')
 * 
 * def convert_to_date_array(list values):             # <<<<<<<<<<<<<<
 *     cdef array.array date_array = array.array('i', [])
 *     for v in values:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("_redukti.convert_to_date_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_date_array);
  __Pyx_XDECREF(__pyx_v_v);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":307
 *     cdef const calendar.Calendar *_calendar
 * 
 *     def __init__(self, list business_centres):             # <<<<<<<<<<<<<<
 *         """
 *         Constructs a Calendar instance for specified list of business centers.
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_8Calendar_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_8Calendar___init__[] = "\n        Constructs a Calendar instance for specified list of business centers.\n\n        Args:\n            business_centres: List of business centers\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_8_redukti_8Calendar___init__;
#endif
static int __pyx_pw_8_redukti_8Calendar_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_business_centres = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_business_centres,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_business_centres)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 307, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_business_centres = ((PyObject*)values[0]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 307, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Calendar.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_business_centres), (&PyList_Type), 1, "business_centres", 1))) __PYX_ERR(0, 307, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_8Calendar___init__(((struct __pyx_obj_8_redukti_Calendar *)__pyx_v_self), __pyx_v_business_centres);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_8Calendar___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_business_centres) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":316
 *         pass
 * 
 *     def __cinit__(self, list business_centres):             # <<<<<<<<<<<<<<
 *         cdef calendar.JointCalendarParameters joint_calendars
 *         validate_business_centers(business_centres)
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_8Calendar_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_8Calendar_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_business_centres = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_business_centres,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_business_centres)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 316, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_business_centres = ((PyObject*)values[0]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 316, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Calendar.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_business_centres), (&PyList_Type), 1, "business_centres", 1))) __PYX_ERR(0, 316, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_8Calendar_2__cinit__(((struct __pyx_obj_8_redukti_Calendar *)__pyx_v_self), __pyx_v_business_centres);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_8Calendar_2__cinit__(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, PyObject *__pyx_v_business_centres) {
  redukti::JointCalendarParameters __pyx_v_joint_calendars;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  int __pyx_t_3;
  enum redukti::BusinessCenter __pyx_t_4;
  enum redukti::BusinessCenter __pyx_t_5;
  enum redukti::BusinessCenter __pyx_t_6;
  enum redukti::BusinessCenter __pyx_t_7;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":318
 *     def __cinit__(self, list business_centres):
 *         cdef calendar.JointCalendarParameters joint_calendars
 *         validate_business_centers(business_centres)             # <<<<<<<<<<<<<<
 *         if len(business_centres) == 0:
 *             raise ValueError('Business centers must be specified')
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_business_centers(__pyx_v_business_centres); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 318, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":319
 *         cdef calendar.JointCalendarParameters joint_calendars
 *         validate_business_centers(business_centres)
 *         if len(business_centres) == 0:             # <<<<<<<<<<<<<<
 *             raise ValueError('Business centers must be specified')
 *         if len(business_centres) == 1:
 */
  if (unlikely(__pyx_v_business_centres == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 319, __pyx_L1_error)
  }
  __pyx_t_2 = PyList_GET_SIZE(__pyx_v_business_centres); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 319, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_2 == 0) != 0);
  if (unlikely(__pyx_t_3)) {

    /* "_redukti.pyx":320
 *         validate_business_centers(business_centres)
 *         if len(business_centres) == 0:
 *             raise ValueError('Business centers must be specified')             # <<<<<<<<<<<<<<
 *         if len(business_centres) == 1:
 *             self._calendar = calendar.get_calendar_factory().get_calendar(<enums.BusinessCenter> business_centres[0])
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 320, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 320, __pyx_L1_error)

    /* "_redukti.pyx":319
 *         cdef calendar.JointCalendarParameters joint_calendars
 *         validate_business_centers(business_centres)
 *         if len(business_centres) == 0:             # <<<<<<<<<<<<<<
 *             raise ValueError('Business centers must be specified')
 *         if len(business_centres) == 1:
 */
  }

  /* "_redukti.pyx":321
 *         if len(business_centres) == 0:
 *             raise ValueError('Business centers must be specified')
 *         if len(business_centres) == 1:             # <<<<<<<<<<<<<<
 *             self._calendar = calendar.get_calendar_factory().get_calendar(<enums.BusinessCenter> business_centres[0])
 *         elif len(business_centres) == 2:
 */
  if (unlikely(__pyx_v_business_centres == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 321, __pyx_L1_error)
  }
  __pyx_t_2 = PyList_GET_SIZE(__pyx_v_business_centres); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 321, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_2 == 1) != 0);
  if (__pyx_t_3) {

    /* "_redukti.pyx":322
 *             raise ValueError('Business centers must be specified')
 *         if len(business_centres) == 1:
 *             self._calendar = calendar.get_calendar_factory().get_calendar(<enums.BusinessCenter> business_centres[0])             # <<<<<<<<<<<<<<
 *         elif len(business_centres) == 2:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1])
 */
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 322, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 322, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 322, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_self->_calendar = redukti::get_calendar_factory()->get_calendar(((enum redukti::BusinessCenter)__pyx_t_4));

    /* "_redukti.pyx":321
 *         if len(business_centres) == 0:
 *             raise ValueError('Business centers must be specified')
 *         if len(business_centres) == 1:             # <<<<<<<<<<<<<<
 *             self._calendar = calendar.get_calendar_factory().get_calendar(<enums.BusinessCenter> business_centres[0])
 *         elif len(business_centres) == 2:
 */
    goto __pyx_L4;
  }

  /* "_redukti.pyx":323
 *         if len(business_centres) == 1:
 *             self._calendar = calendar.get_calendar_factory().get_calendar(<enums.BusinessCenter> business_centres[0])
 *         elif len(business_centres) == 2:             # <<<<<<<<<<<<<<
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 */
  if (unlikely(__pyx_v_business_centres == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 323, __pyx_L1_error)
  }
  __pyx_t_2 = PyList_GET_SIZE(__pyx_v_business_centres); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 323, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_2 == 2) != 0);
  if (__pyx_t_3) {

    /* "_redukti.pyx":324
 *             self._calendar = calendar.get_calendar_factory().get_calendar(<enums.BusinessCenter> business_centres[0])
 *         elif len(business_centres) == 2:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1])             # <<<<<<<<<<<<<<
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 3:
 */
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 324, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 324, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 324, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 324, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 1, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 324, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 324, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_joint_calendars = redukti::JointCalendarParameters(__pyx_t_4, __pyx_t_5);

    /* "_redukti.pyx":325
 *         elif len(business_centres) == 2:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)             # <<<<<<<<<<<<<<
 *         elif len(business_centres) == 3:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 */
    __pyx_v_self->_calendar = redukti::get_calendar_factory()->get_calendar(__pyx_v_joint_calendars);

    /* "_redukti.pyx":323
 *         if len(business_centres) == 1:
 *             self._calendar = calendar.get_calendar_factory().get_calendar(<enums.BusinessCenter> business_centres[0])
 *         elif len(business_centres) == 2:             # <<<<<<<<<<<<<<
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 */
    goto __pyx_L4;
  }

  /* "_redukti.pyx":326
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 3:             # <<<<<<<<<<<<<<
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 *                                                                business_centres[2])
 */
  if (unlikely(__pyx_v_business_centres == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 326, __pyx_L1_error)
  }
  __pyx_t_2 = PyList_GET_SIZE(__pyx_v_business_centres); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 326, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_2 == 3) != 0);
  if (__pyx_t_3) {

    /* "_redukti.pyx":327
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 3:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],             # <<<<<<<<<<<<<<
 *                                                                business_centres[2])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 */
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 327, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 327, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 327, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 327, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 1, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 327, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 327, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "_redukti.pyx":328
 *         elif len(business_centres) == 3:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 *                                                                business_centres[2])             # <<<<<<<<<<<<<<
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 4:
 */
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 328, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 2, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 328, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 328, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "_redukti.pyx":327
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 3:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],             # <<<<<<<<<<<<<<
 *                                                                business_centres[2])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 */
    __pyx_v_joint_calendars = redukti::JointCalendarParameters(__pyx_t_5, __pyx_t_4, __pyx_t_6);

    /* "_redukti.pyx":329
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 *                                                                business_centres[2])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)             # <<<<<<<<<<<<<<
 *         elif len(business_centres) == 4:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 */
    __pyx_v_self->_calendar = redukti::get_calendar_factory()->get_calendar(__pyx_v_joint_calendars);

    /* "_redukti.pyx":326
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 3:             # <<<<<<<<<<<<<<
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 *                                                                business_centres[2])
 */
    goto __pyx_L4;
  }

  /* "_redukti.pyx":330
 *                                                                business_centres[2])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 4:             # <<<<<<<<<<<<<<
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 *                                                                business_centres[2], business_centres[3])
 */
  if (unlikely(__pyx_v_business_centres == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 330, __pyx_L1_error)
  }
  __pyx_t_2 = PyList_GET_SIZE(__pyx_v_business_centres); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 330, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_2 == 4) != 0);
  if (likely(__pyx_t_3)) {

    /* "_redukti.pyx":331
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 4:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],             # <<<<<<<<<<<<<<
 *                                                                business_centres[2], business_centres[3])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 */
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 331, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 331, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 331, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 331, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 1, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 331, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 331, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "_redukti.pyx":332
 *         elif len(business_centres) == 4:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 *                                                                business_centres[2], business_centres[3])             # <<<<<<<<<<<<<<
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         else:
 */
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 332, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 2, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 332, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 332, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(__pyx_v_business_centres == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 332, __pyx_L1_error)
    }
    __pyx_t_1 = __Pyx_GetItemInt_List(__pyx_v_business_centres, 3, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 332, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(__pyx_t_1)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 332, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "_redukti.pyx":331
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 4:
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],             # <<<<<<<<<<<<<<
 *                                                                business_centres[2], business_centres[3])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 */
    __pyx_v_joint_calendars = redukti::JointCalendarParameters(__pyx_t_6, __pyx_t_4, __pyx_t_5, __pyx_t_7);

    /* "_redukti.pyx":333
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 *                                                                business_centres[2], business_centres[3])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)             # <<<<<<<<<<<<<<
 *         else:
 *             raise ValueError('Incorrect number of values in business centres list, max of 4 allowed')
 */
    __pyx_v_self->_calendar = redukti::get_calendar_factory()->get_calendar(__pyx_v_joint_calendars);

    /* "_redukti.pyx":330
 *                                                                business_centres[2])
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         elif len(business_centres) == 4:             # <<<<<<<<<<<<<<
 *             joint_calendars = calendar.JointCalendarParameters(business_centres[0], business_centres[1],
 *                                                                business_centres[2], business_centres[3])
 */
    goto __pyx_L4;
  }

  /* "_redukti.pyx":335
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         else:
 *             raise ValueError('Incorrect number of values in business centres list, max of 4 allowed')             # <<<<<<<<<<<<<<
 *         if self._calendar is NULL:
 *             raise ValueError('Unable to construct a calendar from given parameters')
 */
  /*else*/ {
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 335, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 335, __pyx_L1_error)
  }
  __pyx_L4:;

  /* "_redukti.pyx":336
 *         else:
 *             raise ValueError('Incorrect number of values in business centres list, max of 4 allowed')
 *         if self._calendar is NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError('Unable to construct a calendar from given parameters')
 * 
 */
  __pyx_t_3 = ((__pyx_v_self->_calendar == NULL) != 0);
  if (unlikely(__pyx_t_3)) {

    /* "_redukti.pyx":337
 *             raise ValueError('Incorrect number of values in business centres list, max of 4 allowed')
 *         if self._calendar is NULL:
 *             raise ValueError('Unable to construct a calendar from given parameters')             # <<<<<<<<<<<<<<
 * 
 *     cpdef bint is_holiday(self, Date d):
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 337, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 337, __pyx_L1_error)

    /* "_redukti.pyx":336
 *         else:
 *             raise ValueError('Incorrect number of values in business centres list, max of 4 allowed')
 *         if self._calendar is NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError('Unable to construct a calendar from given parameters')
 * 
 */
  }

  /* "_redukti.pyx":316
 *         pass
 * 
 *     def __cinit__(self, list business_centres):             # <<<<<<<<<<<<<<
 *         cdef calendar.JointCalendarParameters joint_calendars
 *         validate_business_centers(business_centres)
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Calendar.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":339
 *             raise ValueError('Unable to construct a calendar from given parameters')
 * 
 *     cpdef bint is_holiday(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Determines if the given date is a holiday as per this calendar.
 */

static PyObject *__pyx_pw_8_redukti_8Calendar_5is_holiday(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static int __pyx_f_8_redukti_8Calendar_is_holiday(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("is_holiday", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_holiday); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 339, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_8Calendar_5is_holiday)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 339, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 339, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":349
 *             True if it is a holiday
 *         """
 *         return self._calendar.is_holiday(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     def last_day_of_month(self, Date d):
 */
  __pyx_r = __pyx_v_self->_calendar->is_holiday(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":339
 *             raise ValueError('Unable to construct a calendar from given parameters')
 * 
 *     cpdef bint is_holiday(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Determines if the given date is a holiday as per this calendar.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.Calendar.is_holiday", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_8Calendar_5is_holiday(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_8Calendar_4is_holiday[] = "Calendar.is_holiday(self, Date d) -> bool\n\n        Determines if the given date is a holiday as per this calendar.\n\n        Args:\n            d: date to be checked\n            \n        Returns:\n            True if it is a holiday\n        ";
static PyObject *__pyx_pw_8_redukti_8Calendar_5is_holiday(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_holiday (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 339, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_8Calendar_4is_holiday(((struct __pyx_obj_8_redukti_Calendar *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_8Calendar_4is_holiday(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("is_holiday", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_f_8_redukti_8Calendar_is_holiday(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 339, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Calendar.is_holiday", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":351
 *         return self._calendar.is_holiday(d.serial())
 * 
 *     def last_day_of_month(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the last business date of the month/year in given date
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_8Calendar_7last_day_of_month(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_8Calendar_6last_day_of_month[] = "Calendar.last_day_of_month(self, Date d)\n\n        Computes the last business date of the month/year in given date\n\n        Args:\n            d: Date to be used to compute the last business day of month\n\n        Returns:\n            New Date object representing the last business day of the month\n        ";
static PyObject *__pyx_pw_8_redukti_8Calendar_7last_day_of_month(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("last_day_of_month (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 351, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_8Calendar_6last_day_of_month(((struct __pyx_obj_8_redukti_Calendar *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_8Calendar_6last_day_of_month(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("last_day_of_month", 0);

  /* "_redukti.pyx":361
 *             New Date object representing the last business day of the month
 *         """
 *         return Date(self._calendar.end_of_month(d.serial()))             # <<<<<<<<<<<<<<
 * 
 *     def advance(self, Date date, int n, enums.PeriodUnit unit,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_calendar->end_of_month(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 361, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 361, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":351
 *         return self._calendar.is_holiday(d.serial())
 * 
 *     def last_day_of_month(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the last business date of the month/year in given date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.Calendar.last_day_of_month", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":363
 *         return Date(self._calendar.end_of_month(d.serial()))
 * 
 *     def advance(self, Date date, int n, enums.PeriodUnit unit,             # <<<<<<<<<<<<<<
 *                 enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING, bint is_eom = False):
 *         """
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_8Calendar_9advance(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_8Calendar_8advance[] = "Calendar.advance(self, Date date, int n, PeriodUnit unit, BusinessDayConvention convention=enums.BusinessDayConvention.FOLLOWING, bool is_eom=False)\n\n        Advances the given date by the given period and if the resulting date is a holiday then adjusts it to be on a business day.\n        \n        Args:\n            date: Date from which new date is to be computed\n            n: Number of units\n            unit: Type of units\n            convention: Business Day Convention, defaults to ``FOLLOWING``\n            is_eom: Boolean value to indicate whether EOM convention should be applied, defaults to ``False``\n\n        Returns:\n            New Date object\n        ";
static PyObject *__pyx_pw_8_redukti_8Calendar_9advance(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_date = 0;
  int __pyx_v_n;
  enum redukti::PeriodUnit __pyx_v_unit;
  enum redukti::BusinessDayConvention __pyx_v_convention;
  int __pyx_v_is_eom;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("advance (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_date,&__pyx_n_s_n,&__pyx_n_s_unit,&__pyx_n_s_convention,&__pyx_n_s_is_eom,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_date)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("advance", 0, 3, 5, 1); __PYX_ERR(0, 363, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_unit)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("advance", 0, 3, 5, 2); __PYX_ERR(0, 363, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_convention);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_is_eom);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "advance") < 0)) __PYX_ERR(0, 363, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_date = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_n = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_n == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 363, __pyx_L3_error)
    __pyx_v_unit = ((enum redukti::PeriodUnit)__Pyx_PyInt_As_enum__redukti_3a__3a_PeriodUnit(values[2])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 363, __pyx_L3_error)
    if (values[3]) {
      __pyx_v_convention = ((enum redukti::BusinessDayConvention)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessDayConvention(values[3])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 364, __pyx_L3_error)
    } else {
      __pyx_v_convention = __pyx_k__22;
    }
    if (values[4]) {
      __pyx_v_is_eom = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_is_eom == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 364, __pyx_L3_error)
    } else {

      /* "_redukti.pyx":364
 * 
 *     def advance(self, Date date, int n, enums.PeriodUnit unit,
 *                 enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING, bint is_eom = False):             # <<<<<<<<<<<<<<
 *         """
 *         Advances the given date by the given period and if the resulting date is a holiday then adjusts it to be on a business day.
 */
      __pyx_v_is_eom = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("advance", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 363, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Calendar.advance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_date), __pyx_ptype_8_redukti_Date, 1, "date", 0))) __PYX_ERR(0, 363, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_8Calendar_8advance(((struct __pyx_obj_8_redukti_Calendar *)__pyx_v_self), __pyx_v_date, __pyx_v_n, __pyx_v_unit, __pyx_v_convention, __pyx_v_is_eom);

  /* "_redukti.pyx":363
 *         return Date(self._calendar.end_of_month(d.serial()))
 * 
 *     def advance(self, Date date, int n, enums.PeriodUnit unit,             # <<<<<<<<<<<<<<
 *                 enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING, bint is_eom = False):
 *         """
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_8Calendar_8advance(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_date, int __pyx_v_n, enum redukti::PeriodUnit __pyx_v_unit, enum redukti::BusinessDayConvention __pyx_v_convention, int __pyx_v_is_eom) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("advance", 0);

  /* "_redukti.pyx":378
 *             New Date object
 *         """
 *         validate_periodunit(unit)             # <<<<<<<<<<<<<<
 *         return Date(self._calendar.advance(date.serial(), n, unit, convention, is_eom))
 * 
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_periodunit(__pyx_v_unit); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 378, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":379
 *         """
 *         validate_periodunit(unit)
 *         return Date(self._calendar.advance(date.serial(), n, unit, convention, is_eom))             # <<<<<<<<<<<<<<
 * 
 *     def adjust(self, Date date, enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_calendar->advance(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_date->__pyx_vtab)->serial(__pyx_v_date, 0), __pyx_v_n, __pyx_v_unit, __pyx_v_convention, __pyx_v_is_eom)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 379, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 379, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":363
 *         return Date(self._calendar.end_of_month(d.serial()))
 * 
 *     def advance(self, Date date, int n, enums.PeriodUnit unit,             # <<<<<<<<<<<<<<
 *                 enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING, bint is_eom = False):
 *         """
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.Calendar.advance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":381
 *         return Date(self._calendar.advance(date.serial(), n, unit, convention, is_eom))
 * 
 *     def adjust(self, Date date, enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING):             # <<<<<<<<<<<<<<
 *         """
 *         If given date falls on holiday then a new date is computed that is a business day, else same date is returned
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_8Calendar_11adjust(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_8Calendar_10adjust[] = "Calendar.adjust(self, Date date, BusinessDayConvention convention=enums.BusinessDayConvention.FOLLOWING)\n\n        If given date falls on holiday then a new date is computed that is a business day, else same date is returned\n\n        Args:\n            date: Date to be checked\n            convention: Business Day Convention, defaults to ``FOLLOWING``\n\n        Returns:\n            New Date object\n        ";
static PyObject *__pyx_pw_8_redukti_8Calendar_11adjust(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_date = 0;
  enum redukti::BusinessDayConvention __pyx_v_convention;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("adjust (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_date,&__pyx_n_s_convention,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_date)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_convention);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "adjust") < 0)) __PYX_ERR(0, 381, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_date = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    if (values[1]) {
      __pyx_v_convention = ((enum redukti::BusinessDayConvention)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessDayConvention(values[1])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 381, __pyx_L3_error)
    } else {
      __pyx_v_convention = __pyx_k__23;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("adjust", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 381, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Calendar.adjust", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_date), __pyx_ptype_8_redukti_Date, 1, "date", 0))) __PYX_ERR(0, 381, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_8Calendar_10adjust(((struct __pyx_obj_8_redukti_Calendar *)__pyx_v_self), __pyx_v_date, __pyx_v_convention);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_8Calendar_10adjust(struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_date, enum redukti::BusinessDayConvention __pyx_v_convention) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("adjust", 0);

  /* "_redukti.pyx":392
 *             New Date object
 *         """
 *         return Date(self._calendar.adjust(date.serial(), convention))             # <<<<<<<<<<<<<<
 * 
 *     @staticmethod
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_calendar->adjust(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_date->__pyx_vtab)->serial(__pyx_v_date, 0), __pyx_v_convention)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 392, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 392, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":381
 *         return Date(self._calendar.advance(date.serial(), n, unit, convention, is_eom))
 * 
 *     def adjust(self, Date date, enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING):             # <<<<<<<<<<<<<<
 *         """
 *         If given date falls on holiday then a new date is computed that is a business day, else same date is returned
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.Calendar.adjust", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":395
 * 
 *     @staticmethod
 *     def register_calendar(enums.BusinessCenter id, list holidays):             # <<<<<<<<<<<<<<
 *         """
 *         Creates a calendar from a set of holidays and assign it to the business center
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_8Calendar_13register_calendar(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_8Calendar_12register_calendar[] = "Calendar.register_calendar(BusinessCenter id, list holidays)\n\n        Creates a calendar from a set of holidays and assign it to the business center\n\n        If the assignment is successful the service will take ownership of the instance\n        May fail if calendar instance already set and has been\n        accessed by a client - i.e. new calendars can only be set prior to\n        any use.\n        ";
static PyMethodDef __pyx_mdef_8_redukti_8Calendar_13register_calendar = {"register_calendar", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_8Calendar_13register_calendar, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_8Calendar_12register_calendar};
static PyObject *__pyx_pw_8_redukti_8Calendar_13register_calendar(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum redukti::BusinessCenter __pyx_v_id;
  PyObject *__pyx_v_holidays = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("register_calendar (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_holidays,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_holidays)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("register_calendar", 1, 2, 2, 1); __PYX_ERR(0, 395, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "register_calendar") < 0)) __PYX_ERR(0, 395, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_id = ((enum redukti::BusinessCenter)__Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(values[0])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 395, __pyx_L3_error)
    __pyx_v_holidays = ((PyObject*)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("register_calendar", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 395, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Calendar.register_calendar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_holidays), (&PyList_Type), 1, "holidays", 1))) __PYX_ERR(0, 395, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_8Calendar_12register_calendar(__pyx_v_id, __pyx_v_holidays);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_8Calendar_12register_calendar(enum redukti::BusinessCenter __pyx_v_id, PyObject *__pyx_v_holidays) {
  arrayobject *__pyx_v_dates = 0;
  int *__pyx_v_xdata;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  __Pyx_RefNannySetupContext("register_calendar", 0);

  /* "_redukti.pyx":404
 *         any use.
 *         """
 *         cdef array.array dates = convert_to_date_array(holidays)             # <<<<<<<<<<<<<<
 *         cdef int *xdata = <int *> dates.data.as_voidptr
 *         return calendar.get_calendar_factory().set_calendar(id, xdata, len(dates))
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_convert_to_date_array); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 404, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_holidays) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_holidays);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 404, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_7cpython_5array_array))))) __PYX_ERR(0, 404, __pyx_L1_error)
  __pyx_v_dates = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":405
 *         """
 *         cdef array.array dates = convert_to_date_array(holidays)
 *         cdef int *xdata = <int *> dates.data.as_voidptr             # <<<<<<<<<<<<<<
 *         return calendar.get_calendar_factory().set_calendar(id, xdata, len(dates))
 * 
 */
  __pyx_v_xdata = ((int *)__pyx_v_dates->data.as_voidptr);

  /* "_redukti.pyx":406
 *         cdef array.array dates = convert_to_date_array(holidays)
 *         cdef int *xdata = <int *> dates.data.as_voidptr
 *         return calendar.get_calendar_factory().set_calendar(id, xdata, len(dates))             # <<<<<<<<<<<<<<
 * 
 * cdef validate_daycountfraction(enums.DayCountFraction dfc):
 */
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(((PyObject *)__pyx_v_dates) == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 406, __pyx_L1_error)
  }
  __pyx_t_4 = Py_SIZE(((PyObject *)__pyx_v_dates)); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 406, __pyx_L1_error)
  __pyx_t_1 = __Pyx_PyBool_FromLong(redukti::get_calendar_factory()->set_calendar(__pyx_v_id, __pyx_v_xdata, __pyx_t_4)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 406, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":395
 * 
 *     @staticmethod
 *     def register_calendar(enums.BusinessCenter id, list holidays):             # <<<<<<<<<<<<<<
 *         """
 *         Creates a calendar from a set of holidays and assign it to the business center
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.Calendar.register_calendar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_dates);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_8Calendar_15__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_8Calendar_14__reduce_cython__[] = "Calendar.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_8Calendar_15__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_8Calendar_14__reduce_cython__(((struct __pyx_obj_8_redukti_Calendar *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_8Calendar_14__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Calendar *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Calendar.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_8Calendar_17__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_8Calendar_16__setstate_cython__[] = "Calendar.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_8Calendar_17__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_8Calendar_16__setstate_cython__(((struct __pyx_obj_8_redukti_Calendar *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_8Calendar_16__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Calendar *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Calendar.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":408
 *         return calendar.get_calendar_factory().set_calendar(id, xdata, len(dates))
 * 
 * cdef validate_daycountfraction(enums.DayCountFraction dfc):             # <<<<<<<<<<<<<<
 *     if dfc < 1 or dfc > enums.BUS_252:
 *         raise ValueError('Invalid DayCountFraction specified')
 */

static PyObject *__pyx_f_8_redukti_validate_daycountfraction(enum redukti::DayCountFraction __pyx_v_dfc) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("validate_daycountfraction", 0);

  /* "_redukti.pyx":409
 * 
 * cdef validate_daycountfraction(enums.DayCountFraction dfc):
 *     if dfc < 1 or dfc > enums.BUS_252:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid DayCountFraction specified')
 * 
 */
  __pyx_t_2 = ((__pyx_v_dfc < 1) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((__pyx_v_dfc > redukti::BUS_252) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":410
 * cdef validate_daycountfraction(enums.DayCountFraction dfc):
 *     if dfc < 1 or dfc > enums.BUS_252:
 *         raise ValueError('Invalid DayCountFraction specified')             # <<<<<<<<<<<<<<
 * 
 * cdef class DayFraction:
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 410, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 410, __pyx_L1_error)

    /* "_redukti.pyx":409
 * 
 * cdef validate_daycountfraction(enums.DayCountFraction dfc):
 *     if dfc < 1 or dfc > enums.BUS_252:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid DayCountFraction specified')
 * 
 */
  }

  /* "_redukti.pyx":408
 *         return calendar.get_calendar_factory().set_calendar(id, xdata, len(dates))
 * 
 * cdef validate_daycountfraction(enums.DayCountFraction dfc):             # <<<<<<<<<<<<<<
 *     if dfc < 1 or dfc > enums.BUS_252:
 *         raise ValueError('Invalid DayCountFraction specified')
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.validate_daycountfraction", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":422
 *     cdef const dayfraction.DayFraction *_dayfraction
 * 
 *     def __init__(self, enums.DayCountFraction dfc):             # <<<<<<<<<<<<<<
 *         """
 *         Constructs a DayFraction object
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_11DayFraction_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_11DayFraction___init__[] = "\n        Constructs a DayFraction object\n        Args:\n            dfc: The Day Count Fraction enum\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_8_redukti_11DayFraction___init__;
#endif
static int __pyx_pw_8_redukti_11DayFraction_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_dfc;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_dfc,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dfc)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 422, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_dfc = ((enum redukti::DayCountFraction)__Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(values[0])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 422, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 422, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.DayFraction.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_11DayFraction___init__(((struct __pyx_obj_8_redukti_DayFraction *)__pyx_v_self), __pyx_v_dfc);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_11DayFraction___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_dfc) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":430
 *         pass
 * 
 *     def __cinit__(self, enums.DayCountFraction dfc):             # <<<<<<<<<<<<<<
 *         validate_daycountfraction(dfc)
 *         self._dayfraction = dayfraction.get_day_fraction(dfc)
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_11DayFraction_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_11DayFraction_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum redukti::DayCountFraction __pyx_v_dfc;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_dfc,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dfc)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 430, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_dfc = ((enum redukti::DayCountFraction)__Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(values[0])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 430, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 430, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.DayFraction.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_11DayFraction_2__cinit__(((struct __pyx_obj_8_redukti_DayFraction *)__pyx_v_self), __pyx_v_dfc);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_11DayFraction_2__cinit__(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, enum redukti::DayCountFraction __pyx_v_dfc) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":431
 * 
 *     def __cinit__(self, enums.DayCountFraction dfc):
 *         validate_daycountfraction(dfc)             # <<<<<<<<<<<<<<
 *         self._dayfraction = dayfraction.get_day_fraction(dfc)
 * 
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_daycountfraction(__pyx_v_dfc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 431, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":432
 *     def __cinit__(self, enums.DayCountFraction dfc):
 *         validate_daycountfraction(dfc)
 *         self._dayfraction = dayfraction.get_day_fraction(dfc)             # <<<<<<<<<<<<<<
 * 
 *     cpdef double year_fraction(self, Date d1, Date d2):
 */
  __pyx_v_self->_dayfraction = redukti::get_day_fraction(__pyx_v_dfc);

  /* "_redukti.pyx":430
 *         pass
 * 
 *     def __cinit__(self, enums.DayCountFraction dfc):             # <<<<<<<<<<<<<<
 *         validate_daycountfraction(dfc)
 *         self._dayfraction = dayfraction.get_day_fraction(dfc)
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.DayFraction.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":434
 *         self._dayfraction = dayfraction.get_day_fraction(dfc)
 * 
 *     cpdef double year_fraction(self, Date d1, Date d2):             # <<<<<<<<<<<<<<
 *         """
 *         Calculates the day fraction between two dates
 */

static PyObject *__pyx_pw_8_redukti_11DayFraction_5year_fraction(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static double __pyx_f_8_redukti_11DayFraction_year_fraction(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  double __pyx_t_7;
  __Pyx_RefNannySetupContext("year_fraction", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_year_fraction); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 434, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_11DayFraction_5year_fraction)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        __pyx_t_5 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
            __pyx_t_5 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2)};
          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 434, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2)};
          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 434, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        {
          __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 434, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_6);
          if (__pyx_t_4) {
            __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
          }
          __Pyx_INCREF(((PyObject *)__pyx_v_d1));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d1));
          PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, ((PyObject *)__pyx_v_d1));
          __Pyx_INCREF(((PyObject *)__pyx_v_d2));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d2));
          PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, ((PyObject *)__pyx_v_d2));
          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 434, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 434, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_7;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":445
 *             A decimal expressed as a year fraction
 *         """
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double year_fraction_with_finalperiod(self, Date d1, Date d2, bint final_period):
 */
  __pyx_r = __pyx_v_self->_dayfraction->year_fraction(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d1->__pyx_vtab)->serial(__pyx_v_d1, 0), ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d2->__pyx_vtab)->serial(__pyx_v_d2, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":434
 *         self._dayfraction = dayfraction.get_day_fraction(dfc)
 * 
 *     cpdef double year_fraction(self, Date d1, Date d2):             # <<<<<<<<<<<<<<
 *         """
 *         Calculates the day fraction between two dates
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_WriteUnraisable("_redukti.DayFraction.year_fraction", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_11DayFraction_5year_fraction(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_11DayFraction_4year_fraction[] = "DayFraction.year_fraction(self, Date d1, Date d2) -> double\n\n        Calculates the day fraction between two dates\n        \n        Args:\n            d1: First date\n            d2: Second date\n\n        Returns:\n            A decimal expressed as a year fraction\n        ";
static PyObject *__pyx_pw_8_redukti_11DayFraction_5year_fraction(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_d1 = 0;
  struct __pyx_obj_8_redukti_Date *__pyx_v_d2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("year_fraction (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_d1,&__pyx_n_s_d2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("year_fraction", 1, 2, 2, 1); __PYX_ERR(0, 434, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "year_fraction") < 0)) __PYX_ERR(0, 434, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_d1 = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_d2 = ((struct __pyx_obj_8_redukti_Date *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("year_fraction", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 434, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.DayFraction.year_fraction", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d1), __pyx_ptype_8_redukti_Date, 1, "d1", 0))) __PYX_ERR(0, 434, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d2), __pyx_ptype_8_redukti_Date, 1, "d2", 0))) __PYX_ERR(0, 434, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_11DayFraction_4year_fraction(((struct __pyx_obj_8_redukti_DayFraction *)__pyx_v_self), __pyx_v_d1, __pyx_v_d2);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_11DayFraction_4year_fraction(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("year_fraction", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_11DayFraction_year_fraction(__pyx_v_self, __pyx_v_d1, __pyx_v_d2, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 434, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.DayFraction.year_fraction", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":447
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial())
 * 
 *     cpdef double year_fraction_with_finalperiod(self, Date d1, Date d2, bint final_period):             # <<<<<<<<<<<<<<
 *         """
 *         Calculates the day fraction between two dates, only used for ``30E/360.ISDA``
 */

static PyObject *__pyx_pw_8_redukti_11DayFraction_7year_fraction_with_finalperiod(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static double __pyx_f_8_redukti_11DayFraction_year_fraction_with_finalperiod(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_v_final_period, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  double __pyx_t_8;
  __Pyx_RefNannySetupContext("year_fraction_with_finalperiod", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_year_fraction_with_finalperiod); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 447, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_11DayFraction_7year_fraction_with_finalperiod)) {
        __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_final_period); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 447, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
        __pyx_t_6 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_5)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_5);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
            __pyx_t_6 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[4] = {__pyx_t_5, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2), __pyx_t_3};
          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 447, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[4] = {__pyx_t_5, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2), __pyx_t_3};
          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 447, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else
        #endif
        {
          __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 447, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_7);
          if (__pyx_t_5) {
            __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
          }
          __Pyx_INCREF(((PyObject *)__pyx_v_d1));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d1));
          PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, ((PyObject *)__pyx_v_d1));
          __Pyx_INCREF(((PyObject *)__pyx_v_d2));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d2));
          PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, ((PyObject *)__pyx_v_d2));
          __Pyx_GIVEREF(__pyx_t_3);
          PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_t_3);
          __pyx_t_3 = 0;
          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 447, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        }
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_8 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_8 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 447, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_8;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":459
 *             A decimal expressed as a year fraction
 *         """
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial(), final_period)             # <<<<<<<<<<<<<<
 * 
 *     cpdef double year_fraction_with_refdates(self, Date d1, Date d2, Date ref_date1, Date ref_date2):
 */
  __pyx_r = __pyx_v_self->_dayfraction->year_fraction(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d1->__pyx_vtab)->serial(__pyx_v_d1, 0), ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d2->__pyx_vtab)->serial(__pyx_v_d2, 0), __pyx_v_final_period);
  goto __pyx_L0;

  /* "_redukti.pyx":447
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial())
 * 
 *     cpdef double year_fraction_with_finalperiod(self, Date d1, Date d2, bint final_period):             # <<<<<<<<<<<<<<
 *         """
 *         Calculates the day fraction between two dates, only used for ``30E/360.ISDA``
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_WriteUnraisable("_redukti.DayFraction.year_fraction_with_finalperiod", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_11DayFraction_7year_fraction_with_finalperiod(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_11DayFraction_6year_fraction_with_finalperiod[] = "DayFraction.year_fraction_with_finalperiod(self, Date d1, Date d2, bool final_period) -> double\n\n        Calculates the day fraction between two dates, only used for ``30E/360.ISDA``\n\n        Args:\n            d1: First date\n            d2: Second date\n            final_period: The finalPeriod flag indicates whether this fraction is for the final period - i.e. d2 is maturity date.\n\n        Returns:\n            A decimal expressed as a year fraction\n        ";
static PyObject *__pyx_pw_8_redukti_11DayFraction_7year_fraction_with_finalperiod(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_d1 = 0;
  struct __pyx_obj_8_redukti_Date *__pyx_v_d2 = 0;
  int __pyx_v_final_period;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("year_fraction_with_finalperiod (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_d1,&__pyx_n_s_d2,&__pyx_n_s_final_period,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("year_fraction_with_finalperiod", 1, 3, 3, 1); __PYX_ERR(0, 447, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_final_period)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("year_fraction_with_finalperiod", 1, 3, 3, 2); __PYX_ERR(0, 447, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "year_fraction_with_finalperiod") < 0)) __PYX_ERR(0, 447, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_d1 = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_d2 = ((struct __pyx_obj_8_redukti_Date *)values[1]);
    __pyx_v_final_period = __Pyx_PyObject_IsTrue(values[2]); if (unlikely((__pyx_v_final_period == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 447, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("year_fraction_with_finalperiod", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 447, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.DayFraction.year_fraction_with_finalperiod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d1), __pyx_ptype_8_redukti_Date, 1, "d1", 0))) __PYX_ERR(0, 447, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d2), __pyx_ptype_8_redukti_Date, 1, "d2", 0))) __PYX_ERR(0, 447, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_11DayFraction_6year_fraction_with_finalperiod(((struct __pyx_obj_8_redukti_DayFraction *)__pyx_v_self), __pyx_v_d1, __pyx_v_d2, __pyx_v_final_period);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_11DayFraction_6year_fraction_with_finalperiod(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_v_final_period) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("year_fraction_with_finalperiod", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_11DayFraction_year_fraction_with_finalperiod(__pyx_v_self, __pyx_v_d1, __pyx_v_d2, __pyx_v_final_period, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 447, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.DayFraction.year_fraction_with_finalperiod", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":461
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial(), final_period)
 * 
 *     cpdef double year_fraction_with_refdates(self, Date d1, Date d2, Date ref_date1, Date ref_date2):             # <<<<<<<<<<<<<<
 *         """
 *         Calculates the day fraction between two dates, Used only for ACT/ACT.ISMA
 */

static PyObject *__pyx_pw_8_redukti_11DayFraction_9year_fraction_with_refdates(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static double __pyx_f_8_redukti_11DayFraction_year_fraction_with_refdates(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date1, struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date2, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  double __pyx_t_7;
  __Pyx_RefNannySetupContext("year_fraction_with_refdates", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_year_fraction_with_refdates); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 461, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_11DayFraction_9year_fraction_with_refdates)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        __pyx_t_5 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
            __pyx_t_5 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[5] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2), ((PyObject *)__pyx_v_ref_date1), ((PyObject *)__pyx_v_ref_date2)};
          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 4+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 461, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[5] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2), ((PyObject *)__pyx_v_ref_date1), ((PyObject *)__pyx_v_ref_date2)};
          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 4+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 461, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        {
          __pyx_t_6 = PyTuple_New(4+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 461, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_6);
          if (__pyx_t_4) {
            __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
          }
          __Pyx_INCREF(((PyObject *)__pyx_v_d1));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d1));
          PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, ((PyObject *)__pyx_v_d1));
          __Pyx_INCREF(((PyObject *)__pyx_v_d2));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d2));
          PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, ((PyObject *)__pyx_v_d2));
          __Pyx_INCREF(((PyObject *)__pyx_v_ref_date1));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_ref_date1));
          PyTuple_SET_ITEM(__pyx_t_6, 2+__pyx_t_5, ((PyObject *)__pyx_v_ref_date1));
          __Pyx_INCREF(((PyObject *)__pyx_v_ref_date2));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_ref_date2));
          PyTuple_SET_ITEM(__pyx_t_6, 3+__pyx_t_5, ((PyObject *)__pyx_v_ref_date2));
          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 461, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 461, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_7;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":474
 *             A decimal expressed as a year fraction
 *         """
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial(), ref_date1.serial(), ref_date2.serial())             # <<<<<<<<<<<<<<
 * 
 * cdef validate_isda_index(enums.IsdaIndex index):
 */
  __pyx_r = __pyx_v_self->_dayfraction->year_fraction(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d1->__pyx_vtab)->serial(__pyx_v_d1, 0), ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d2->__pyx_vtab)->serial(__pyx_v_d2, 0), ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_ref_date1->__pyx_vtab)->serial(__pyx_v_ref_date1, 0), ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_ref_date2->__pyx_vtab)->serial(__pyx_v_ref_date2, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":461
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial(), final_period)
 * 
 *     cpdef double year_fraction_with_refdates(self, Date d1, Date d2, Date ref_date1, Date ref_date2):             # <<<<<<<<<<<<<<
 *         """
 *         Calculates the day fraction between two dates, Used only for ACT/ACT.ISMA
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_WriteUnraisable("_redukti.DayFraction.year_fraction_with_refdates", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_11DayFraction_9year_fraction_with_refdates(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_11DayFraction_8year_fraction_with_refdates[] = "DayFraction.year_fraction_with_refdates(self, Date d1, Date d2, Date ref_date1, Date ref_date2) -> double\n\n        Calculates the day fraction between two dates, Used only for ACT/ACT.ISMA\n\n        Args:\n            d1: First date\n            d2: Second date\n            ref_date1: If regular period or front stub then adjusted end date minus calculation period frequency (roll convention NONE), else adjusted start date\n            ref_date2: If regular period or front stub then adjusted end date, else adjusted start date plus calculation period frequency (roll convention NONE)\n\n        Returns:\n            A decimal expressed as a year fraction\n        ";
static PyObject *__pyx_pw_8_redukti_11DayFraction_9year_fraction_with_refdates(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_d1 = 0;
  struct __pyx_obj_8_redukti_Date *__pyx_v_d2 = 0;
  struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date1 = 0;
  struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("year_fraction_with_refdates (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_d1,&__pyx_n_s_d2,&__pyx_n_s_ref_date1,&__pyx_n_s_ref_date2,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("year_fraction_with_refdates", 1, 4, 4, 1); __PYX_ERR(0, 461, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ref_date1)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("year_fraction_with_refdates", 1, 4, 4, 2); __PYX_ERR(0, 461, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ref_date2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("year_fraction_with_refdates", 1, 4, 4, 3); __PYX_ERR(0, 461, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "year_fraction_with_refdates") < 0)) __PYX_ERR(0, 461, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_d1 = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_d2 = ((struct __pyx_obj_8_redukti_Date *)values[1]);
    __pyx_v_ref_date1 = ((struct __pyx_obj_8_redukti_Date *)values[2]);
    __pyx_v_ref_date2 = ((struct __pyx_obj_8_redukti_Date *)values[3]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("year_fraction_with_refdates", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 461, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.DayFraction.year_fraction_with_refdates", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d1), __pyx_ptype_8_redukti_Date, 1, "d1", 0))) __PYX_ERR(0, 461, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d2), __pyx_ptype_8_redukti_Date, 1, "d2", 0))) __PYX_ERR(0, 461, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ref_date1), __pyx_ptype_8_redukti_Date, 1, "ref_date1", 0))) __PYX_ERR(0, 461, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ref_date2), __pyx_ptype_8_redukti_Date, 1, "ref_date2", 0))) __PYX_ERR(0, 461, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_11DayFraction_8year_fraction_with_refdates(((struct __pyx_obj_8_redukti_DayFraction *)__pyx_v_self), __pyx_v_d1, __pyx_v_d2, __pyx_v_ref_date1, __pyx_v_ref_date2);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_11DayFraction_8year_fraction_with_refdates(struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date1, struct __pyx_obj_8_redukti_Date *__pyx_v_ref_date2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("year_fraction_with_refdates", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_11DayFraction_year_fraction_with_refdates(__pyx_v_self, __pyx_v_d1, __pyx_v_d2, __pyx_v_ref_date1, __pyx_v_ref_date2, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 461, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.DayFraction.year_fraction_with_refdates", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_11DayFraction_11__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_11DayFraction_10__reduce_cython__[] = "DayFraction.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_11DayFraction_11__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_11DayFraction_10__reduce_cython__(((struct __pyx_obj_8_redukti_DayFraction *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_11DayFraction_10__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.DayFraction.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_11DayFraction_13__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_11DayFraction_12__setstate_cython__[] = "DayFraction.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_11DayFraction_13__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_11DayFraction_12__setstate_cython__(((struct __pyx_obj_8_redukti_DayFraction *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_11DayFraction_12__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_DayFraction *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.DayFraction.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":476
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial(), ref_date1.serial(), ref_date2.serial())
 * 
 * cdef validate_isda_index(enums.IsdaIndex index):             # <<<<<<<<<<<<<<
 *     if index < 1 or index > enums.ZAR_JIBAR_SAFEX:
 *         raise ValueError('Invalid IsdaIndex specified')
 */

static PyObject *__pyx_f_8_redukti_validate_isda_index(enum redukti::IsdaIndex __pyx_v_index) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("validate_isda_index", 0);

  /* "_redukti.pyx":477
 * 
 * cdef validate_isda_index(enums.IsdaIndex index):
 *     if index < 1 or index > enums.ZAR_JIBAR_SAFEX:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid IsdaIndex specified')
 * 
 */
  __pyx_t_2 = ((__pyx_v_index < 1) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((__pyx_v_index > redukti::ZAR_JIBAR_SAFEX) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":478
 * cdef validate_isda_index(enums.IsdaIndex index):
 *     if index < 1 or index > enums.ZAR_JIBAR_SAFEX:
 *         raise ValueError('Invalid IsdaIndex specified')             # <<<<<<<<<<<<<<
 * 
 * cdef validate_index_family(enums.IndexFamily family):
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__29, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 478, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 478, __pyx_L1_error)

    /* "_redukti.pyx":477
 * 
 * cdef validate_isda_index(enums.IsdaIndex index):
 *     if index < 1 or index > enums.ZAR_JIBAR_SAFEX:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid IsdaIndex specified')
 * 
 */
  }

  /* "_redukti.pyx":476
 *         return self._dayfraction.year_fraction(d1.serial(), d2.serial(), ref_date1.serial(), ref_date2.serial())
 * 
 * cdef validate_isda_index(enums.IsdaIndex index):             # <<<<<<<<<<<<<<
 *     if index < 1 or index > enums.ZAR_JIBAR_SAFEX:
 *         raise ValueError('Invalid IsdaIndex specified')
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.validate_isda_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":480
 *         raise ValueError('Invalid IsdaIndex specified')
 * 
 * cdef validate_index_family(enums.IndexFamily family):             # <<<<<<<<<<<<<<
 *     if family < 1 or family > enums.REPO_CURVE:
 *         raise ValueError('Invalid IndexFamily specified')
 */

static PyObject *__pyx_f_8_redukti_validate_index_family(enum redukti::IndexFamily __pyx_v_family) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("validate_index_family", 0);

  /* "_redukti.pyx":481
 * 
 * cdef validate_index_family(enums.IndexFamily family):
 *     if family < 1 or family > enums.REPO_CURVE:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid IndexFamily specified')
 * 
 */
  __pyx_t_2 = ((__pyx_v_family < 1) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((__pyx_v_family > redukti::REPO_CURVE) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":482
 * cdef validate_index_family(enums.IndexFamily family):
 *     if family < 1 or family > enums.REPO_CURVE:
 *         raise ValueError('Invalid IndexFamily specified')             # <<<<<<<<<<<<<<
 * 
 * cdef validate_tenor(enums.Tenor tenor):
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 482, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 482, __pyx_L1_error)

    /* "_redukti.pyx":481
 * 
 * cdef validate_index_family(enums.IndexFamily family):
 *     if family < 1 or family > enums.REPO_CURVE:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid IndexFamily specified')
 * 
 */
  }

  /* "_redukti.pyx":480
 *         raise ValueError('Invalid IsdaIndex specified')
 * 
 * cdef validate_index_family(enums.IndexFamily family):             # <<<<<<<<<<<<<<
 *     if family < 1 or family > enums.REPO_CURVE:
 *         raise ValueError('Invalid IndexFamily specified')
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.validate_index_family", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":484
 *         raise ValueError('Invalid IndexFamily specified')
 * 
 * cdef validate_tenor(enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *     if tenor < 0 or tenor > enums.TENOR_1T:
 *         raise ValueError('Invalid Tenor specified')
 */

static PyObject *__pyx_f_8_redukti_validate_tenor(enum redukti::Tenor __pyx_v_tenor) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("validate_tenor", 0);

  /* "_redukti.pyx":485
 * 
 * cdef validate_tenor(enums.Tenor tenor):
 *     if tenor < 0 or tenor > enums.TENOR_1T:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid Tenor specified')
 * 
 */
  __pyx_t_2 = ((__pyx_v_tenor < 0) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((__pyx_v_tenor > redukti::TENOR_1T) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":486
 * cdef validate_tenor(enums.Tenor tenor):
 *     if tenor < 0 or tenor > enums.TENOR_1T:
 *         raise ValueError('Invalid Tenor specified')             # <<<<<<<<<<<<<<
 * 
 * cdef validate_currency(enums.Currency ccy):
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 486, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 486, __pyx_L1_error)

    /* "_redukti.pyx":485
 * 
 * cdef validate_tenor(enums.Tenor tenor):
 *     if tenor < 0 or tenor > enums.TENOR_1T:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid Tenor specified')
 * 
 */
  }

  /* "_redukti.pyx":484
 *         raise ValueError('Invalid IndexFamily specified')
 * 
 * cdef validate_tenor(enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *     if tenor < 0 or tenor > enums.TENOR_1T:
 *         raise ValueError('Invalid Tenor specified')
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.validate_tenor", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":488
 *         raise ValueError('Invalid Tenor specified')
 * 
 * cdef validate_currency(enums.Currency ccy):             # <<<<<<<<<<<<<<
 *     if ccy < 0 or ccy > enums.PLN:
 *         raise ValueError('Invalid Currency specified')
 */

static PyObject *__pyx_f_8_redukti_validate_currency(enum redukti::Currency __pyx_v_ccy) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("validate_currency", 0);

  /* "_redukti.pyx":489
 * 
 * cdef validate_currency(enums.Currency ccy):
 *     if ccy < 0 or ccy > enums.PLN:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid Currency specified')
 * 
 */
  __pyx_t_2 = ((__pyx_v_ccy < 0) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((__pyx_v_ccy > redukti::PLN) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":490
 * cdef validate_currency(enums.Currency ccy):
 *     if ccy < 0 or ccy > enums.PLN:
 *         raise ValueError('Invalid Currency specified')             # <<<<<<<<<<<<<<
 * 
 * cdef validate_interpolator_type(enums.InterpolatorType t):
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__32, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 490, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 490, __pyx_L1_error)

    /* "_redukti.pyx":489
 * 
 * cdef validate_currency(enums.Currency ccy):
 *     if ccy < 0 or ccy > enums.PLN:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid Currency specified')
 * 
 */
  }

  /* "_redukti.pyx":488
 *         raise ValueError('Invalid Tenor specified')
 * 
 * cdef validate_currency(enums.Currency ccy):             # <<<<<<<<<<<<<<
 *     if ccy < 0 or ccy > enums.PLN:
 *         raise ValueError('Invalid Currency specified')
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.validate_currency", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":492
 *         raise ValueError('Invalid Currency specified')
 * 
 * cdef validate_interpolator_type(enums.InterpolatorType t):             # <<<<<<<<<<<<<<
 *     if t < 0 or t > enums.CUBIC_SPLINE_CLAMPED:
 *         raise ValueError('Invalid InterpolatorType specified')
 */

static PyObject *__pyx_f_8_redukti_validate_interpolator_type(enum redukti::InterpolatorType __pyx_v_t) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("validate_interpolator_type", 0);

  /* "_redukti.pyx":493
 * 
 * cdef validate_interpolator_type(enums.InterpolatorType t):
 *     if t < 0 or t > enums.CUBIC_SPLINE_CLAMPED:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid InterpolatorType specified')
 * 
 */
  __pyx_t_2 = ((__pyx_v_t < 0) != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_2 = ((__pyx_v_t > redukti::CUBIC_SPLINE_CLAMPED) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "_redukti.pyx":494
 * cdef validate_interpolator_type(enums.InterpolatorType t):
 *     if t < 0 or t > enums.CUBIC_SPLINE_CLAMPED:
 *         raise ValueError('Invalid InterpolatorType specified')             # <<<<<<<<<<<<<<
 * 
 * cdef class InterestRateIndex:
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__33, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 494, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 494, __pyx_L1_error)

    /* "_redukti.pyx":493
 * 
 * cdef validate_interpolator_type(enums.InterpolatorType t):
 *     if t < 0 or t > enums.CUBIC_SPLINE_CLAMPED:             # <<<<<<<<<<<<<<
 *         raise ValueError('Invalid InterpolatorType specified')
 * 
 */
  }

  /* "_redukti.pyx":492
 *         raise ValueError('Invalid Currency specified')
 * 
 * cdef validate_interpolator_type(enums.InterpolatorType t):             # <<<<<<<<<<<<<<
 *     if t < 0 or t > enums.CUBIC_SPLINE_CLAMPED:
 *         raise ValueError('Invalid InterpolatorType specified')
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.validate_interpolator_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":505
 *     cdef const index.InterestRateIndex *_index
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._index = NULL
 * 
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_17InterestRateIndex_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_17InterestRateIndex_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex___cinit__(((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_17InterestRateIndex___cinit__(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":506
 * 
 *     def __cinit__(self):
 *         self._index = NULL             # <<<<<<<<<<<<<<
 * 
 *     @staticmethod
 */
  __pyx_v_self->_index = NULL;

  /* "_redukti.pyx":505
 *     cdef const index.InterestRateIndex *_index
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self._index = NULL
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":509
 * 
 *     @staticmethod
 *     def get_index_by_isdaindex(enums.IsdaIndex isda_index, enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains an instance by IsdaIndex and Tenor
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_3get_index_by_isdaindex(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_2get_index_by_isdaindex[] = "InterestRateIndex.get_index_by_isdaindex(IsdaIndex isda_index, Tenor tenor)\n\n        Obtains an instance by IsdaIndex and Tenor\n        ";
static PyMethodDef __pyx_mdef_8_redukti_17InterestRateIndex_3get_index_by_isdaindex = {"get_index_by_isdaindex", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_17InterestRateIndex_3get_index_by_isdaindex, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_17InterestRateIndex_2get_index_by_isdaindex};
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_3get_index_by_isdaindex(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum redukti::IsdaIndex __pyx_v_isda_index;
  enum redukti::Tenor __pyx_v_tenor;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_index_by_isdaindex (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_isda_index,&__pyx_n_s_tenor,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_isda_index)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_tenor)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_index_by_isdaindex", 1, 2, 2, 1); __PYX_ERR(0, 509, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_index_by_isdaindex") < 0)) __PYX_ERR(0, 509, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_isda_index = ((enum redukti::IsdaIndex)__Pyx_PyInt_As_enum__redukti_3a__3a_IsdaIndex(values[0])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 509, __pyx_L3_error)
    __pyx_v_tenor = ((enum redukti::Tenor)__Pyx_PyInt_As_enum__redukti_3a__3a_Tenor(values[1])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 509, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get_index_by_isdaindex", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 509, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InterestRateIndex.get_index_by_isdaindex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_2get_index_by_isdaindex(__pyx_v_isda_index, __pyx_v_tenor);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_2get_index_by_isdaindex(enum redukti::IsdaIndex __pyx_v_isda_index, enum redukti::Tenor __pyx_v_tenor) {
  redukti::InterestRateIndex const *__pyx_v_idx;
  struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_obj = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("get_index_by_isdaindex", 0);

  /* "_redukti.pyx":513
 *         Obtains an instance by IsdaIndex and Tenor
 *         """
 *         validate_isda_index(isda_index)             # <<<<<<<<<<<<<<
 *         validate_tenor(tenor)
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(isda_index, tenor)
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_isda_index(__pyx_v_isda_index); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 513, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":514
 *         """
 *         validate_isda_index(isda_index)
 *         validate_tenor(tenor)             # <<<<<<<<<<<<<<
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(isda_index, tenor)
 *         if idx is NULL:
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_tenor(__pyx_v_tenor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 514, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":515
 *         validate_isda_index(isda_index)
 *         validate_tenor(tenor)
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(isda_index, tenor)             # <<<<<<<<<<<<<<
 *         if idx is NULL:
 *             raise ValueError('Index not defined for given IsdaIndex and Tenor')
 */
  __pyx_v_idx = redukti::get_default_index_service()->get_index(__pyx_v_isda_index, __pyx_v_tenor);

  /* "_redukti.pyx":516
 *         validate_tenor(tenor)
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(isda_index, tenor)
 *         if idx is NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError('Index not defined for given IsdaIndex and Tenor')
 *         cdef InterestRateIndex obj = InterestRateIndex()
 */
  __pyx_t_2 = ((__pyx_v_idx == NULL) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":517
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(isda_index, tenor)
 *         if idx is NULL:
 *             raise ValueError('Index not defined for given IsdaIndex and Tenor')             # <<<<<<<<<<<<<<
 *         cdef InterestRateIndex obj = InterestRateIndex()
 *         obj._index = idx
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__34, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 517, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 517, __pyx_L1_error)

    /* "_redukti.pyx":516
 *         validate_tenor(tenor)
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(isda_index, tenor)
 *         if idx is NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError('Index not defined for given IsdaIndex and Tenor')
 *         cdef InterestRateIndex obj = InterestRateIndex()
 */
  }

  /* "_redukti.pyx":518
 *         if idx is NULL:
 *             raise ValueError('Index not defined for given IsdaIndex and Tenor')
 *         cdef InterestRateIndex obj = InterestRateIndex()             # <<<<<<<<<<<<<<
 *         obj._index = idx
 *         return obj
 */
  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)__pyx_ptype_8_redukti_InterestRateIndex)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 518, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_obj = ((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":519
 *             raise ValueError('Index not defined for given IsdaIndex and Tenor')
 *         cdef InterestRateIndex obj = InterestRateIndex()
 *         obj._index = idx             # <<<<<<<<<<<<<<
 *         return obj
 * 
 */
  __pyx_v_obj->_index = __pyx_v_idx;

  /* "_redukti.pyx":520
 *         cdef InterestRateIndex obj = InterestRateIndex()
 *         obj._index = idx
 *         return obj             # <<<<<<<<<<<<<<
 * 
 *     @staticmethod
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_obj));
  __pyx_r = ((PyObject *)__pyx_v_obj);
  goto __pyx_L0;

  /* "_redukti.pyx":509
 * 
 *     @staticmethod
 *     def get_index_by_isdaindex(enums.IsdaIndex isda_index, enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains an instance by IsdaIndex and Tenor
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.get_index_by_isdaindex", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_obj);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":523
 * 
 *     @staticmethod
 *     def get_index(enums.Currency currency, enums.IndexFamily index_family, enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains an instance by Currency, IndexFamily and Tenor
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_5get_index(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_4get_index[] = "InterestRateIndex.get_index(Currency currency, IndexFamily index_family, Tenor tenor)\n\n        Obtains an instance by Currency, IndexFamily and Tenor\n        ";
static PyMethodDef __pyx_mdef_8_redukti_17InterestRateIndex_5get_index = {"get_index", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_17InterestRateIndex_5get_index, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_17InterestRateIndex_4get_index};
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_5get_index(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum redukti::Currency __pyx_v_currency;
  enum redukti::IndexFamily __pyx_v_index_family;
  enum redukti::Tenor __pyx_v_tenor;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_index (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_currency,&__pyx_n_s_index_family,&__pyx_n_s_tenor,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_currency)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_index_family)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_index", 1, 3, 3, 1); __PYX_ERR(0, 523, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_tenor)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_index", 1, 3, 3, 2); __PYX_ERR(0, 523, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_index") < 0)) __PYX_ERR(0, 523, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_currency = ((enum redukti::Currency)__Pyx_PyInt_As_enum__redukti_3a__3a_Currency(values[0])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 523, __pyx_L3_error)
    __pyx_v_index_family = ((enum redukti::IndexFamily)__Pyx_PyInt_As_enum__redukti_3a__3a_IndexFamily(values[1])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 523, __pyx_L3_error)
    __pyx_v_tenor = ((enum redukti::Tenor)__Pyx_PyInt_As_enum__redukti_3a__3a_Tenor(values[2])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 523, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get_index", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 523, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InterestRateIndex.get_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_4get_index(__pyx_v_currency, __pyx_v_index_family, __pyx_v_tenor);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_4get_index(enum redukti::Currency __pyx_v_currency, enum redukti::IndexFamily __pyx_v_index_family, enum redukti::Tenor __pyx_v_tenor) {
  redukti::InterestRateIndex const *__pyx_v_idx;
  struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_obj = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("get_index", 0);

  /* "_redukti.pyx":527
 *         Obtains an instance by Currency, IndexFamily and Tenor
 *         """
 *         validate_currency(currency)             # <<<<<<<<<<<<<<
 *         validate_index_family(index_family)
 *         validate_tenor(tenor)
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_currency(__pyx_v_currency); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 527, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":528
 *         """
 *         validate_currency(currency)
 *         validate_index_family(index_family)             # <<<<<<<<<<<<<<
 *         validate_tenor(tenor)
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(currency, index_family,
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_index_family(__pyx_v_index_family); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 528, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":529
 *         validate_currency(currency)
 *         validate_index_family(index_family)
 *         validate_tenor(tenor)             # <<<<<<<<<<<<<<
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(currency, index_family,
 *                                                                                               tenor)
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_tenor(__pyx_v_tenor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 529, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":530
 *         validate_index_family(index_family)
 *         validate_tenor(tenor)
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(currency, index_family,             # <<<<<<<<<<<<<<
 *                                                                                               tenor)
 *         if idx is NULL:
 */
  __pyx_v_idx = redukti::get_default_index_service()->get_index(__pyx_v_currency, __pyx_v_index_family, __pyx_v_tenor);

  /* "_redukti.pyx":532
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(currency, index_family,
 *                                                                                               tenor)
 *         if idx is NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError('Index not defined for given Currency, IndexFamily and Tenor')
 *         cdef InterestRateIndex obj = InterestRateIndex()
 */
  __pyx_t_2 = ((__pyx_v_idx == NULL) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":533
 *                                                                                               tenor)
 *         if idx is NULL:
 *             raise ValueError('Index not defined for given Currency, IndexFamily and Tenor')             # <<<<<<<<<<<<<<
 *         cdef InterestRateIndex obj = InterestRateIndex()
 *         obj._index = idx
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__35, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 533, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 533, __pyx_L1_error)

    /* "_redukti.pyx":532
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(currency, index_family,
 *                                                                                               tenor)
 *         if idx is NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError('Index not defined for given Currency, IndexFamily and Tenor')
 *         cdef InterestRateIndex obj = InterestRateIndex()
 */
  }

  /* "_redukti.pyx":534
 *         if idx is NULL:
 *             raise ValueError('Index not defined for given Currency, IndexFamily and Tenor')
 *         cdef InterestRateIndex obj = InterestRateIndex()             # <<<<<<<<<<<<<<
 *         obj._index = idx
 *         return obj
 */
  __pyx_t_1 = __Pyx_PyObject_CallNoArg(((PyObject *)__pyx_ptype_8_redukti_InterestRateIndex)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 534, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_obj = ((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":535
 *             raise ValueError('Index not defined for given Currency, IndexFamily and Tenor')
 *         cdef InterestRateIndex obj = InterestRateIndex()
 *         obj._index = idx             # <<<<<<<<<<<<<<
 *         return obj
 * 
 */
  __pyx_v_obj->_index = __pyx_v_idx;

  /* "_redukti.pyx":536
 *         cdef InterestRateIndex obj = InterestRateIndex()
 *         obj._index = idx
 *         return obj             # <<<<<<<<<<<<<<
 * 
 *     cpdef Date value_date(self, Date fixing_date):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_obj));
  __pyx_r = ((PyObject *)__pyx_v_obj);
  goto __pyx_L0;

  /* "_redukti.pyx":523
 * 
 *     @staticmethod
 *     def get_index(enums.Currency currency, enums.IndexFamily index_family, enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains an instance by Currency, IndexFamily and Tenor
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.get_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_obj);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":538
 *         return obj
 * 
 *     cpdef Date value_date(self, Date fixing_date):             # <<<<<<<<<<<<<<
 *         """
 *         Given a fixing date, calculate the value date
 */

static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_7value_date(PyObject *__pyx_v_self, PyObject *__pyx_v_fixing_date); /*proto*/
static struct __pyx_obj_8_redukti_Date *__pyx_f_8_redukti_17InterestRateIndex_value_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_fixing_date, int __pyx_skip_dispatch) {
  struct __pyx_obj_8_redukti_Date *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("value_date", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_value_date); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 538, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_17InterestRateIndex_7value_date)) {
        __Pyx_XDECREF(((PyObject *)__pyx_r));
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_fixing_date)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_fixing_date));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 538, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_Date))))) __PYX_ERR(0, 538, __pyx_L1_error)
        __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":544
 *         Applies the calendars and day conventions associated with the index
 *         """
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.value_date(fixing_date.serial()))
 */
  __pyx_t_5 = ((__pyx_v_self->_index == NULL) != 0);
  if (__pyx_t_5) {

    /* "_redukti.pyx":545
 *         """
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')             # <<<<<<<<<<<<<<
 *         return Date(self._index.value_date(fixing_date.serial()))
 * 
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 545, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_8_redukti_Date))))) __PYX_ERR(0, 545, __pyx_L1_error)
    __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_1);
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "_redukti.pyx":544
 *         Applies the calendars and day conventions associated with the index
 *         """
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.value_date(fixing_date.serial()))
 */
  }

  /* "_redukti.pyx":546
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.value_date(fixing_date.serial()))             # <<<<<<<<<<<<<<
 * 
 *     cpdef Date fixing_date(self, Date accrual_start_date):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_index->value_date(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_fixing_date->__pyx_vtab)->serial(__pyx_v_fixing_date, 0))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 546, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 546, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":538
 *         return obj
 * 
 *     cpdef Date value_date(self, Date fixing_date):             # <<<<<<<<<<<<<<
 *         """
 *         Given a fixing date, calculate the value date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.value_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_7value_date(PyObject *__pyx_v_self, PyObject *__pyx_v_fixing_date); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_6value_date[] = "InterestRateIndex.value_date(self, Date fixing_date) -> Date\n\n        Given a fixing date, calculate the value date\n        \n        Applies the calendars and day conventions associated with the index\n        ";
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_7value_date(PyObject *__pyx_v_self, PyObject *__pyx_v_fixing_date) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("value_date (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_fixing_date), __pyx_ptype_8_redukti_Date, 1, "fixing_date", 0))) __PYX_ERR(0, 538, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_6value_date(((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_fixing_date));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_6value_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_fixing_date) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("value_date", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_8_redukti_17InterestRateIndex_value_date(__pyx_v_self, __pyx_v_fixing_date, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 538, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.value_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":548
 *         return Date(self._index.value_date(fixing_date.serial()))
 * 
 *     cpdef Date fixing_date(self, Date accrual_start_date):             # <<<<<<<<<<<<<<
 *         """
 *         Given a value date, calculate the fixing date
 */

static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_9fixing_date(PyObject *__pyx_v_self, PyObject *__pyx_v_accrual_start_date); /*proto*/
static struct __pyx_obj_8_redukti_Date *__pyx_f_8_redukti_17InterestRateIndex_fixing_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_accrual_start_date, int __pyx_skip_dispatch) {
  struct __pyx_obj_8_redukti_Date *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("fixing_date", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fixing_date); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 548, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_17InterestRateIndex_9fixing_date)) {
        __Pyx_XDECREF(((PyObject *)__pyx_r));
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_accrual_start_date)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_accrual_start_date));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 548, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_Date))))) __PYX_ERR(0, 548, __pyx_L1_error)
        __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":554
 *         Applies the calendars and day conventions associated with the index
 *         """
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.fixing_date(accrual_start_date.serial()))
 */
  __pyx_t_5 = ((__pyx_v_self->_index == NULL) != 0);
  if (__pyx_t_5) {

    /* "_redukti.pyx":555
 *         """
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')             # <<<<<<<<<<<<<<
 *         return Date(self._index.fixing_date(accrual_start_date.serial()))
 * 
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_8_redukti_Date))))) __PYX_ERR(0, 555, __pyx_L1_error)
    __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_1);
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "_redukti.pyx":554
 *         Applies the calendars and day conventions associated with the index
 *         """
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.fixing_date(accrual_start_date.serial()))
 */
  }

  /* "_redukti.pyx":556
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.fixing_date(accrual_start_date.serial()))             # <<<<<<<<<<<<<<
 * 
 *     cpdef Date maturity_date(self, Date value_date):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_index->fixing_date(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_accrual_start_date->__pyx_vtab)->serial(__pyx_v_accrual_start_date, 0))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 556, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 556, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":548
 *         return Date(self._index.value_date(fixing_date.serial()))
 * 
 *     cpdef Date fixing_date(self, Date accrual_start_date):             # <<<<<<<<<<<<<<
 *         """
 *         Given a value date, calculate the fixing date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.fixing_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_9fixing_date(PyObject *__pyx_v_self, PyObject *__pyx_v_accrual_start_date); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_8fixing_date[] = "InterestRateIndex.fixing_date(self, Date accrual_start_date) -> Date\n\n        Given a value date, calculate the fixing date\n\n        Applies the calendars and day conventions associated with the index\n        ";
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_9fixing_date(PyObject *__pyx_v_self, PyObject *__pyx_v_accrual_start_date) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fixing_date (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_accrual_start_date), __pyx_ptype_8_redukti_Date, 1, "accrual_start_date", 0))) __PYX_ERR(0, 548, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_8fixing_date(((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_accrual_start_date));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_8fixing_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_accrual_start_date) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("fixing_date", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_8_redukti_17InterestRateIndex_fixing_date(__pyx_v_self, __pyx_v_accrual_start_date, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 548, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.fixing_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":558
 *         return Date(self._index.fixing_date(accrual_start_date.serial()))
 * 
 *     cpdef Date maturity_date(self, Date value_date):             # <<<<<<<<<<<<<<
 *         """
 *         Given a value date calculate the maturity date
 */

static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_11maturity_date(PyObject *__pyx_v_self, PyObject *__pyx_v_value_date); /*proto*/
static struct __pyx_obj_8_redukti_Date *__pyx_f_8_redukti_17InterestRateIndex_maturity_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_value_date, int __pyx_skip_dispatch) {
  struct __pyx_obj_8_redukti_Date *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("maturity_date", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_maturity_date); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 558, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_17InterestRateIndex_11maturity_date)) {
        __Pyx_XDECREF(((PyObject *)__pyx_r));
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_value_date)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_value_date));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 558, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_Date))))) __PYX_ERR(0, 558, __pyx_L1_error)
        __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":564
 *         Applies the calendars and day conventions associated with the index
 *         """
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.maturity_date(value_date.serial()))
 */
  __pyx_t_5 = ((__pyx_v_self->_index == NULL) != 0);
  if (__pyx_t_5) {

    /* "_redukti.pyx":565
 *         """
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')             # <<<<<<<<<<<<<<
 *         return Date(self._index.maturity_date(value_date.serial()))
 * 
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 565, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_8_redukti_Date))))) __PYX_ERR(0, 565, __pyx_L1_error)
    __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_1);
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "_redukti.pyx":564
 *         Applies the calendars and day conventions associated with the index
 *         """
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.maturity_date(value_date.serial()))
 */
  }

  /* "_redukti.pyx":566
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')
 *         return Date(self._index.maturity_date(value_date.serial()))             # <<<<<<<<<<<<<<
 * 
 *     def date_components(self, Date accrual_start_date):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_index->maturity_date(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_value_date->__pyx_vtab)->serial(__pyx_v_value_date, 0))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 566, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 566, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":558
 *         return Date(self._index.fixing_date(accrual_start_date.serial()))
 * 
 *     cpdef Date maturity_date(self, Date value_date):             # <<<<<<<<<<<<<<
 *         """
 *         Given a value date calculate the maturity date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.maturity_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_11maturity_date(PyObject *__pyx_v_self, PyObject *__pyx_v_value_date); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_10maturity_date[] = "InterestRateIndex.maturity_date(self, Date value_date) -> Date\n\n        Given a value date calculate the maturity date\n\n        Applies the calendars and day conventions associated with the index\n        ";
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_11maturity_date(PyObject *__pyx_v_self, PyObject *__pyx_v_value_date) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("maturity_date (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_value_date), __pyx_ptype_8_redukti_Date, 1, "value_date", 0))) __PYX_ERR(0, 558, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_10maturity_date(((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_value_date));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_10maturity_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_value_date) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("maturity_date", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_8_redukti_17InterestRateIndex_maturity_date(__pyx_v_self, __pyx_v_value_date, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 558, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.maturity_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":568
 *         return Date(self._index.maturity_date(value_date.serial()))
 * 
 *     def date_components(self, Date accrual_start_date):             # <<<<<<<<<<<<<<
 *         """
 *         For a given accrual start date, computes fixing date, value date and maturity date
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_13date_components(PyObject *__pyx_v_self, PyObject *__pyx_v_accrual_start_date); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_12date_components[] = "InterestRateIndex.date_components(self, Date accrual_start_date)\n\n        For a given accrual start date, computes fixing date, value date and maturity date\n\n        Args:\n            accrual_start_date: Adjusted start date\n\n        Returns:\n            Tuple containing fixing date, value date and maturity date\n        ";
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_13date_components(PyObject *__pyx_v_self, PyObject *__pyx_v_accrual_start_date) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("date_components (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_accrual_start_date), __pyx_ptype_8_redukti_Date, 1, "accrual_start_date", 0))) __PYX_ERR(0, 568, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_12date_components(((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_accrual_start_date));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_12date_components(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_accrual_start_date) {
  int __pyx_v_fixing;
  int __pyx_v_value_dt;
  int __pyx_v_maturity_dt;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("date_components", 0);

  /* "_redukti.pyx":578
 *             Tuple containing fixing date, value date and maturity date
 *         """
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         cdef int fixing = self._index.fixing_date(accrual_start_date.serial())
 */
  __pyx_t_1 = ((__pyx_v_self->_index == NULL) != 0);
  if (__pyx_t_1) {

    /* "_redukti.pyx":579
 *         """
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')             # <<<<<<<<<<<<<<
 *         cdef int fixing = self._index.fixing_date(accrual_start_date.serial())
 *         cdef int value_dt = self._index.value_date(fixing)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 579, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "_redukti.pyx":578
 *             Tuple containing fixing date, value date and maturity date
 *         """
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         cdef int fixing = self._index.fixing_date(accrual_start_date.serial())
 */
  }

  /* "_redukti.pyx":580
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')
 *         cdef int fixing = self._index.fixing_date(accrual_start_date.serial())             # <<<<<<<<<<<<<<
 *         cdef int value_dt = self._index.value_date(fixing)
 *         cdef int maturity_dt = self._index.maturity_date(value_dt)
 */
  __pyx_v_fixing = __pyx_v_self->_index->fixing_date(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_accrual_start_date->__pyx_vtab)->serial(__pyx_v_accrual_start_date, 0));

  /* "_redukti.pyx":581
 *             return Exception('Index object is not initialized')
 *         cdef int fixing = self._index.fixing_date(accrual_start_date.serial())
 *         cdef int value_dt = self._index.value_date(fixing)             # <<<<<<<<<<<<<<
 *         cdef int maturity_dt = self._index.maturity_date(value_dt)
 *         return Date(fixing), Date(value_dt), Date(maturity_dt)
 */
  __pyx_v_value_dt = __pyx_v_self->_index->value_date(__pyx_v_fixing);

  /* "_redukti.pyx":582
 *         cdef int fixing = self._index.fixing_date(accrual_start_date.serial())
 *         cdef int value_dt = self._index.value_date(fixing)
 *         cdef int maturity_dt = self._index.maturity_date(value_dt)             # <<<<<<<<<<<<<<
 *         return Date(fixing), Date(value_dt), Date(maturity_dt)
 * 
 */
  __pyx_v_maturity_dt = __pyx_v_self->_index->maturity_date(__pyx_v_value_dt);

  /* "_redukti.pyx":583
 *         cdef int value_dt = self._index.value_date(fixing)
 *         cdef int maturity_dt = self._index.maturity_date(value_dt)
 *         return Date(fixing), Date(value_dt), Date(maturity_dt)             # <<<<<<<<<<<<<<
 * 
 *     cpdef Date adjust_date(self, Date unadjusted, int days):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_fixing); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 583, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 583, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_value_dt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 583, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 583, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_maturity_dt); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 583, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 583, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 583, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_t_5);
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_t_5 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":568
 *         return Date(self._index.maturity_date(value_date.serial()))
 * 
 *     def date_components(self, Date accrual_start_date):             # <<<<<<<<<<<<<<
 *         """
 *         For a given accrual start date, computes fixing date, value date and maturity date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.date_components", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":585
 *         return Date(fixing), Date(value_dt), Date(maturity_dt)
 * 
 *     cpdef Date adjust_date(self, Date unadjusted, int days):             # <<<<<<<<<<<<<<
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')
 */

static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_15adjust_date(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static struct __pyx_obj_8_redukti_Date *__pyx_f_8_redukti_17InterestRateIndex_adjust_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_unadjusted, int __pyx_v_days, int __pyx_skip_dispatch) {
  struct __pyx_obj_8_redukti_Date *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  __Pyx_RefNannySetupContext("adjust_date", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_adjust_date); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 585, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_17InterestRateIndex_15adjust_date)) {
        __Pyx_XDECREF(((PyObject *)__pyx_r));
        __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_days); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 585, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
        __pyx_t_6 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_5)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_5);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
            __pyx_t_6 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[3] = {__pyx_t_5, ((PyObject *)__pyx_v_unadjusted), __pyx_t_3};
          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 585, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
          PyObject *__pyx_temp[3] = {__pyx_t_5, ((PyObject *)__pyx_v_unadjusted), __pyx_t_3};
          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 585, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        } else
        #endif
        {
          __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 585, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_7);
          if (__pyx_t_5) {
            __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
          }
          __Pyx_INCREF(((PyObject *)__pyx_v_unadjusted));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_unadjusted));
          PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, ((PyObject *)__pyx_v_unadjusted));
          __Pyx_GIVEREF(__pyx_t_3);
          PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_3);
          __pyx_t_3 = 0;
          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 585, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        }
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_Date))))) __PYX_ERR(0, 585, __pyx_L1_error)
        __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":586
 * 
 *     cpdef Date adjust_date(self, Date unadjusted, int days):
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         return Date(
 */
  __pyx_t_8 = ((__pyx_v_self->_index == NULL) != 0);
  if (__pyx_t_8) {

    /* "_redukti.pyx":587
 *     cpdef Date adjust_date(self, Date unadjusted, int days):
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')             # <<<<<<<<<<<<<<
 *         return Date(
 *             self._index.fixing_calendar().advance(unadjusted.serial(), days, enums.DAYS, self._index.day_convention()))
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 587, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_8_redukti_Date))))) __PYX_ERR(0, 587, __pyx_L1_error)
    __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_1);
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "_redukti.pyx":586
 * 
 *     cpdef Date adjust_date(self, Date unadjusted, int days):
 *         if self._index is NULL:             # <<<<<<<<<<<<<<
 *             return Exception('Index object is not initialized')
 *         return Date(
 */
  }

  /* "_redukti.pyx":588
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')
 *         return Date(             # <<<<<<<<<<<<<<
 *             self._index.fixing_calendar().advance(unadjusted.serial(), days, enums.DAYS, self._index.day_convention()))
 * 
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));

  /* "_redukti.pyx":589
 *             return Exception('Index object is not initialized')
 *         return Date(
 *             self._index.fixing_calendar().advance(unadjusted.serial(), days, enums.DAYS, self._index.day_convention()))             # <<<<<<<<<<<<<<
 * 
 * cdef class Interpolator:
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_index->fixing_calendar()->advance(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_unadjusted->__pyx_vtab)->serial(__pyx_v_unadjusted, 0), __pyx_v_days, redukti::DAYS, __pyx_v_self->_index->day_convention())); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 589, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "_redukti.pyx":588
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')
 *         return Date(             # <<<<<<<<<<<<<<
 *             self._index.fixing_calendar().advance(unadjusted.serial(), days, enums.DAYS, self._index.day_convention()))
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)__pyx_ptype_8_redukti_Date), __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = ((struct __pyx_obj_8_redukti_Date *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":585
 *         return Date(fixing), Date(value_dt), Date(maturity_dt)
 * 
 *     cpdef Date adjust_date(self, Date unadjusted, int days):             # <<<<<<<<<<<<<<
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.adjust_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_15adjust_date(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_14adjust_date[] = "InterestRateIndex.adjust_date(self, Date unadjusted, int days) -> Date";
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_15adjust_date(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_unadjusted = 0;
  int __pyx_v_days;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("adjust_date (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_unadjusted,&__pyx_n_s_days,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_unadjusted)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_days)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("adjust_date", 1, 2, 2, 1); __PYX_ERR(0, 585, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "adjust_date") < 0)) __PYX_ERR(0, 585, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_unadjusted = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_days = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_days == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 585, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("adjust_date", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 585, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InterestRateIndex.adjust_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_unadjusted), __pyx_ptype_8_redukti_Date, 1, "unadjusted", 0))) __PYX_ERR(0, 585, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_14adjust_date(((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_v_self), __pyx_v_unadjusted, __pyx_v_days);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_14adjust_date(struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_unadjusted, int __pyx_v_days) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("adjust_date", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_8_redukti_17InterestRateIndex_adjust_date(__pyx_v_self, __pyx_v_unadjusted, __pyx_v_days, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 585, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.adjust_date", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_17__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_16__reduce_cython__[] = "InterestRateIndex.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_17__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_16__reduce_cython__(((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_16__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__37, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_19__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_17InterestRateIndex_18__setstate_cython__[] = "InterestRateIndex.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_17InterestRateIndex_19__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_17InterestRateIndex_18__setstate_cython__(((struct __pyx_obj_8_redukti_InterestRateIndex *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_17InterestRateIndex_18__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterestRateIndex *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__38, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterestRateIndex.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":610
 *     cdef interpolator.Interpolator *_interpolator_ptr
 * 
 *     def __init__(self, enums.InterpolatorType interpolator_type, array.array x, array.array y, int order = 0):             # <<<<<<<<<<<<<<
 *         pass
 * 
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_12Interpolator_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_12Interpolator_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED enum redukti::InterpolatorType __pyx_v_interpolator_type;
  CYTHON_UNUSED arrayobject *__pyx_v_x = 0;
  CYTHON_UNUSED arrayobject *__pyx_v_y = 0;
  CYTHON_UNUSED int __pyx_v_order;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_interpolator_type,&__pyx_n_s_x,&__pyx_n_s_y,&__pyx_n_s_order,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_interpolator_type)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 4, 1); __PYX_ERR(0, 610, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 4, 2); __PYX_ERR(0, 610, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 610, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_interpolator_type = ((enum redukti::InterpolatorType)__Pyx_PyInt_As_enum__redukti_3a__3a_InterpolatorType(values[0])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 610, __pyx_L3_error)
    __pyx_v_x = ((arrayobject *)values[1]);
    __pyx_v_y = ((arrayobject *)values[2]);
    if (values[3]) {
      __pyx_v_order = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 610, __pyx_L3_error)
    } else {
      __pyx_v_order = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 610, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Interpolator.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_x), __pyx_ptype_7cpython_5array_array, 1, "x", 0))) __PYX_ERR(0, 610, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_y), __pyx_ptype_7cpython_5array_array, 1, "y", 0))) __PYX_ERR(0, 610, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_12Interpolator___init__(((struct __pyx_obj_8_redukti_Interpolator *)__pyx_v_self), __pyx_v_interpolator_type, __pyx_v_x, __pyx_v_y, __pyx_v_order);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_12Interpolator___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, CYTHON_UNUSED enum redukti::InterpolatorType __pyx_v_interpolator_type, CYTHON_UNUSED arrayobject *__pyx_v_x, CYTHON_UNUSED arrayobject *__pyx_v_y, CYTHON_UNUSED int __pyx_v_order) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":613
 *         pass
 * 
 *     def __cinit__(self, enums.InterpolatorType interpolator_type, array.array x, array.array y, int order = 0):             # <<<<<<<<<<<<<<
 *         validate_interpolator_type(interpolator_type)
 *         if x.typecode != 'd' or y.typecode != 'd':
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_12Interpolator_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_12Interpolator_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum redukti::InterpolatorType __pyx_v_interpolator_type;
  arrayobject *__pyx_v_x = 0;
  arrayobject *__pyx_v_y = 0;
  int __pyx_v_order;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_interpolator_type,&__pyx_n_s_x,&__pyx_n_s_y,&__pyx_n_s_order,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_interpolator_type)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 4, 1); __PYX_ERR(0, 613, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 4, 2); __PYX_ERR(0, 613, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_order);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 613, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_interpolator_type = ((enum redukti::InterpolatorType)__Pyx_PyInt_As_enum__redukti_3a__3a_InterpolatorType(values[0])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 613, __pyx_L3_error)
    __pyx_v_x = ((arrayobject *)values[1]);
    __pyx_v_y = ((arrayobject *)values[2]);
    if (values[3]) {
      __pyx_v_order = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 613, __pyx_L3_error)
    } else {
      __pyx_v_order = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 613, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Interpolator.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_x), __pyx_ptype_7cpython_5array_array, 1, "x", 0))) __PYX_ERR(0, 613, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_y), __pyx_ptype_7cpython_5array_array, 1, "y", 0))) __PYX_ERR(0, 613, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_12Interpolator_2__cinit__(((struct __pyx_obj_8_redukti_Interpolator *)__pyx_v_self), __pyx_v_interpolator_type, __pyx_v_x, __pyx_v_y, __pyx_v_order);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_12Interpolator_2__cinit__(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, enum redukti::InterpolatorType __pyx_v_interpolator_type, arrayobject *__pyx_v_x, arrayobject *__pyx_v_y, int __pyx_v_order) {
  double *__pyx_v_xdata;
  double *__pyx_v_ydata;
  int __pyx_v_size;
  struct redukti::InterpolationOptions __pyx_v_options;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  Py_ssize_t __pyx_t_4;
  Py_ssize_t __pyx_t_5;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":614
 * 
 *     def __cinit__(self, enums.InterpolatorType interpolator_type, array.array x, array.array y, int order = 0):
 *         validate_interpolator_type(interpolator_type)             # <<<<<<<<<<<<<<
 *         if x.typecode != 'd' or y.typecode != 'd':
 *             raise ValueError('Supplied arrays must be of type double')
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_interpolator_type(__pyx_v_interpolator_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 614, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":615
 *     def __cinit__(self, enums.InterpolatorType interpolator_type, array.array x, array.array y, int order = 0):
 *         validate_interpolator_type(interpolator_type)
 *         if x.typecode != 'd' or y.typecode != 'd':             # <<<<<<<<<<<<<<
 *             raise ValueError('Supplied arrays must be of type double')
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_x), __pyx_n_s_typecode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 615, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_d, Py_NE)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 615, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (!__pyx_t_3) {
  } else {
    __pyx_t_2 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_y), __pyx_n_s_typecode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 615, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_d, Py_NE)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 615, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_2 = __pyx_t_3;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":616
 *         validate_interpolator_type(interpolator_type)
 *         if x.typecode != 'd' or y.typecode != 'd':
 *             raise ValueError('Supplied arrays must be of type double')             # <<<<<<<<<<<<<<
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:
 *             raise ValueError('Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)')
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__39, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 616, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 616, __pyx_L1_error)

    /* "_redukti.pyx":615
 *     def __cinit__(self, enums.InterpolatorType interpolator_type, array.array x, array.array y, int order = 0):
 *         validate_interpolator_type(interpolator_type)
 *         if x.typecode != 'd' or y.typecode != 'd':             # <<<<<<<<<<<<<<
 *             raise ValueError('Supplied arrays must be of type double')
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:
 */
  }

  /* "_redukti.pyx":617
 *         if x.typecode != 'd' or y.typecode != 'd':
 *             raise ValueError('Supplied arrays must be of type double')
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:             # <<<<<<<<<<<<<<
 *             raise ValueError('Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)')
 *         self._x = x
 */
  if (unlikely(((PyObject *)__pyx_v_x) == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 617, __pyx_L1_error)
  }
  __pyx_t_4 = Py_SIZE(((PyObject *)__pyx_v_x)); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 617, __pyx_L1_error)
  if (unlikely(((PyObject *)__pyx_v_y) == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 617, __pyx_L1_error)
  }
  __pyx_t_5 = Py_SIZE(((PyObject *)__pyx_v_y)); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 617, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_4 != __pyx_t_5) != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_2 = __pyx_t_3;
    goto __pyx_L7_bool_binop_done;
  }
  if (unlikely(((PyObject *)__pyx_v_x) == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 617, __pyx_L1_error)
  }
  __pyx_t_5 = Py_SIZE(((PyObject *)__pyx_v_x)); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 617, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_5 < 4) != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_2 = __pyx_t_3;
    goto __pyx_L7_bool_binop_done;
  }
  if (unlikely(((PyObject *)__pyx_v_x) == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 617, __pyx_L1_error)
  }
  __pyx_t_5 = Py_SIZE(((PyObject *)__pyx_v_x)); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 617, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_5 > 50) != 0);
  __pyx_t_2 = __pyx_t_3;
  __pyx_L7_bool_binop_done:;
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":618
 *             raise ValueError('Supplied arrays must be of type double')
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:
 *             raise ValueError('Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)')             # <<<<<<<<<<<<<<
 *         self._x = x
 *         self._y = y
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__40, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 618, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 618, __pyx_L1_error)

    /* "_redukti.pyx":617
 *         if x.typecode != 'd' or y.typecode != 'd':
 *             raise ValueError('Supplied arrays must be of type double')
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:             # <<<<<<<<<<<<<<
 *             raise ValueError('Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)')
 *         self._x = x
 */
  }

  /* "_redukti.pyx":619
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:
 *             raise ValueError('Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)')
 *         self._x = x             # <<<<<<<<<<<<<<
 *         self._y = y
 *         cdef double *xdata = <double *> self._x.data.as_voidptr
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_x));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_x));
  __Pyx_GOTREF(__pyx_v_self->_x);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->_x));
  __pyx_v_self->_x = __pyx_v_x;

  /* "_redukti.pyx":620
 *             raise ValueError('Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)')
 *         self._x = x
 *         self._y = y             # <<<<<<<<<<<<<<
 *         cdef double *xdata = <double *> self._x.data.as_voidptr
 *         cdef double *ydata = <double *> self._y.data.as_voidptr
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_y));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_y));
  __Pyx_GOTREF(__pyx_v_self->_y);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->_y));
  __pyx_v_self->_y = __pyx_v_y;

  /* "_redukti.pyx":621
 *         self._x = x
 *         self._y = y
 *         cdef double *xdata = <double *> self._x.data.as_voidptr             # <<<<<<<<<<<<<<
 *         cdef double *ydata = <double *> self._y.data.as_voidptr
 *         cdef int size = len(x)
 */
  __pyx_v_xdata = ((double *)__pyx_v_self->_x->data.as_voidptr);

  /* "_redukti.pyx":622
 *         self._y = y
 *         cdef double *xdata = <double *> self._x.data.as_voidptr
 *         cdef double *ydata = <double *> self._y.data.as_voidptr             # <<<<<<<<<<<<<<
 *         cdef int size = len(x)
 *         cdef interpolator.InterpolationOptions options;
 */
  __pyx_v_ydata = ((double *)__pyx_v_self->_y->data.as_voidptr);

  /* "_redukti.pyx":623
 *         cdef double *xdata = <double *> self._x.data.as_voidptr
 *         cdef double *ydata = <double *> self._y.data.as_voidptr
 *         cdef int size = len(x)             # <<<<<<<<<<<<<<
 *         cdef interpolator.InterpolationOptions options;
 *         options.differentiation_order = order
 */
  if (unlikely(((PyObject *)__pyx_v_x) == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 623, __pyx_L1_error)
  }
  __pyx_t_5 = Py_SIZE(((PyObject *)__pyx_v_x)); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 623, __pyx_L1_error)
  __pyx_v_size = __pyx_t_5;

  /* "_redukti.pyx":625
 *         cdef int size = len(x)
 *         cdef interpolator.InterpolationOptions options;
 *         options.differentiation_order = order             # <<<<<<<<<<<<<<
 *         self._interpolator = interpolator.make_interpolator(interpolator_type, xdata, ydata, size,
 *                                                             allocator.get_default_allocator(), options)
 */
  __pyx_v_options.differentiation_order = __pyx_v_order;

  /* "_redukti.pyx":626
 *         cdef interpolator.InterpolationOptions options;
 *         options.differentiation_order = order
 *         self._interpolator = interpolator.make_interpolator(interpolator_type, xdata, ydata, size,             # <<<<<<<<<<<<<<
 *                                                             allocator.get_default_allocator(), options)
 *         self._interpolator_ptr = self._interpolator.get()
 */
  __pyx_v_self->_interpolator = redukti::make_interpolator(__pyx_v_interpolator_type, __pyx_v_xdata, __pyx_v_ydata, __pyx_v_size, redukti::get_default_allocator(), __pyx_v_options);

  /* "_redukti.pyx":628
 *         self._interpolator = interpolator.make_interpolator(interpolator_type, xdata, ydata, size,
 *                                                             allocator.get_default_allocator(), options)
 *         self._interpolator_ptr = self._interpolator.get()             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->_interpolator_ptr = __pyx_v_self->_interpolator.get();

  /* "_redukti.pyx":613
 *         pass
 * 
 *     def __cinit__(self, enums.InterpolatorType interpolator_type, array.array x, array.array y, int order = 0):             # <<<<<<<<<<<<<<
 *         validate_interpolator_type(interpolator_type)
 *         if x.typecode != 'd' or y.typecode != 'd':
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Interpolator.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":630
 *         self._interpolator_ptr = self._interpolator.get()
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._interpolator.reset(NULL)
 * 
 */

/* Python wrapper */
static void __pyx_pw_8_redukti_12Interpolator_5__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_8_redukti_12Interpolator_5__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_8_redukti_12Interpolator_4__dealloc__(((struct __pyx_obj_8_redukti_Interpolator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_8_redukti_12Interpolator_4__dealloc__(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "_redukti.pyx":631
 * 
 *     def __dealloc__(self):
 *         self._interpolator.reset(NULL)             # <<<<<<<<<<<<<<
 * 
 *     cpdef double interpolate(self, double x):
 */
  __pyx_v_self->_interpolator.reset(NULL);

  /* "_redukti.pyx":630
 *         self._interpolator_ptr = self._interpolator.get()
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._interpolator.reset(NULL)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "_redukti.pyx":633
 *         self._interpolator.reset(NULL)
 * 
 *     cpdef double interpolate(self, double x):             # <<<<<<<<<<<<<<
 *         return self._interpolator_ptr.interpolate(x)
 * 
 */

static PyObject *__pyx_pw_8_redukti_12Interpolator_7interpolate(PyObject *__pyx_v_self, PyObject *__pyx_arg_x); /*proto*/
static double __pyx_f_8_redukti_12Interpolator_interpolate(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  double __pyx_t_6;
  __Pyx_RefNannySetupContext("interpolate", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_interpolate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 633, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_12Interpolator_7interpolate)) {
        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_x); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 633, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_5)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_5);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
          }
        }
        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 633, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 633, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_6;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":634
 * 
 *     cpdef double interpolate(self, double x):
 *         return self._interpolator_ptr.interpolate(x)             # <<<<<<<<<<<<<<
 * 
 *     cdef ADVar interpolate_with_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):
 */
  __pyx_r = __pyx_v_self->_interpolator_ptr->interpolate(__pyx_v_x);
  goto __pyx_L0;

  /* "_redukti.pyx":633
 *         self._interpolator.reset(NULL)
 * 
 *     cpdef double interpolate(self, double x):             # <<<<<<<<<<<<<<
 *         return self._interpolator_ptr.interpolate(x)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_WriteUnraisable("_redukti.Interpolator.interpolate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_12Interpolator_7interpolate(PyObject *__pyx_v_self, PyObject *__pyx_arg_x); /*proto*/
static char __pyx_doc_8_redukti_12Interpolator_6interpolate[] = "Interpolator.interpolate(self, double x) -> double";
static PyObject *__pyx_pw_8_redukti_12Interpolator_7interpolate(PyObject *__pyx_v_self, PyObject *__pyx_arg_x) {
  double __pyx_v_x;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("interpolate (wrapper)", 0);
  assert(__pyx_arg_x); {
    __pyx_v_x = __pyx_PyFloat_AsDouble(__pyx_arg_x); if (unlikely((__pyx_v_x == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 633, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Interpolator.interpolate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_12Interpolator_6interpolate(((struct __pyx_obj_8_redukti_Interpolator *)__pyx_v_self), ((double)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_12Interpolator_6interpolate(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("interpolate", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_12Interpolator_interpolate(__pyx_v_self, __pyx_v_x, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 633, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Interpolator.interpolate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":636
 *         return self._interpolator_ptr.interpolate(x)
 * 
 *     cdef ADVar interpolate_with_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):             # <<<<<<<<<<<<<<
 *         cdef interpolator.SensitivitiesPointerType sensitivities = self._interpolator_ptr.interpolate_with_sensitivities(
 *             x, fixed_region_allocator)
 */

static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_12Interpolator_interpolate_with_sensitivities_(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x, redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator) {
  redukti::SensitivitiesPointerType __pyx_v_sensitivities;
  redukti_adouble_t *__pyx_v_data;
  struct __pyx_obj_8_redukti_ADVar *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("interpolate_with_sensitivities_", 0);

  /* "_redukti.pyx":637
 * 
 *     cdef ADVar interpolate_with_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):
 *         cdef interpolator.SensitivitiesPointerType sensitivities = self._interpolator_ptr.interpolate_with_sensitivities(             # <<<<<<<<<<<<<<
 *             x, fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 */
  __pyx_v_sensitivities = __pyx_v_self->_interpolator_ptr->interpolate_with_sensitivities(__pyx_v_x, __pyx_v_fixed_region_allocator);

  /* "_redukti.pyx":639
 *         cdef interpolator.SensitivitiesPointerType sensitivities = self._interpolator_ptr.interpolate_with_sensitivities(
 *             x, fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()             # <<<<<<<<<<<<<<
 *         if data is NULL:
 *             return None
 */
  __pyx_v_data = __pyx_v_sensitivities.get();

  /* "_redukti.pyx":640
 *             x, fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return ADVar.dup(sensitivities.get())
 */
  __pyx_t_1 = ((__pyx_v_data == NULL) != 0);
  if (__pyx_t_1) {

    /* "_redukti.pyx":641
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:
 *             return None             # <<<<<<<<<<<<<<
 *         return ADVar.dup(sensitivities.get())
 * 
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)Py_None); __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "_redukti.pyx":640
 *             x, fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return ADVar.dup(sensitivities.get())
 */
  }

  /* "_redukti.pyx":642
 *         if data is NULL:
 *             return None
 *         return ADVar.dup(sensitivities.get())             # <<<<<<<<<<<<<<
 * 
 *     cpdef ADVar interpolate_with_sensitivities(self, double x):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __pyx_t_2 = __pyx_f_8_redukti_5ADVar_dup(__pyx_v_sensitivities.get()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_ADVar))))) __PYX_ERR(0, 642, __pyx_L1_error)
  __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":636
 *         return self._interpolator_ptr.interpolate(x)
 * 
 *     cdef ADVar interpolate_with_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):             # <<<<<<<<<<<<<<
 *         cdef interpolator.SensitivitiesPointerType sensitivities = self._interpolator_ptr.interpolate_with_sensitivities(
 *             x, fixed_region_allocator)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.Interpolator.interpolate_with_sensitivities_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":644
 *         return ADVar.dup(sensitivities.get())
 * 
 *     cpdef ADVar interpolate_with_sensitivities(self, double x):             # <<<<<<<<<<<<<<
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 */

static PyObject *__pyx_pw_8_redukti_12Interpolator_9interpolate_with_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x); /*proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_12Interpolator_interpolate_with_sensitivities(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x, int __pyx_skip_dispatch) {
  redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator;
  size_t __pyx_v_pos;
  struct __pyx_obj_8_redukti_ADVar *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  redukti::FixedRegionAllocator *__pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  char const *__pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  struct __pyx_obj_8_redukti_ADVar *__pyx_t_16 = NULL;
  __Pyx_RefNannySetupContext("interpolate_with_sensitivities", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_interpolate_with_sensitivities); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 644, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_12Interpolator_9interpolate_with_sensitivities)) {
        __Pyx_XDECREF(((PyObject *)__pyx_r));
        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_x); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 644, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_5)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_5);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
          }
        }
        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 644, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_ADVar))))) __PYX_ERR(0, 644, __pyx_L1_error)
        __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":645
 * 
 *     cpdef ADVar interpolate_with_sensitivities(self, double x):
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator             # <<<<<<<<<<<<<<
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:
 */
  __pyx_t_6 = redukti::get_threadspecific_allocators()->tempspace_allocator;
  __pyx_v_fixed_region_allocator = __pyx_t_6;

  /* "_redukti.pyx":646
 *     cpdef ADVar interpolate_with_sensitivities(self, double x):
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython             # <<<<<<<<<<<<<<
 *         try:
 *             return self.interpolate_with_sensitivities_(x, fixed_region_allocator)
 */
  __pyx_v_pos = __pyx_v_fixed_region_allocator->pos();

  /* "_redukti.pyx":647
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:             # <<<<<<<<<<<<<<
 *             return self.interpolate_with_sensitivities_(x, fixed_region_allocator)
 *         finally:
 */
  /*try:*/ {

    /* "_redukti.pyx":648
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:
 *             return self.interpolate_with_sensitivities_(x, fixed_region_allocator)             # <<<<<<<<<<<<<<
 *         finally:
 *             fixed_region_allocator.pos(pos)
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_8_redukti_Interpolator *)__pyx_v_self->__pyx_vtab)->interpolate_with_sensitivities_(__pyx_v_self, __pyx_v_x, __pyx_v_fixed_region_allocator)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 648, __pyx_L4_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_1);
    __pyx_t_1 = 0;
    goto __pyx_L3_return;
  }

  /* "_redukti.pyx":650
 *             return self.interpolate_with_sensitivities_(x, fixed_region_allocator)
 *         finally:
 *             fixed_region_allocator.pos(pos)             # <<<<<<<<<<<<<<
 * 
 * cdef class CurveId:
 */
  /*finally:*/ {
    __pyx_L4_error:;
    /*exception exit:*/{
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12) < 0)) __Pyx_ErrFetch(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_14);
      __Pyx_XGOTREF(__pyx_t_15);
      __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
      {
        __pyx_v_fixed_region_allocator->pos(__pyx_v_pos);
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_13);
        __Pyx_XGIVEREF(__pyx_t_14);
        __Pyx_XGIVEREF(__pyx_t_15);
        __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
      }
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ErrRestore(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_9;
      goto __pyx_L1_error;
    }
    __pyx_L3_return: {
      __pyx_t_16 = __pyx_r;
      __pyx_r = 0;
      __pyx_v_fixed_region_allocator->pos(__pyx_v_pos);
      __pyx_r = __pyx_t_16;
      __pyx_t_16 = 0;
      goto __pyx_L0;
    }
  }

  /* "_redukti.pyx":644
 *         return ADVar.dup(sensitivities.get())
 * 
 *     cpdef ADVar interpolate_with_sensitivities(self, double x):             # <<<<<<<<<<<<<<
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_redukti.Interpolator.interpolate_with_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_12Interpolator_9interpolate_with_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x); /*proto*/
static char __pyx_doc_8_redukti_12Interpolator_8interpolate_with_sensitivities[] = "Interpolator.interpolate_with_sensitivities(self, double x) -> ADVar";
static PyObject *__pyx_pw_8_redukti_12Interpolator_9interpolate_with_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x) {
  double __pyx_v_x;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("interpolate_with_sensitivities (wrapper)", 0);
  assert(__pyx_arg_x); {
    __pyx_v_x = __pyx_PyFloat_AsDouble(__pyx_arg_x); if (unlikely((__pyx_v_x == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 644, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.Interpolator.interpolate_with_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_12Interpolator_8interpolate_with_sensitivities(((struct __pyx_obj_8_redukti_Interpolator *)__pyx_v_self), ((double)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_12Interpolator_8interpolate_with_sensitivities(struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, double __pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("interpolate_with_sensitivities", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_8_redukti_12Interpolator_interpolate_with_sensitivities(__pyx_v_self, __pyx_v_x, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 644, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Interpolator.interpolate_with_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_12Interpolator_11__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_12Interpolator_10__reduce_cython__[] = "Interpolator.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_12Interpolator_11__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_12Interpolator_10__reduce_cython__(((struct __pyx_obj_8_redukti_Interpolator *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_12Interpolator_10__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__41, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Interpolator.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_12Interpolator_13__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_12Interpolator_12__setstate_cython__[] = "Interpolator.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_12Interpolator_13__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_12Interpolator_12__setstate_cython__(((struct __pyx_obj_8_redukti_Interpolator *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_12Interpolator_12__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_Interpolator *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__42, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.Interpolator.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":655
 *     cdef long long _id
 * 
 *     def __cinit__(self, enums.PricingCurveType pricing_curve_type, enums.Currency ccy, enums.IndexFamily index_family,             # <<<<<<<<<<<<<<
 *                   enums.Tenor tenor,
 *                   Date as_of_date, int cycle = 0, enums.MarketDataQualifier qual = enums.MDQ_NORMAL, int scenario = 0):
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_7CurveId_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_7CurveId_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  enum redukti::PricingCurveType __pyx_v_pricing_curve_type;
  enum redukti::Currency __pyx_v_ccy;
  enum redukti::IndexFamily __pyx_v_index_family;
  enum redukti::Tenor __pyx_v_tenor;
  struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date = 0;
  int __pyx_v_cycle;
  enum redukti::MarketDataQualifier __pyx_v_qual;
  int __pyx_v_scenario;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pricing_curve_type,&__pyx_n_s_ccy,&__pyx_n_s_index_family,&__pyx_n_s_tenor,&__pyx_n_s_as_of_date,&__pyx_n_s_cycle,&__pyx_n_s_qual,&__pyx_n_s_scenario,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pricing_curve_type)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ccy)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 5, 8, 1); __PYX_ERR(0, 655, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_index_family)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 5, 8, 2); __PYX_ERR(0, 655, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_tenor)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 5, 8, 3); __PYX_ERR(0, 655, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_as_of_date)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 5, 8, 4); __PYX_ERR(0, 655, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cycle);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_qual);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_scenario);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 655, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_pricing_curve_type = ((enum redukti::PricingCurveType)__Pyx_PyInt_As_enum__redukti_3a__3a_PricingCurveType(values[0])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 655, __pyx_L3_error)
    __pyx_v_ccy = ((enum redukti::Currency)__Pyx_PyInt_As_enum__redukti_3a__3a_Currency(values[1])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 655, __pyx_L3_error)
    __pyx_v_index_family = ((enum redukti::IndexFamily)__Pyx_PyInt_As_enum__redukti_3a__3a_IndexFamily(values[2])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 655, __pyx_L3_error)
    __pyx_v_tenor = ((enum redukti::Tenor)__Pyx_PyInt_As_enum__redukti_3a__3a_Tenor(values[3])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 656, __pyx_L3_error)
    __pyx_v_as_of_date = ((struct __pyx_obj_8_redukti_Date *)values[4]);
    if (values[5]) {
      __pyx_v_cycle = __Pyx_PyInt_As_int(values[5]); if (unlikely((__pyx_v_cycle == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 657, __pyx_L3_error)
    } else {
      __pyx_v_cycle = ((int)0);
    }
    if (values[6]) {
      __pyx_v_qual = ((enum redukti::MarketDataQualifier)__Pyx_PyInt_As_enum__redukti_3a__3a_MarketDataQualifier(values[6])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 657, __pyx_L3_error)
    } else {
      __pyx_v_qual = __pyx_k__43;
    }
    if (values[7]) {
      __pyx_v_scenario = __Pyx_PyInt_As_int(values[7]); if (unlikely((__pyx_v_scenario == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 657, __pyx_L3_error)
    } else {
      __pyx_v_scenario = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 5, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 655, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.CurveId.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_as_of_date), __pyx_ptype_8_redukti_Date, 1, "as_of_date", 0))) __PYX_ERR(0, 657, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_7CurveId___cinit__(((struct __pyx_obj_8_redukti_CurveId *)__pyx_v_self), __pyx_v_pricing_curve_type, __pyx_v_ccy, __pyx_v_index_family, __pyx_v_tenor, __pyx_v_as_of_date, __pyx_v_cycle, __pyx_v_qual, __pyx_v_scenario);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_7CurveId___cinit__(struct __pyx_obj_8_redukti_CurveId *__pyx_v_self, enum redukti::PricingCurveType __pyx_v_pricing_curve_type, enum redukti::Currency __pyx_v_ccy, enum redukti::IndexFamily __pyx_v_index_family, enum redukti::Tenor __pyx_v_tenor, struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, int __pyx_v_cycle, enum redukti::MarketDataQualifier __pyx_v_qual, int __pyx_v_scenario) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":658
 *                   enums.Tenor tenor,
 *                   Date as_of_date, int cycle = 0, enums.MarketDataQualifier qual = enums.MDQ_NORMAL, int scenario = 0):
 *         self._id = curve.make_curve_id(pricing_curve_type, ccy, index_family, tenor, as_of_date.serial(),             # <<<<<<<<<<<<<<
 *                                        cycle, qual, scenario)
 * 
 */
  __pyx_v_self->_id = redukti::make_curve_id(__pyx_v_pricing_curve_type, __pyx_v_ccy, __pyx_v_index_family, __pyx_v_tenor, ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_as_of_date->__pyx_vtab)->serial(__pyx_v_as_of_date, 0), __pyx_v_cycle, __pyx_v_qual, __pyx_v_scenario);

  /* "_redukti.pyx":655
 *     cdef long long _id
 * 
 *     def __cinit__(self, enums.PricingCurveType pricing_curve_type, enums.Currency ccy, enums.IndexFamily index_family,             # <<<<<<<<<<<<<<
 *                   enums.Tenor tenor,
 *                   Date as_of_date, int cycle = 0, enums.MarketDataQualifier qual = enums.MDQ_NORMAL, int scenario = 0):
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":661
 *                                        cycle, qual, scenario)
 * 
 *     cpdef long long id(self):             # <<<<<<<<<<<<<<
 *         return self._id
 * 
 */

static PyObject *__pyx_pw_8_redukti_7CurveId_3id(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PY_LONG_LONG __pyx_f_8_redukti_7CurveId_id(struct __pyx_obj_8_redukti_CurveId *__pyx_v_self, int __pyx_skip_dispatch) {
  PY_LONG_LONG __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PY_LONG_LONG __pyx_t_5;
  __Pyx_RefNannySetupContext("id", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 661, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_7CurveId_3id)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 661, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_2); if (unlikely((__pyx_t_5 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 661, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":662
 * 
 *     cpdef long long id(self):
 *         return self._id             # <<<<<<<<<<<<<<
 * 
 * cdef class InterpolatedYieldCurve:
 */
  __pyx_r = __pyx_v_self->_id;
  goto __pyx_L0;

  /* "_redukti.pyx":661
 *                                        cycle, qual, scenario)
 * 
 *     cpdef long long id(self):             # <<<<<<<<<<<<<<
 *         return self._id
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.CurveId.id", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_7CurveId_3id(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_7CurveId_2id[] = "CurveId.id(self) -> long long";
static PyObject *__pyx_pw_8_redukti_7CurveId_3id(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("id (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_7CurveId_2id(((struct __pyx_obj_8_redukti_CurveId *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_7CurveId_2id(struct __pyx_obj_8_redukti_CurveId *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("id", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_f_8_redukti_7CurveId_id(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 661, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.CurveId.id", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_7CurveId_5__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_7CurveId_4__reduce_cython__[] = "CurveId.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_7CurveId_5__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_7CurveId_4__reduce_cython__(((struct __pyx_obj_8_redukti_CurveId *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_7CurveId_4__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_CurveId *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__44, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.CurveId.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_7CurveId_7__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_7CurveId_6__setstate_cython__[] = "CurveId.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_7CurveId_7__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_7CurveId_6__setstate_cython__(((struct __pyx_obj_8_redukti_CurveId *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_7CurveId_6__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_CurveId *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__45, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.CurveId.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":676
 *     cdef curve.YieldCurve *_yield_curve_ptr
 * 
 *     def __init__(self, long long id, Date as_of_date, list maturities, list values,             # <<<<<<<<<<<<<<
 *                   enums.InterpolatorType interpolator_type, enums.IRRateType rate_type, int deriv_order,
 *                   enums.DayCountFraction fraction):
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_22InterpolatedYieldCurve_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_22InterpolatedYieldCurve_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PY_LONG_LONG __pyx_v_id;
  CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date = 0;
  CYTHON_UNUSED PyObject *__pyx_v_maturities = 0;
  CYTHON_UNUSED PyObject *__pyx_v_values = 0;
  CYTHON_UNUSED enum redukti::InterpolatorType __pyx_v_interpolator_type;
  CYTHON_UNUSED enum redukti::IRRateType __pyx_v_rate_type;
  CYTHON_UNUSED int __pyx_v_deriv_order;
  CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_fraction;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_as_of_date,&__pyx_n_s_maturities,&__pyx_n_s_values,&__pyx_n_s_interpolator_type,&__pyx_n_s_rate_type,&__pyx_n_s_deriv_order,&__pyx_n_s_fraction,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_as_of_date)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 1); __PYX_ERR(0, 676, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_maturities)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 2); __PYX_ERR(0, 676, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 3); __PYX_ERR(0, 676, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_interpolator_type)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 4); __PYX_ERR(0, 676, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate_type)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 5); __PYX_ERR(0, 676, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (likely((values[6] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_deriv_order)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 6); __PYX_ERR(0, 676, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (likely((values[7] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fraction)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 7); __PYX_ERR(0, 676, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 676, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 8) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
      values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
      values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
      values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
    }
    __pyx_v_id = __Pyx_PyInt_As_PY_LONG_LONG(values[0]); if (unlikely((__pyx_v_id == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 676, __pyx_L3_error)
    __pyx_v_as_of_date = ((struct __pyx_obj_8_redukti_Date *)values[1]);
    __pyx_v_maturities = ((PyObject*)values[2]);
    __pyx_v_values = ((PyObject*)values[3]);
    __pyx_v_interpolator_type = ((enum redukti::InterpolatorType)__Pyx_PyInt_As_enum__redukti_3a__3a_InterpolatorType(values[4])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 677, __pyx_L3_error)
    __pyx_v_rate_type = ((enum redukti::IRRateType)__Pyx_PyInt_As_enum__redukti_3a__3a_IRRateType(values[5])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 677, __pyx_L3_error)
    __pyx_v_deriv_order = __Pyx_PyInt_As_int(values[6]); if (unlikely((__pyx_v_deriv_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 677, __pyx_L3_error)
    __pyx_v_fraction = ((enum redukti::DayCountFraction)__Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(values[7])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 678, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 676, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_as_of_date), __pyx_ptype_8_redukti_Date, 1, "as_of_date", 0))) __PYX_ERR(0, 676, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_maturities), (&PyList_Type), 1, "maturities", 1))) __PYX_ERR(0, 676, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_values), (&PyList_Type), 1, "values", 1))) __PYX_ERR(0, 676, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve___init__(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self), __pyx_v_id, __pyx_v_as_of_date, __pyx_v_maturities, __pyx_v_values, __pyx_v_interpolator_type, __pyx_v_rate_type, __pyx_v_deriv_order, __pyx_v_fraction);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_22InterpolatedYieldCurve___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, CYTHON_UNUSED PY_LONG_LONG __pyx_v_id, CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, CYTHON_UNUSED PyObject *__pyx_v_maturities, CYTHON_UNUSED PyObject *__pyx_v_values, CYTHON_UNUSED enum redukti::InterpolatorType __pyx_v_interpolator_type, CYTHON_UNUSED enum redukti::IRRateType __pyx_v_rate_type, CYTHON_UNUSED int __pyx_v_deriv_order, CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_fraction) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":681
 *         pass
 * 
 *     def __cinit__(self, long long id, Date as_of_date, list maturities, list values,             # <<<<<<<<<<<<<<
 *                   enums.InterpolatorType interpolator_type, enums.IRRateType rate_type, int deriv_order,
 *                   enums.DayCountFraction fraction):
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_22InterpolatedYieldCurve_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_22InterpolatedYieldCurve_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PY_LONG_LONG __pyx_v_id;
  struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date = 0;
  PyObject *__pyx_v_maturities = 0;
  PyObject *__pyx_v_values = 0;
  enum redukti::InterpolatorType __pyx_v_interpolator_type;
  enum redukti::IRRateType __pyx_v_rate_type;
  int __pyx_v_deriv_order;
  enum redukti::DayCountFraction __pyx_v_fraction;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_as_of_date,&__pyx_n_s_maturities,&__pyx_n_s_values,&__pyx_n_s_interpolator_type,&__pyx_n_s_rate_type,&__pyx_n_s_deriv_order,&__pyx_n_s_fraction,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_as_of_date)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 8, 8, 1); __PYX_ERR(0, 681, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_maturities)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 8, 8, 2); __PYX_ERR(0, 681, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_values)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 8, 8, 3); __PYX_ERR(0, 681, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_interpolator_type)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 8, 8, 4); __PYX_ERR(0, 681, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rate_type)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 8, 8, 5); __PYX_ERR(0, 681, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (likely((values[6] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_deriv_order)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 8, 8, 6); __PYX_ERR(0, 681, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (likely((values[7] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fraction)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 8, 8, 7); __PYX_ERR(0, 681, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 681, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 8) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
      values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
      values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
      values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
    }
    __pyx_v_id = __Pyx_PyInt_As_PY_LONG_LONG(values[0]); if (unlikely((__pyx_v_id == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 681, __pyx_L3_error)
    __pyx_v_as_of_date = ((struct __pyx_obj_8_redukti_Date *)values[1]);
    __pyx_v_maturities = ((PyObject*)values[2]);
    __pyx_v_values = ((PyObject*)values[3]);
    __pyx_v_interpolator_type = ((enum redukti::InterpolatorType)__Pyx_PyInt_As_enum__redukti_3a__3a_InterpolatorType(values[4])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 682, __pyx_L3_error)
    __pyx_v_rate_type = ((enum redukti::IRRateType)__Pyx_PyInt_As_enum__redukti_3a__3a_IRRateType(values[5])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 682, __pyx_L3_error)
    __pyx_v_deriv_order = __Pyx_PyInt_As_int(values[6]); if (unlikely((__pyx_v_deriv_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 682, __pyx_L3_error)
    __pyx_v_fraction = ((enum redukti::DayCountFraction)__Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(values[7])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 683, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 8, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 681, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_as_of_date), __pyx_ptype_8_redukti_Date, 1, "as_of_date", 0))) __PYX_ERR(0, 681, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_maturities), (&PyList_Type), 1, "maturities", 1))) __PYX_ERR(0, 681, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_values), (&PyList_Type), 1, "values", 1))) __PYX_ERR(0, 681, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve_2__cinit__(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self), __pyx_v_id, __pyx_v_as_of_date, __pyx_v_maturities, __pyx_v_values, __pyx_v_interpolator_type, __pyx_v_rate_type, __pyx_v_deriv_order, __pyx_v_fraction);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_22InterpolatedYieldCurve_2__cinit__(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, PY_LONG_LONG __pyx_v_id, struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, PyObject *__pyx_v_maturities, PyObject *__pyx_v_values, enum redukti::InterpolatorType __pyx_v_interpolator_type, enum redukti::IRRateType __pyx_v_rate_type, int __pyx_v_deriv_order, enum redukti::DayCountFraction __pyx_v_fraction) {
  int *__pyx_v_xdata;
  double *__pyx_v_ydata;
  int __pyx_v_size;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  Py_ssize_t __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":684
 *                   enums.InterpolatorType interpolator_type, enums.IRRateType rate_type, int deriv_order,
 *                   enums.DayCountFraction fraction):
 *         validate_interpolator_type(interpolator_type)             # <<<<<<<<<<<<<<
 *         if len(maturities) != len(values) or len(maturities) < 4 or len(maturities) > 50:
 *             raise ValueError(
 */
  __pyx_t_1 = __pyx_f_8_redukti_validate_interpolator_type(__pyx_v_interpolator_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 684, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":685
 *                   enums.DayCountFraction fraction):
 *         validate_interpolator_type(interpolator_type)
 *         if len(maturities) != len(values) or len(maturities) < 4 or len(maturities) > 50:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 'Invalid size of maturities or values: minimum 4 elements required and len(maturies) must be == len(values)')
 */
  if (unlikely(__pyx_v_maturities == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 685, __pyx_L1_error)
  }
  __pyx_t_3 = PyList_GET_SIZE(__pyx_v_maturities); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 685, __pyx_L1_error)
  if (unlikely(__pyx_v_values == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 685, __pyx_L1_error)
  }
  __pyx_t_4 = PyList_GET_SIZE(__pyx_v_values); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 685, __pyx_L1_error)
  __pyx_t_5 = ((__pyx_t_3 != __pyx_t_4) != 0);
  if (!__pyx_t_5) {
  } else {
    __pyx_t_2 = __pyx_t_5;
    goto __pyx_L4_bool_binop_done;
  }
  if (unlikely(__pyx_v_maturities == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 685, __pyx_L1_error)
  }
  __pyx_t_4 = PyList_GET_SIZE(__pyx_v_maturities); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 685, __pyx_L1_error)
  __pyx_t_5 = ((__pyx_t_4 < 4) != 0);
  if (!__pyx_t_5) {
  } else {
    __pyx_t_2 = __pyx_t_5;
    goto __pyx_L4_bool_binop_done;
  }
  if (unlikely(__pyx_v_maturities == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 685, __pyx_L1_error)
  }
  __pyx_t_4 = PyList_GET_SIZE(__pyx_v_maturities); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 685, __pyx_L1_error)
  __pyx_t_5 = ((__pyx_t_4 > 50) != 0);
  __pyx_t_2 = __pyx_t_5;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":686
 *         validate_interpolator_type(interpolator_type)
 *         if len(maturities) != len(values) or len(maturities) < 4 or len(maturities) > 50:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 'Invalid size of maturities or values: minimum 4 elements required and len(maturies) must be == len(values)')
 *         self._maturities = convert_to_date_array(maturities)
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__46, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 686, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 686, __pyx_L1_error)

    /* "_redukti.pyx":685
 *                   enums.DayCountFraction fraction):
 *         validate_interpolator_type(interpolator_type)
 *         if len(maturities) != len(values) or len(maturities) < 4 or len(maturities) > 50:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 'Invalid size of maturities or values: minimum 4 elements required and len(maturies) must be == len(values)')
 */
  }

  /* "_redukti.pyx":688
 *             raise ValueError(
 *                 'Invalid size of maturities or values: minimum 4 elements required and len(maturies) must be == len(values)')
 *         self._maturities = convert_to_date_array(maturities)             # <<<<<<<<<<<<<<
 *         self._values = array.array('d', values)
 *         cdef int *xdata = <int *> self._maturities.data.as_voidptr
 */
  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_convert_to_date_array); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 688, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  __pyx_t_1 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_v_maturities) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_maturities);
  __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 688, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_7cpython_5array_array))))) __PYX_ERR(0, 688, __pyx_L1_error)
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->_maturities);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->_maturities));
  __pyx_v_self->_maturities = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":689
 *                 'Invalid size of maturities or values: minimum 4 elements required and len(maturies) must be == len(values)')
 *         self._maturities = convert_to_date_array(maturities)
 *         self._values = array.array('d', values)             # <<<<<<<<<<<<<<
 *         cdef int *xdata = <int *> self._maturities.data.as_voidptr
 *         cdef double *ydata = <double *> self._values.data.as_voidptr
 */
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 689, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_u_d);
  __Pyx_GIVEREF(__pyx_n_u_d);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_n_u_d);
  __Pyx_INCREF(__pyx_v_values);
  __Pyx_GIVEREF(__pyx_v_values);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_values);
  __pyx_t_6 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_7cpython_5array_array), __pyx_t_1, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 689, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_GIVEREF(__pyx_t_6);
  __Pyx_GOTREF(__pyx_v_self->_values);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->_values));
  __pyx_v_self->_values = ((arrayobject *)__pyx_t_6);
  __pyx_t_6 = 0;

  /* "_redukti.pyx":690
 *         self._maturities = convert_to_date_array(maturities)
 *         self._values = array.array('d', values)
 *         cdef int *xdata = <int *> self._maturities.data.as_voidptr             # <<<<<<<<<<<<<<
 *         cdef double *ydata = <double *> self._values.data.as_voidptr
 *         cdef int size = len(maturities)
 */
  __pyx_v_xdata = ((int *)__pyx_v_self->_maturities->data.as_voidptr);

  /* "_redukti.pyx":691
 *         self._values = array.array('d', values)
 *         cdef int *xdata = <int *> self._maturities.data.as_voidptr
 *         cdef double *ydata = <double *> self._values.data.as_voidptr             # <<<<<<<<<<<<<<
 *         cdef int size = len(maturities)
 *         self._yield_curve = curve.make_curve(allocator.get_default_allocator(), id, as_of_date.serial(), xdata, ydata,
 */
  __pyx_v_ydata = ((double *)__pyx_v_self->_values->data.as_voidptr);

  /* "_redukti.pyx":692
 *         cdef int *xdata = <int *> self._maturities.data.as_voidptr
 *         cdef double *ydata = <double *> self._values.data.as_voidptr
 *         cdef int size = len(maturities)             # <<<<<<<<<<<<<<
 *         self._yield_curve = curve.make_curve(allocator.get_default_allocator(), id, as_of_date.serial(), xdata, ydata,
 *                                              size, interpolator_type, rate_type, deriv_order, fraction)
 */
  if (unlikely(__pyx_v_maturities == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 692, __pyx_L1_error)
  }
  __pyx_t_4 = PyList_GET_SIZE(__pyx_v_maturities); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 692, __pyx_L1_error)
  __pyx_v_size = __pyx_t_4;

  /* "_redukti.pyx":693
 *         cdef double *ydata = <double *> self._values.data.as_voidptr
 *         cdef int size = len(maturities)
 *         self._yield_curve = curve.make_curve(allocator.get_default_allocator(), id, as_of_date.serial(), xdata, ydata,             # <<<<<<<<<<<<<<
 *                                              size, interpolator_type, rate_type, deriv_order, fraction)
 *         self._yield_curve_ptr = self._yield_curve.get()
 */
  __pyx_v_self->_yield_curve = redukti::make_curve(redukti::get_default_allocator(), __pyx_v_id, ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_as_of_date->__pyx_vtab)->serial(__pyx_v_as_of_date, 0), __pyx_v_xdata, __pyx_v_ydata, __pyx_v_size, __pyx_v_interpolator_type, __pyx_v_rate_type, __pyx_v_deriv_order, __pyx_v_fraction);

  /* "_redukti.pyx":695
 *         self._yield_curve = curve.make_curve(allocator.get_default_allocator(), id, as_of_date.serial(), xdata, ydata,
 *                                              size, interpolator_type, rate_type, deriv_order, fraction)
 *         self._yield_curve_ptr = self._yield_curve.get()             # <<<<<<<<<<<<<<
 *         if self._yield_curve_ptr is NULL:
 *             raise Exception('Failed to create instance of InterpolatedYieldCurve: please check inputs are correct')
 */
  __pyx_v_self->_yield_curve_ptr = __pyx_v_self->_yield_curve.get();

  /* "_redukti.pyx":696
 *                                              size, interpolator_type, rate_type, deriv_order, fraction)
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to create instance of InterpolatedYieldCurve: please check inputs are correct')
 * 
 */
  __pyx_t_2 = ((__pyx_v_self->_yield_curve_ptr == NULL) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":697
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:
 *             raise Exception('Failed to create instance of InterpolatedYieldCurve: please check inputs are correct')             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
    __pyx_t_6 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__47, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 697, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_Raise(__pyx_t_6, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __PYX_ERR(0, 697, __pyx_L1_error)

    /* "_redukti.pyx":696
 *                                              size, interpolator_type, rate_type, deriv_order, fraction)
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to create instance of InterpolatedYieldCurve: please check inputs are correct')
 * 
 */
  }

  /* "_redukti.pyx":681
 *         pass
 * 
 *     def __cinit__(self, long long id, Date as_of_date, list maturities, list values,             # <<<<<<<<<<<<<<
 *                   enums.InterpolatorType interpolator_type, enums.IRRateType rate_type, int deriv_order,
 *                   enums.DayCountFraction fraction):
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":699
 *             raise Exception('Failed to create instance of InterpolatedYieldCurve: please check inputs are correct')
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._yield_curve.reset(NULL)
 * 
 */

/* Python wrapper */
static void __pyx_pw_8_redukti_22InterpolatedYieldCurve_5__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_8_redukti_22InterpolatedYieldCurve_5__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_8_redukti_22InterpolatedYieldCurve_4__dealloc__(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_8_redukti_22InterpolatedYieldCurve_4__dealloc__(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "_redukti.pyx":700
 * 
 *     def __dealloc__(self):
 *         self._yield_curve.reset(NULL)             # <<<<<<<<<<<<<<
 * 
 *     cpdef double discount(self, Date d):
 */
  __pyx_v_self->_yield_curve.reset(NULL);

  /* "_redukti.pyx":699
 *             raise Exception('Failed to create instance of InterpolatedYieldCurve: please check inputs are correct')
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._yield_curve.reset(NULL)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "_redukti.pyx":702
 *         self._yield_curve.reset(NULL)
 * 
 *     cpdef double discount(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the discount factor for the given date
 */

static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_22InterpolatedYieldCurve_discount(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("discount", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_discount); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 702, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_22InterpolatedYieldCurve_7discount)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 702, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 702, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":713
 *         """
 * 
 *         return self._yield_curve_ptr.discount(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double zero_rate(self, Date d):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->discount(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":702
 *         self._yield_curve.reset(NULL)
 * 
 *     cpdef double discount(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the discount factor for the given date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.InterpolatedYieldCurve.discount", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_22InterpolatedYieldCurve_6discount[] = "InterpolatedYieldCurve.discount(self, Date d) -> double\n\n        Computes the discount factor for the given date\n\n        Args:\n            d: Date for which discount factor is desired\n\n        Returns:\n            Desired discount factor\n        ";
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("discount (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 702, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve_6discount(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_6discount(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("discount", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_22InterpolatedYieldCurve_discount(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 702, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.discount", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":715
 *         return self._yield_curve_ptr.discount(d.serial())
 * 
 *     cpdef double zero_rate(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the continuously compounded zero rate for a given date
 */

static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_22InterpolatedYieldCurve_zero_rate(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("zero_rate", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_zero_rate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 715, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_22InterpolatedYieldCurve_9zero_rate)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 715, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 715, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":726
 *         """
 * 
 *         return self._yield_curve_ptr.zero_rate(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->zero_rate(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":715
 *         return self._yield_curve_ptr.discount(d.serial())
 * 
 *     cpdef double zero_rate(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the continuously compounded zero rate for a given date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.InterpolatedYieldCurve.zero_rate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_22InterpolatedYieldCurve_8zero_rate[] = "InterpolatedYieldCurve.zero_rate(self, Date d) -> double\n\n        Computes the continuously compounded zero rate for a given date\n\n        Args:\n            d: Date for which the zero rate is desired\n\n        Returns:\n            Continuously compounded zero rate at the given date\n        ";
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("zero_rate (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 715, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve_8zero_rate(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_8zero_rate(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("zero_rate", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_22InterpolatedYieldCurve_zero_rate(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 715, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.zero_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":728
 *         return self._yield_curve_ptr.zero_rate(d.serial())
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the forward rate between two dates
 */

static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static double __pyx_f_8_redukti_22InterpolatedYieldCurve_forward_rate(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  double __pyx_t_7;
  __Pyx_RefNannySetupContext("forward_rate", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_forward_rate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 728, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_22InterpolatedYieldCurve_11forward_rate)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        __pyx_t_5 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
            __pyx_t_5 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2)};
          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 728, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2)};
          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 728, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        {
          __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 728, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_6);
          if (__pyx_t_4) {
            __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
          }
          __Pyx_INCREF(((PyObject *)__pyx_v_d1));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d1));
          PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, ((PyObject *)__pyx_v_d1));
          __Pyx_INCREF(((PyObject *)__pyx_v_d2));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d2));
          PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, ((PyObject *)__pyx_v_d2));
          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 728, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 728, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_7;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":739
 *             Forward rate for the specified dates
 *         """
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double time_from_reference(self, Date d):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->forward_rate(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d1->__pyx_vtab)->serial(__pyx_v_d1, 0), ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d2->__pyx_vtab)->serial(__pyx_v_d2, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":728
 *         return self._yield_curve_ptr.zero_rate(d.serial())
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the forward rate between two dates
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_WriteUnraisable("_redukti.InterpolatedYieldCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_22InterpolatedYieldCurve_10forward_rate[] = "InterpolatedYieldCurve.forward_rate(self, Date d1, Date d2) -> double\n\n        Computes the forward rate between two dates\n\n        Args:\n            d1: Start date\n            d2: End date\n\n        Returns:\n            Forward rate for the specified dates\n        ";
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_d1 = 0;
  struct __pyx_obj_8_redukti_Date *__pyx_v_d2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("forward_rate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_d1,&__pyx_n_s_d2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("forward_rate", 1, 2, 2, 1); __PYX_ERR(0, 728, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "forward_rate") < 0)) __PYX_ERR(0, 728, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_d1 = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_d2 = ((struct __pyx_obj_8_redukti_Date *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("forward_rate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 728, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d1), __pyx_ptype_8_redukti_Date, 1, "d1", 0))) __PYX_ERR(0, 728, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d2), __pyx_ptype_8_redukti_Date, 1, "d2", 0))) __PYX_ERR(0, 728, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve_10forward_rate(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self), __pyx_v_d1, __pyx_v_d2);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_10forward_rate(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("forward_rate", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_22InterpolatedYieldCurve_forward_rate(__pyx_v_self, __pyx_v_d1, __pyx_v_d2, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 728, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":741
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())
 * 
 *     cpdef double time_from_reference(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Gets time from the curve's reference date to the given date expressed as a year fraction
 */

static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_22InterpolatedYieldCurve_time_from_reference(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("time_from_reference", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_time_from_reference); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_22InterpolatedYieldCurve_13time_from_reference)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 741, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 741, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":751
 *             A double value expressing the time from curve's reference date
 *         """
 *         return self._yield_curve_ptr.time_from_reference(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     cdef ADVar get_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->time_from_reference(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":741
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())
 * 
 *     cpdef double time_from_reference(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Gets time from the curve's reference date to the given date expressed as a year fraction
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.InterpolatedYieldCurve.time_from_reference", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_22InterpolatedYieldCurve_12time_from_reference[] = "InterpolatedYieldCurve.time_from_reference(self, Date d) -> double\n\n        Gets time from the curve's reference date to the given date expressed as a year fraction\n\n        Args:\n            d: date to be converted\n\n        Returns:\n            A double value expressing the time from curve's reference date\n        ";
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("time_from_reference (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 741, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve_12time_from_reference(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_12time_from_reference(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("time_from_reference", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_22InterpolatedYieldCurve_time_from_reference(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 741, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.time_from_reference", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":753
 *         return self._yield_curve_ptr.time_from_reference(d.serial())
 * 
 *     cdef ADVar get_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):             # <<<<<<<<<<<<<<
 *         cdef curve.CurveSensitivitiesPointerType sensitivities = self._yield_curve_ptr.get_sensitivities(x,
 *                                                                                                          fixed_region_allocator)
 */

static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_22InterpolatedYieldCurve_get_sensitivities_(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, double __pyx_v_x, redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator) {
  redukti::CurveSensitivitiesPointerType __pyx_v_sensitivities;
  redukti_adouble_t *__pyx_v_data;
  struct __pyx_obj_8_redukti_ADVar *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("get_sensitivities_", 0);

  /* "_redukti.pyx":754
 * 
 *     cdef ADVar get_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):
 *         cdef curve.CurveSensitivitiesPointerType sensitivities = self._yield_curve_ptr.get_sensitivities(x,             # <<<<<<<<<<<<<<
 *                                                                                                          fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 */
  __pyx_v_sensitivities = __pyx_v_self->_yield_curve_ptr->get_sensitivities(__pyx_v_x, __pyx_v_fixed_region_allocator);

  /* "_redukti.pyx":756
 *         cdef curve.CurveSensitivitiesPointerType sensitivities = self._yield_curve_ptr.get_sensitivities(x,
 *                                                                                                          fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()             # <<<<<<<<<<<<<<
 *         if data is NULL:
 *             return None
 */
  __pyx_v_data = __pyx_v_sensitivities.get();

  /* "_redukti.pyx":757
 *                                                                                                          fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return ADVar.dup(sensitivities.get())
 */
  __pyx_t_1 = ((__pyx_v_data == NULL) != 0);
  if (__pyx_t_1) {

    /* "_redukti.pyx":758
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:
 *             return None             # <<<<<<<<<<<<<<
 *         return ADVar.dup(sensitivities.get())
 * 
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)Py_None); __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "_redukti.pyx":757
 *                                                                                                          fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return ADVar.dup(sensitivities.get())
 */
  }

  /* "_redukti.pyx":759
 *         if data is NULL:
 *             return None
 *         return ADVar.dup(sensitivities.get())             # <<<<<<<<<<<<<<
 * 
 *     cpdef ADVar get_sensitivities(self, double x):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __pyx_t_2 = __pyx_f_8_redukti_5ADVar_dup(__pyx_v_sensitivities.get()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 759, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_ADVar))))) __PYX_ERR(0, 759, __pyx_L1_error)
  __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":753
 *         return self._yield_curve_ptr.time_from_reference(d.serial())
 * 
 *     cdef ADVar get_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):             # <<<<<<<<<<<<<<
 *         cdef curve.CurveSensitivitiesPointerType sensitivities = self._yield_curve_ptr.get_sensitivities(x,
 *                                                                                                          fixed_region_allocator)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.get_sensitivities_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":761
 *         return ADVar.dup(sensitivities.get())
 * 
 *     cpdef ADVar get_sensitivities(self, double x):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains sensitivities of x to the interpolator fixed points.
 */

static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_15get_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x); /*proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_22InterpolatedYieldCurve_get_sensitivities(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, double __pyx_v_x, int __pyx_skip_dispatch) {
  redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator;
  size_t __pyx_v_pos;
  struct __pyx_obj_8_redukti_ADVar *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  redukti::FixedRegionAllocator *__pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  char const *__pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  struct __pyx_obj_8_redukti_ADVar *__pyx_t_16 = NULL;
  __Pyx_RefNannySetupContext("get_sensitivities", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_get_sensitivities); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 761, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_22InterpolatedYieldCurve_15get_sensitivities)) {
        __Pyx_XDECREF(((PyObject *)__pyx_r));
        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_x); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 761, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_5)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_5);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
          }
        }
        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 761, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_ADVar))))) __PYX_ERR(0, 761, __pyx_L1_error)
        __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":771
 *             An ADVar containing first order and second order sensitivities depending upon how the interpolator was configured
 *         """
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator             # <<<<<<<<<<<<<<
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:
 */
  __pyx_t_6 = redukti::get_threadspecific_allocators()->tempspace_allocator;
  __pyx_v_fixed_region_allocator = __pyx_t_6;

  /* "_redukti.pyx":772
 *         """
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython             # <<<<<<<<<<<<<<
 *         try:
 *             return self.get_sensitivities_(x, fixed_region_allocator)
 */
  __pyx_v_pos = __pyx_v_fixed_region_allocator->pos();

  /* "_redukti.pyx":773
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:             # <<<<<<<<<<<<<<
 *             return self.get_sensitivities_(x, fixed_region_allocator)
 *         finally:
 */
  /*try:*/ {

    /* "_redukti.pyx":774
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:
 *             return self.get_sensitivities_(x, fixed_region_allocator)             # <<<<<<<<<<<<<<
 *         finally:
 *             fixed_region_allocator.pos(pos)
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_8_redukti_InterpolatedYieldCurve *)__pyx_v_self->__pyx_vtab)->get_sensitivities_(__pyx_v_self, __pyx_v_x, __pyx_v_fixed_region_allocator)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 774, __pyx_L4_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_1);
    __pyx_t_1 = 0;
    goto __pyx_L3_return;
  }

  /* "_redukti.pyx":776
 *             return self.get_sensitivities_(x, fixed_region_allocator)
 *         finally:
 *             fixed_region_allocator.pos(pos)             # <<<<<<<<<<<<<<
 * 
 * cdef class SvenssonCurve:
 */
  /*finally:*/ {
    __pyx_L4_error:;
    /*exception exit:*/{
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12) < 0)) __Pyx_ErrFetch(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_14);
      __Pyx_XGOTREF(__pyx_t_15);
      __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
      {
        __pyx_v_fixed_region_allocator->pos(__pyx_v_pos);
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_13);
        __Pyx_XGIVEREF(__pyx_t_14);
        __Pyx_XGIVEREF(__pyx_t_15);
        __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
      }
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ErrRestore(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_9;
      goto __pyx_L1_error;
    }
    __pyx_L3_return: {
      __pyx_t_16 = __pyx_r;
      __pyx_r = 0;
      __pyx_v_fixed_region_allocator->pos(__pyx_v_pos);
      __pyx_r = __pyx_t_16;
      __pyx_t_16 = 0;
      goto __pyx_L0;
    }
  }

  /* "_redukti.pyx":761
 *         return ADVar.dup(sensitivities.get())
 * 
 *     cpdef ADVar get_sensitivities(self, double x):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains sensitivities of x to the interpolator fixed points.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.get_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_15get_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x); /*proto*/
static char __pyx_doc_8_redukti_22InterpolatedYieldCurve_14get_sensitivities[] = "InterpolatedYieldCurve.get_sensitivities(self, double x) -> ADVar\n\n        Obtains sensitivities of x to the interpolator fixed points.\n\n        Args:\n            x: A value in the range of the interpolator's x-axis\n\n        Returns:\n            An ADVar containing first order and second order sensitivities depending upon how the interpolator was configured\n        ";
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_15get_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x) {
  double __pyx_v_x;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_sensitivities (wrapper)", 0);
  assert(__pyx_arg_x); {
    __pyx_v_x = __pyx_PyFloat_AsDouble(__pyx_arg_x); if (unlikely((__pyx_v_x == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 761, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.get_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve_14get_sensitivities(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self), ((double)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_14get_sensitivities(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, double __pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("get_sensitivities", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_8_redukti_22InterpolatedYieldCurve_get_sensitivities(__pyx_v_self, __pyx_v_x, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 761, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.get_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_17__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_22InterpolatedYieldCurve_16__reduce_cython__[] = "InterpolatedYieldCurve.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_17__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve_16__reduce_cython__(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_16__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__48, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_19__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_22InterpolatedYieldCurve_18__setstate_cython__[] = "InterpolatedYieldCurve.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_22InterpolatedYieldCurve_19__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_22InterpolatedYieldCurve_18__setstate_cython__(((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_22InterpolatedYieldCurve_18__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InterpolatedYieldCurve *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__49, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InterpolatedYieldCurve.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":792
 *     cdef curve.YieldCurve *_yield_curve_ptr
 * 
 *     def __init__(self, long long id, Date as_of_date, list parameters, enums.DayCountFraction fraction):             # <<<<<<<<<<<<<<
 *         pass
 * 
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_13SvenssonCurve_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_13SvenssonCurve_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PY_LONG_LONG __pyx_v_id;
  CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date = 0;
  CYTHON_UNUSED PyObject *__pyx_v_parameters = 0;
  CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_fraction;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_as_of_date,&__pyx_n_s_parameters,&__pyx_n_s_fraction,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_as_of_date)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 4, 4, 1); __PYX_ERR(0, 792, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_parameters)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 4, 4, 2); __PYX_ERR(0, 792, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fraction)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 4, 4, 3); __PYX_ERR(0, 792, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 792, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_id = __Pyx_PyInt_As_PY_LONG_LONG(values[0]); if (unlikely((__pyx_v_id == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 792, __pyx_L3_error)
    __pyx_v_as_of_date = ((struct __pyx_obj_8_redukti_Date *)values[1]);
    __pyx_v_parameters = ((PyObject*)values[2]);
    __pyx_v_fraction = ((enum redukti::DayCountFraction)__Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(values[3])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 792, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 792, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.SvenssonCurve.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_as_of_date), __pyx_ptype_8_redukti_Date, 1, "as_of_date", 0))) __PYX_ERR(0, 792, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_parameters), (&PyList_Type), 1, "parameters", 1))) __PYX_ERR(0, 792, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_13SvenssonCurve___init__(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self), __pyx_v_id, __pyx_v_as_of_date, __pyx_v_parameters, __pyx_v_fraction);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_13SvenssonCurve___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, CYTHON_UNUSED PY_LONG_LONG __pyx_v_id, CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, CYTHON_UNUSED PyObject *__pyx_v_parameters, CYTHON_UNUSED enum redukti::DayCountFraction __pyx_v_fraction) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":795
 *         pass
 * 
 *     def __cinit__(self, long long id, Date as_of_date, list parameters, enums.DayCountFraction fraction):             # <<<<<<<<<<<<<<
 *         if len(parameters) != 6:
 *             raise ValueError('Invalid size of parameters: six parameters required')
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_13SvenssonCurve_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_13SvenssonCurve_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PY_LONG_LONG __pyx_v_id;
  struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date = 0;
  PyObject *__pyx_v_parameters = 0;
  enum redukti::DayCountFraction __pyx_v_fraction;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_id,&__pyx_n_s_as_of_date,&__pyx_n_s_parameters,&__pyx_n_s_fraction,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_id)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_as_of_date)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 4, 4, 1); __PYX_ERR(0, 795, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_parameters)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 4, 4, 2); __PYX_ERR(0, 795, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_fraction)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 4, 4, 3); __PYX_ERR(0, 795, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 795, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_id = __Pyx_PyInt_As_PY_LONG_LONG(values[0]); if (unlikely((__pyx_v_id == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 795, __pyx_L3_error)
    __pyx_v_as_of_date = ((struct __pyx_obj_8_redukti_Date *)values[1]);
    __pyx_v_parameters = ((PyObject*)values[2]);
    __pyx_v_fraction = ((enum redukti::DayCountFraction)__Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(values[3])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 795, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 795, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.SvenssonCurve.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_as_of_date), __pyx_ptype_8_redukti_Date, 1, "as_of_date", 0))) __PYX_ERR(0, 795, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_parameters), (&PyList_Type), 1, "parameters", 1))) __PYX_ERR(0, 795, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_13SvenssonCurve_2__cinit__(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self), __pyx_v_id, __pyx_v_as_of_date, __pyx_v_parameters, __pyx_v_fraction);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_13SvenssonCurve_2__cinit__(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, PY_LONG_LONG __pyx_v_id, struct __pyx_obj_8_redukti_Date *__pyx_v_as_of_date, PyObject *__pyx_v_parameters, enum redukti::DayCountFraction __pyx_v_fraction) {
  double *__pyx_v_ydata;
  int __pyx_v_size;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  Py_ssize_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":796
 * 
 *     def __cinit__(self, long long id, Date as_of_date, list parameters, enums.DayCountFraction fraction):
 *         if len(parameters) != 6:             # <<<<<<<<<<<<<<
 *             raise ValueError('Invalid size of parameters: six parameters required')
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:
 */
  if (unlikely(__pyx_v_parameters == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 796, __pyx_L1_error)
  }
  __pyx_t_1 = PyList_GET_SIZE(__pyx_v_parameters); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 796, __pyx_L1_error)
  __pyx_t_2 = ((__pyx_t_1 != 6) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":797
 *     def __cinit__(self, long long id, Date as_of_date, list parameters, enums.DayCountFraction fraction):
 *         if len(parameters) != 6:
 *             raise ValueError('Invalid size of parameters: six parameters required')             # <<<<<<<<<<<<<<
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:
 *             raise ValueError('Beta0, tau1 and tau2 must be positive')
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__50, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 797, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 797, __pyx_L1_error)

    /* "_redukti.pyx":796
 * 
 *     def __cinit__(self, long long id, Date as_of_date, list parameters, enums.DayCountFraction fraction):
 *         if len(parameters) != 6:             # <<<<<<<<<<<<<<
 *             raise ValueError('Invalid size of parameters: six parameters required')
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:
 */
  }

  /* "_redukti.pyx":798
 *         if len(parameters) != 6:
 *             raise ValueError('Invalid size of parameters: six parameters required')
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:             # <<<<<<<<<<<<<<
 *             raise ValueError('Beta0, tau1 and tau2 must be positive')
 *         self._parameters = array.array('d', parameters)
 */
  if (unlikely(__pyx_v_parameters == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
    __PYX_ERR(0, 798, __pyx_L1_error)
  }
  __pyx_t_3 = __Pyx_GetItemInt_List(__pyx_v_parameters, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_float_0_0, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (!__pyx_t_5) {
  } else {
    __pyx_t_2 = __pyx_t_5;
    goto __pyx_L5_bool_binop_done;
  }
  if (unlikely(__pyx_v_parameters == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
    __PYX_ERR(0, 798, __pyx_L1_error)
  }
  __pyx_t_4 = __Pyx_GetItemInt_List(__pyx_v_parameters, 4, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyObject_RichCompare(__pyx_t_4, __pyx_float_0_0, Py_LT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (!__pyx_t_5) {
  } else {
    __pyx_t_2 = __pyx_t_5;
    goto __pyx_L5_bool_binop_done;
  }
  if (unlikely(__pyx_v_parameters == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
    __PYX_ERR(0, 798, __pyx_L1_error)
  }
  __pyx_t_3 = __Pyx_GetItemInt_List(__pyx_v_parameters, 5, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_float_0_0, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_2 = __pyx_t_5;
  __pyx_L5_bool_binop_done:;
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":799
 *             raise ValueError('Invalid size of parameters: six parameters required')
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:
 *             raise ValueError('Beta0, tau1 and tau2 must be positive')             # <<<<<<<<<<<<<<
 *         self._parameters = array.array('d', parameters)
 *         cdef double *ydata = <double *> self._parameters.data.as_voidptr
 */
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__51, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 799, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 799, __pyx_L1_error)

    /* "_redukti.pyx":798
 *         if len(parameters) != 6:
 *             raise ValueError('Invalid size of parameters: six parameters required')
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:             # <<<<<<<<<<<<<<
 *             raise ValueError('Beta0, tau1 and tau2 must be positive')
 *         self._parameters = array.array('d', parameters)
 */
  }

  /* "_redukti.pyx":800
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:
 *             raise ValueError('Beta0, tau1 and tau2 must be positive')
 *         self._parameters = array.array('d', parameters)             # <<<<<<<<<<<<<<
 *         cdef double *ydata = <double *> self._parameters.data.as_voidptr
 *         cdef int size = len(parameters)
 */
  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 800, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_n_u_d);
  __Pyx_GIVEREF(__pyx_n_u_d);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_n_u_d);
  __Pyx_INCREF(__pyx_v_parameters);
  __Pyx_GIVEREF(__pyx_v_parameters);
  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_parameters);
  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_7cpython_5array_array), __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 800, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(__pyx_v_self->_parameters);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->_parameters));
  __pyx_v_self->_parameters = ((arrayobject *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "_redukti.pyx":801
 *             raise ValueError('Beta0, tau1 and tau2 must be positive')
 *         self._parameters = array.array('d', parameters)
 *         cdef double *ydata = <double *> self._parameters.data.as_voidptr             # <<<<<<<<<<<<<<
 *         cdef int size = len(parameters)
 *         self._yield_curve = curve.make_svensson_curve(allocator.get_default_allocator(), id, as_of_date.serial(), ydata,
 */
  __pyx_v_ydata = ((double *)__pyx_v_self->_parameters->data.as_voidptr);

  /* "_redukti.pyx":802
 *         self._parameters = array.array('d', parameters)
 *         cdef double *ydata = <double *> self._parameters.data.as_voidptr
 *         cdef int size = len(parameters)             # <<<<<<<<<<<<<<
 *         self._yield_curve = curve.make_svensson_curve(allocator.get_default_allocator(), id, as_of_date.serial(), ydata,
 *                                                       size, fraction)
 */
  if (unlikely(__pyx_v_parameters == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 802, __pyx_L1_error)
  }
  __pyx_t_1 = PyList_GET_SIZE(__pyx_v_parameters); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 802, __pyx_L1_error)
  __pyx_v_size = __pyx_t_1;

  /* "_redukti.pyx":803
 *         cdef double *ydata = <double *> self._parameters.data.as_voidptr
 *         cdef int size = len(parameters)
 *         self._yield_curve = curve.make_svensson_curve(allocator.get_default_allocator(), id, as_of_date.serial(), ydata,             # <<<<<<<<<<<<<<
 *                                                       size, fraction)
 *         self._yield_curve_ptr = self._yield_curve.get()
 */
  __pyx_v_self->_yield_curve = redukti::make_svensson_curve(redukti::get_default_allocator(), __pyx_v_id, ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_as_of_date->__pyx_vtab)->serial(__pyx_v_as_of_date, 0), __pyx_v_ydata, __pyx_v_size, __pyx_v_fraction);

  /* "_redukti.pyx":805
 *         self._yield_curve = curve.make_svensson_curve(allocator.get_default_allocator(), id, as_of_date.serial(), ydata,
 *                                                       size, fraction)
 *         self._yield_curve_ptr = self._yield_curve.get()             # <<<<<<<<<<<<<<
 *         if self._yield_curve_ptr is NULL:
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 */
  __pyx_v_self->_yield_curve_ptr = __pyx_v_self->_yield_curve.get();

  /* "_redukti.pyx":806
 *                                                       size, fraction)
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 * 
 */
  __pyx_t_2 = ((__pyx_v_self->_yield_curve_ptr == NULL) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "_redukti.pyx":807
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
    __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__52, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 807, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 807, __pyx_L1_error)

    /* "_redukti.pyx":806
 *                                                       size, fraction)
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 * 
 */
  }

  /* "_redukti.pyx":795
 *         pass
 * 
 *     def __cinit__(self, long long id, Date as_of_date, list parameters, enums.DayCountFraction fraction):             # <<<<<<<<<<<<<<
 *         if len(parameters) != 6:
 *             raise ValueError('Invalid size of parameters: six parameters required')
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_redukti.SvenssonCurve.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":809
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._yield_curve.reset(NULL)
 * 
 */

/* Python wrapper */
static void __pyx_pw_8_redukti_13SvenssonCurve_5__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_8_redukti_13SvenssonCurve_5__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_8_redukti_13SvenssonCurve_4__dealloc__(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_8_redukti_13SvenssonCurve_4__dealloc__(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "_redukti.pyx":810
 * 
 *     def __dealloc__(self):
 *         self._yield_curve.reset(NULL)             # <<<<<<<<<<<<<<
 * 
 *     cpdef double discount(self, Date d):
 */
  __pyx_v_self->_yield_curve.reset(NULL);

  /* "_redukti.pyx":809
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._yield_curve.reset(NULL)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "_redukti.pyx":812
 *         self._yield_curve.reset(NULL)
 * 
 *     cpdef double discount(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the discount factor for the given date
 */

static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_13SvenssonCurve_discount(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("discount", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_discount); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 812, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_13SvenssonCurve_7discount)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 812, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 812, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":823
 *         """
 * 
 *         return self._yield_curve_ptr.discount(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double zero_rate(self, Date d):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->discount(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":812
 *         self._yield_curve.reset(NULL)
 * 
 *     cpdef double discount(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the discount factor for the given date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.SvenssonCurve.discount", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_13SvenssonCurve_6discount[] = "SvenssonCurve.discount(self, Date d) -> double\n\n        Computes the discount factor for the given date\n\n        Args:\n            d: Date for which discount factor is desired\n\n        Returns:\n            Desired discount factor\n        ";
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("discount (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 812, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_13SvenssonCurve_6discount(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_6discount(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("discount", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_13SvenssonCurve_discount(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 812, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.SvenssonCurve.discount", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":825
 *         return self._yield_curve_ptr.discount(d.serial())
 * 
 *     cpdef double zero_rate(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the continuously compounded zero rate for a given date
 */

static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_13SvenssonCurve_zero_rate(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("zero_rate", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_zero_rate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 825, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_13SvenssonCurve_9zero_rate)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 825, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 825, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":836
 *         """
 * 
 *         return self._yield_curve_ptr.zero_rate(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->zero_rate(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":825
 *         return self._yield_curve_ptr.discount(d.serial())
 * 
 *     cpdef double zero_rate(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the continuously compounded zero rate for a given date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.SvenssonCurve.zero_rate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_13SvenssonCurve_8zero_rate[] = "SvenssonCurve.zero_rate(self, Date d) -> double\n\n        Computes the continuously compounded zero rate for a given date\n\n        Args:\n            d: Date for which the zero rate is desired\n\n        Returns:\n            Continuously compounded zero rate at the given date\n        ";
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("zero_rate (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 825, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_13SvenssonCurve_8zero_rate(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_8zero_rate(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("zero_rate", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_13SvenssonCurve_zero_rate(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 825, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.SvenssonCurve.zero_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":838
 *         return self._yield_curve_ptr.zero_rate(d.serial())
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the forward rate between two dates
 */

static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static double __pyx_f_8_redukti_13SvenssonCurve_forward_rate(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  double __pyx_t_7;
  __Pyx_RefNannySetupContext("forward_rate", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_forward_rate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 838, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_13SvenssonCurve_11forward_rate)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        __pyx_t_5 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
            __pyx_t_5 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2)};
          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 838, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2)};
          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 838, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        {
          __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 838, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_6);
          if (__pyx_t_4) {
            __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
          }
          __Pyx_INCREF(((PyObject *)__pyx_v_d1));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d1));
          PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, ((PyObject *)__pyx_v_d1));
          __Pyx_INCREF(((PyObject *)__pyx_v_d2));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d2));
          PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, ((PyObject *)__pyx_v_d2));
          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 838, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 838, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_7;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":850
 *         """
 * 
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double time_from_reference(self, Date d):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->forward_rate(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d1->__pyx_vtab)->serial(__pyx_v_d1, 0), ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d2->__pyx_vtab)->serial(__pyx_v_d2, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":838
 *         return self._yield_curve_ptr.zero_rate(d.serial())
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the forward rate between two dates
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_WriteUnraisable("_redukti.SvenssonCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_13SvenssonCurve_10forward_rate[] = "SvenssonCurve.forward_rate(self, Date d1, Date d2) -> double\n\n        Computes the forward rate between two dates\n\n        Args:\n            d1: Start date\n            d2: End date\n\n        Returns:\n            Forward rate for the specified dates\n        ";
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_d1 = 0;
  struct __pyx_obj_8_redukti_Date *__pyx_v_d2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("forward_rate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_d1,&__pyx_n_s_d2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("forward_rate", 1, 2, 2, 1); __PYX_ERR(0, 838, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "forward_rate") < 0)) __PYX_ERR(0, 838, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_d1 = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_d2 = ((struct __pyx_obj_8_redukti_Date *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("forward_rate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 838, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.SvenssonCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d1), __pyx_ptype_8_redukti_Date, 1, "d1", 0))) __PYX_ERR(0, 838, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d2), __pyx_ptype_8_redukti_Date, 1, "d2", 0))) __PYX_ERR(0, 838, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_13SvenssonCurve_10forward_rate(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self), __pyx_v_d1, __pyx_v_d2);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_10forward_rate(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("forward_rate", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_13SvenssonCurve_forward_rate(__pyx_v_self, __pyx_v_d1, __pyx_v_d2, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 838, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.SvenssonCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":852
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())
 * 
 *     cpdef double time_from_reference(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Gets time from the curve's reference date to the given date expressed as a year fraction
 */

static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_13SvenssonCurve_time_from_reference(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("time_from_reference", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_time_from_reference); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 852, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_13SvenssonCurve_13time_from_reference)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 852, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 852, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":862
 *             A double value expressing the time from curve's reference date
 *         """
 *         return self._yield_curve_ptr.time_from_reference(d.serial())             # <<<<<<<<<<<<<<
 * 
 * cdef class YieldCurve:
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->time_from_reference(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":852
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())
 * 
 *     cpdef double time_from_reference(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Gets time from the curve's reference date to the given date expressed as a year fraction
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.SvenssonCurve.time_from_reference", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_13SvenssonCurve_12time_from_reference[] = "SvenssonCurve.time_from_reference(self, Date d) -> double\n\n        Gets time from the curve's reference date to the given date expressed as a year fraction\n\n        Args:\n            d: date to be converted\n\n        Returns:\n            A double value expressing the time from curve's reference date\n        ";
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("time_from_reference (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 852, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_13SvenssonCurve_12time_from_reference(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_12time_from_reference(struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("time_from_reference", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_13SvenssonCurve_time_from_reference(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 852, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.SvenssonCurve.time_from_reference", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_15__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_13SvenssonCurve_14__reduce_cython__[] = "SvenssonCurve.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_15__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_13SvenssonCurve_14__reduce_cython__(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_14__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__53, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.SvenssonCurve.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_17__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_13SvenssonCurve_16__setstate_cython__[] = "SvenssonCurve.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_13SvenssonCurve_17__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_13SvenssonCurve_16__setstate_cython__(((struct __pyx_obj_8_redukti_SvenssonCurve *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_13SvenssonCurve_16__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_SvenssonCurve *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__54, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.SvenssonCurve.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":873
 *     cdef curve.YieldCurve *_yield_curve_ptr
 * 
 *     def __init__(self, Date business_date, curve_defn, zero_curve, int deriv_order = 2,             # <<<<<<<<<<<<<<
 *                   enums.PricingCurveType type = enums.PRICING_CURVE_TYPE_FORWARD,
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_10YieldCurve_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_10YieldCurve_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_business_date = 0;
  CYTHON_UNUSED PyObject *__pyx_v_curve_defn = 0;
  CYTHON_UNUSED PyObject *__pyx_v_zero_curve = 0;
  CYTHON_UNUSED int __pyx_v_deriv_order;
  CYTHON_UNUSED enum redukti::PricingCurveType __pyx_v_type;
  CYTHON_UNUSED enum redukti::MarketDataQualifier __pyx_v_mdq;
  CYTHON_UNUSED int __pyx_v_cycle;
  CYTHON_UNUSED int __pyx_v_scenario;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_business_date,&__pyx_n_s_curve_defn,&__pyx_n_s_zero_curve,&__pyx_n_s_deriv_order,&__pyx_n_s_type,&__pyx_n_s_mdq,&__pyx_n_s_cycle,&__pyx_n_s_scenario,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_business_date)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_curve_defn)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 8, 1); __PYX_ERR(0, 873, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_zero_curve)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 8, 2); __PYX_ERR(0, 873, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_deriv_order);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_type);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mdq);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cycle);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_scenario);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 873, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_business_date = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_curve_defn = values[1];
    __pyx_v_zero_curve = values[2];
    if (values[3]) {
      __pyx_v_deriv_order = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_deriv_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 873, __pyx_L3_error)
    } else {
      __pyx_v_deriv_order = ((int)2);
    }
    if (values[4]) {
      __pyx_v_type = ((enum redukti::PricingCurveType)__Pyx_PyInt_As_enum__redukti_3a__3a_PricingCurveType(values[4])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 874, __pyx_L3_error)
    } else {
      __pyx_v_type = __pyx_k__55;
    }
    if (values[5]) {
      __pyx_v_mdq = ((enum redukti::MarketDataQualifier)__Pyx_PyInt_As_enum__redukti_3a__3a_MarketDataQualifier(values[5])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 875, __pyx_L3_error)
    } else {
      __pyx_v_mdq = __pyx_k__56;
    }
    if (values[6]) {
      __pyx_v_cycle = __Pyx_PyInt_As_int(values[6]); if (unlikely((__pyx_v_cycle == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 875, __pyx_L3_error)
    } else {
      __pyx_v_cycle = ((int)0);
    }
    if (values[7]) {
      __pyx_v_scenario = __Pyx_PyInt_As_int(values[7]); if (unlikely((__pyx_v_scenario == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 875, __pyx_L3_error)
    } else {
      __pyx_v_scenario = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 873, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.YieldCurve.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_business_date), __pyx_ptype_8_redukti_Date, 1, "business_date", 0))) __PYX_ERR(0, 873, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve___init__(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self), __pyx_v_business_date, __pyx_v_curve_defn, __pyx_v_zero_curve, __pyx_v_deriv_order, __pyx_v_type, __pyx_v_mdq, __pyx_v_cycle, __pyx_v_scenario);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_10YieldCurve___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, CYTHON_UNUSED struct __pyx_obj_8_redukti_Date *__pyx_v_business_date, CYTHON_UNUSED PyObject *__pyx_v_curve_defn, CYTHON_UNUSED PyObject *__pyx_v_zero_curve, CYTHON_UNUSED int __pyx_v_deriv_order, CYTHON_UNUSED enum redukti::PricingCurveType __pyx_v_type, CYTHON_UNUSED enum redukti::MarketDataQualifier __pyx_v_mdq, CYTHON_UNUSED int __pyx_v_cycle, CYTHON_UNUSED int __pyx_v_scenario) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":878
 *         pass
 * 
 *     def __cinit__(self, Date business_date, curve_defn, zero_curve, int deriv_order = 2,             # <<<<<<<<<<<<<<
 *                   enums.PricingCurveType type = enums.PRICING_CURVE_TYPE_FORWARD,
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_10YieldCurve_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_10YieldCurve_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_business_date = 0;
  PyObject *__pyx_v_curve_defn = 0;
  PyObject *__pyx_v_zero_curve = 0;
  int __pyx_v_deriv_order;
  enum redukti::PricingCurveType __pyx_v_type;
  enum redukti::MarketDataQualifier __pyx_v_mdq;
  int __pyx_v_cycle;
  int __pyx_v_scenario;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_business_date,&__pyx_n_s_curve_defn,&__pyx_n_s_zero_curve,&__pyx_n_s_deriv_order,&__pyx_n_s_type,&__pyx_n_s_mdq,&__pyx_n_s_cycle,&__pyx_n_s_scenario,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_business_date)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_curve_defn)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 8, 1); __PYX_ERR(0, 878, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_zero_curve)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 8, 2); __PYX_ERR(0, 878, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_deriv_order);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_type);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mdq);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cycle);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_scenario);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 878, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_business_date = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_curve_defn = values[1];
    __pyx_v_zero_curve = values[2];
    if (values[3]) {
      __pyx_v_deriv_order = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_deriv_order == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 878, __pyx_L3_error)
    } else {
      __pyx_v_deriv_order = ((int)2);
    }
    if (values[4]) {
      __pyx_v_type = ((enum redukti::PricingCurveType)__Pyx_PyInt_As_enum__redukti_3a__3a_PricingCurveType(values[4])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 879, __pyx_L3_error)
    } else {
      __pyx_v_type = __pyx_k__57;
    }
    if (values[5]) {
      __pyx_v_mdq = ((enum redukti::MarketDataQualifier)__Pyx_PyInt_As_enum__redukti_3a__3a_MarketDataQualifier(values[5])); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 880, __pyx_L3_error)
    } else {
      __pyx_v_mdq = __pyx_k__58;
    }
    if (values[6]) {
      __pyx_v_cycle = __Pyx_PyInt_As_int(values[6]); if (unlikely((__pyx_v_cycle == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 880, __pyx_L3_error)
    } else {
      __pyx_v_cycle = ((int)0);
    }
    if (values[7]) {
      __pyx_v_scenario = __Pyx_PyInt_As_int(values[7]); if (unlikely((__pyx_v_scenario == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 880, __pyx_L3_error)
    } else {
      __pyx_v_scenario = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 3, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 878, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.YieldCurve.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_business_date), __pyx_ptype_8_redukti_Date, 1, "business_date", 0))) __PYX_ERR(0, 878, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve_2__cinit__(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self), __pyx_v_business_date, __pyx_v_curve_defn, __pyx_v_zero_curve, __pyx_v_deriv_order, __pyx_v_type, __pyx_v_mdq, __pyx_v_cycle, __pyx_v_scenario);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_10YieldCurve_2__cinit__(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_business_date, PyObject *__pyx_v_curve_defn, PyObject *__pyx_v_zero_curve, int __pyx_v_deriv_order, enum redukti::PricingCurveType __pyx_v_type, enum redukti::MarketDataQualifier __pyx_v_mdq, int __pyx_v_cycle, int __pyx_v_scenario) {
  std::string __pyx_v_str;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  std::string __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":881
 *                   enums.PricingCurveType type = enums.PRICING_CURVE_TYPE_FORWARD,
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):
 *         cdef string str = curve_defn.SerializeToString()             # <<<<<<<<<<<<<<
 *         if not self._definition.ParseFromString(str):
 *             raise ValueError("Cannot parse the IRCurveDefinition")
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_curve_defn, __pyx_n_s_SerializeToString); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_str = __pyx_t_4;

  /* "_redukti.pyx":882
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):
 *         cdef string str = curve_defn.SerializeToString()
 *         if not self._definition.ParseFromString(str):             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot parse the IRCurveDefinition")
 *         str = zero_curve.SerializeToString()
 */
  __pyx_t_5 = ((!(__pyx_v_self->_definition.ParseFromString(__pyx_v_str) != 0)) != 0);
  if (unlikely(__pyx_t_5)) {

    /* "_redukti.pyx":883
 *         cdef string str = curve_defn.SerializeToString()
 *         if not self._definition.ParseFromString(str):
 *             raise ValueError("Cannot parse the IRCurveDefinition")             # <<<<<<<<<<<<<<
 *         str = zero_curve.SerializeToString()
 *         if not self._underlying_curve.ParseFromString(str):
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__59, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 883, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 883, __pyx_L1_error)

    /* "_redukti.pyx":882
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):
 *         cdef string str = curve_defn.SerializeToString()
 *         if not self._definition.ParseFromString(str):             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot parse the IRCurveDefinition")
 *         str = zero_curve.SerializeToString()
 */
  }

  /* "_redukti.pyx":884
 *         if not self._definition.ParseFromString(str):
 *             raise ValueError("Cannot parse the IRCurveDefinition")
 *         str = zero_curve.SerializeToString()             # <<<<<<<<<<<<<<
 *         if not self._underlying_curve.ParseFromString(str):
 *             raise ValueError("Cannot parse the ZeroCurve")
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_zero_curve, __pyx_n_s_SerializeToString); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 884, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 884, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __pyx_convert_string_from_py_std__in_string(__pyx_t_1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 884, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_str = __pyx_t_4;

  /* "_redukti.pyx":885
 *             raise ValueError("Cannot parse the IRCurveDefinition")
 *         str = zero_curve.SerializeToString()
 *         if not self._underlying_curve.ParseFromString(str):             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot parse the ZeroCurve")
 *         self._yield_curve = curve.make_curve(business_date.serial(), &self._definition, self._underlying_curve,
 */
  __pyx_t_5 = ((!(__pyx_v_self->_underlying_curve.ParseFromString(__pyx_v_str) != 0)) != 0);
  if (unlikely(__pyx_t_5)) {

    /* "_redukti.pyx":886
 *         str = zero_curve.SerializeToString()
 *         if not self._underlying_curve.ParseFromString(str):
 *             raise ValueError("Cannot parse the ZeroCurve")             # <<<<<<<<<<<<<<
 *         self._yield_curve = curve.make_curve(business_date.serial(), &self._definition, self._underlying_curve,
 *                                              deriv_order, type, mdq, cycle, scenario)
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__60, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 886, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 886, __pyx_L1_error)

    /* "_redukti.pyx":885
 *             raise ValueError("Cannot parse the IRCurveDefinition")
 *         str = zero_curve.SerializeToString()
 *         if not self._underlying_curve.ParseFromString(str):             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot parse the ZeroCurve")
 *         self._yield_curve = curve.make_curve(business_date.serial(), &self._definition, self._underlying_curve,
 */
  }

  /* "_redukti.pyx":887
 *         if not self._underlying_curve.ParseFromString(str):
 *             raise ValueError("Cannot parse the ZeroCurve")
 *         self._yield_curve = curve.make_curve(business_date.serial(), &self._definition, self._underlying_curve,             # <<<<<<<<<<<<<<
 *                                              deriv_order, type, mdq, cycle, scenario)
 *         self._yield_curve_ptr = self._yield_curve.get()
 */
  __pyx_v_self->_yield_curve = redukti::make_curve(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_business_date->__pyx_vtab)->serial(__pyx_v_business_date, 0), (&__pyx_v_self->_definition), __pyx_v_self->_underlying_curve, __pyx_v_deriv_order, __pyx_v_type, __pyx_v_mdq, __pyx_v_cycle, __pyx_v_scenario);

  /* "_redukti.pyx":889
 *         self._yield_curve = curve.make_curve(business_date.serial(), &self._definition, self._underlying_curve,
 *                                              deriv_order, type, mdq, cycle, scenario)
 *         self._yield_curve_ptr = self._yield_curve.get()             # <<<<<<<<<<<<<<
 *         if self._yield_curve_ptr is NULL:
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 */
  __pyx_v_self->_yield_curve_ptr = __pyx_v_self->_yield_curve.get();

  /* "_redukti.pyx":890
 *                                              deriv_order, type, mdq, cycle, scenario)
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 * 
 */
  __pyx_t_5 = ((__pyx_v_self->_yield_curve_ptr == NULL) != 0);
  if (unlikely(__pyx_t_5)) {

    /* "_redukti.pyx":891
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
    __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__52, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 891, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 891, __pyx_L1_error)

    /* "_redukti.pyx":890
 *                                              deriv_order, type, mdq, cycle, scenario)
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 * 
 */
  }

  /* "_redukti.pyx":878
 *         pass
 * 
 *     def __cinit__(self, Date business_date, curve_defn, zero_curve, int deriv_order = 2,             # <<<<<<<<<<<<<<
 *                   enums.PricingCurveType type = enums.PRICING_CURVE_TYPE_FORWARD,
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("_redukti.YieldCurve.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":893
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._yield_curve.reset(NULL)
 * 
 */

/* Python wrapper */
static void __pyx_pw_8_redukti_10YieldCurve_5__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_8_redukti_10YieldCurve_5__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_8_redukti_10YieldCurve_4__dealloc__(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_8_redukti_10YieldCurve_4__dealloc__(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "_redukti.pyx":894
 * 
 *     def __dealloc__(self):
 *         self._yield_curve.reset(NULL)             # <<<<<<<<<<<<<<
 * 
 *     cpdef double discount(self, Date d):
 */
  __pyx_v_self->_yield_curve.reset(NULL);

  /* "_redukti.pyx":893
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self._yield_curve.reset(NULL)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "_redukti.pyx":896
 *         self._yield_curve.reset(NULL)
 * 
 *     cpdef double discount(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the discount factor for the given date
 */

static PyObject *__pyx_pw_8_redukti_10YieldCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_10YieldCurve_discount(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("discount", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_discount); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 896, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_10YieldCurve_7discount)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 896, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 896, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":906
 *             Desired discount factor
 *         """
 *         return self._yield_curve_ptr.discount(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double zero_rate(self, Date d):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->discount(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":896
 *         self._yield_curve.reset(NULL)
 * 
 *     cpdef double discount(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the discount factor for the given date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.YieldCurve.discount", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_10YieldCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_10YieldCurve_6discount[] = "YieldCurve.discount(self, Date d) -> double\n\n        Computes the discount factor for the given date\n\n        Args:\n            d: Date for which discount factor is desired\n\n        Returns:\n            Desired discount factor\n        ";
static PyObject *__pyx_pw_8_redukti_10YieldCurve_7discount(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("discount (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 896, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve_6discount(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_10YieldCurve_6discount(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("discount", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_10YieldCurve_discount(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 896, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.YieldCurve.discount", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":908
 *         return self._yield_curve_ptr.discount(d.serial())
 * 
 *     cpdef double zero_rate(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the continuously compounded zero rate for a given date
 */

static PyObject *__pyx_pw_8_redukti_10YieldCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_10YieldCurve_zero_rate(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("zero_rate", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_zero_rate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 908, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_10YieldCurve_9zero_rate)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 908, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 908, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":918
 *             Continuously compounded zero rate at the given date
 *         """
 *         return self._yield_curve_ptr.zero_rate(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->zero_rate(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":908
 *         return self._yield_curve_ptr.discount(d.serial())
 * 
 *     cpdef double zero_rate(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the continuously compounded zero rate for a given date
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.YieldCurve.zero_rate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_10YieldCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_10YieldCurve_8zero_rate[] = "YieldCurve.zero_rate(self, Date d) -> double\n\n        Computes the continuously compounded zero rate for a given date\n\n        Args:\n            d: Date for which the zero rate is desired\n\n        Returns:\n            Continuously compounded zero rate at the given date\n        ";
static PyObject *__pyx_pw_8_redukti_10YieldCurve_9zero_rate(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("zero_rate (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 908, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve_8zero_rate(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_10YieldCurve_8zero_rate(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("zero_rate", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_10YieldCurve_zero_rate(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 908, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.YieldCurve.zero_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":920
 *         return self._yield_curve_ptr.zero_rate(d.serial())
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the forward rate between two dates
 */

static PyObject *__pyx_pw_8_redukti_10YieldCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static double __pyx_f_8_redukti_10YieldCurve_forward_rate(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  double __pyx_t_7;
  __Pyx_RefNannySetupContext("forward_rate", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_forward_rate); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 920, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_10YieldCurve_11forward_rate)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        __pyx_t_5 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
            __pyx_t_5 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2)};
          __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 920, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, ((PyObject *)__pyx_v_d1), ((PyObject *)__pyx_v_d2)};
          __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 920, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_2);
        } else
        #endif
        {
          __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 920, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_6);
          if (__pyx_t_4) {
            __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
          }
          __Pyx_INCREF(((PyObject *)__pyx_v_d1));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d1));
          PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, ((PyObject *)__pyx_v_d1));
          __Pyx_INCREF(((PyObject *)__pyx_v_d2));
          __Pyx_GIVEREF(((PyObject *)__pyx_v_d2));
          PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, ((PyObject *)__pyx_v_d2));
          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 920, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 920, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_7;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":932
 *         """
 * 
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())             # <<<<<<<<<<<<<<
 * 
 *     cpdef double time_from_reference(self, Date d):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->forward_rate(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d1->__pyx_vtab)->serial(__pyx_v_d1, 0), ((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d2->__pyx_vtab)->serial(__pyx_v_d2, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":920
 *         return self._yield_curve_ptr.zero_rate(d.serial())
 * 
 *     cpdef double forward_rate(self, Date d1, Date d2):             # <<<<<<<<<<<<<<
 *         """
 *         Computes the forward rate between two dates
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_WriteUnraisable("_redukti.YieldCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_10YieldCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_10YieldCurve_10forward_rate[] = "YieldCurve.forward_rate(self, Date d1, Date d2) -> double\n\n        Computes the forward rate between two dates\n\n        Args:\n            d1: Start date\n            d2: End date\n\n        Returns:\n            Forward rate for the specified dates\n        ";
static PyObject *__pyx_pw_8_redukti_10YieldCurve_11forward_rate(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_8_redukti_Date *__pyx_v_d1 = 0;
  struct __pyx_obj_8_redukti_Date *__pyx_v_d2 = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("forward_rate (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_d1,&__pyx_n_s_d2,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_d2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("forward_rate", 1, 2, 2, 1); __PYX_ERR(0, 920, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "forward_rate") < 0)) __PYX_ERR(0, 920, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_d1 = ((struct __pyx_obj_8_redukti_Date *)values[0]);
    __pyx_v_d2 = ((struct __pyx_obj_8_redukti_Date *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("forward_rate", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 920, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.YieldCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d1), __pyx_ptype_8_redukti_Date, 1, "d1", 0))) __PYX_ERR(0, 920, __pyx_L1_error)
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d2), __pyx_ptype_8_redukti_Date, 1, "d2", 0))) __PYX_ERR(0, 920, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve_10forward_rate(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self), __pyx_v_d1, __pyx_v_d2);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_10YieldCurve_10forward_rate(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d1, struct __pyx_obj_8_redukti_Date *__pyx_v_d2) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("forward_rate", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_10YieldCurve_forward_rate(__pyx_v_self, __pyx_v_d1, __pyx_v_d2, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 920, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.YieldCurve.forward_rate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":934
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())
 * 
 *     cpdef double time_from_reference(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Gets time from the curve's reference date to the given date expressed as a year fraction
 */

static PyObject *__pyx_pw_8_redukti_10YieldCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static double __pyx_f_8_redukti_10YieldCurve_time_from_reference(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d, int __pyx_skip_dispatch) {
  double __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  double __pyx_t_5;
  __Pyx_RefNannySetupContext("time_from_reference", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_time_from_reference); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 934, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_10YieldCurve_13time_from_reference)) {
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, ((PyObject *)__pyx_v_d)) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_d));
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 934, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_5 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_5 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 934, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_5;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":944
 *             A double value expressing the time from curve's reference date
 *         """
 *         return self._yield_curve_ptr.time_from_reference(d.serial())             # <<<<<<<<<<<<<<
 * 
 *     cdef ADVar get_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):
 */
  __pyx_r = __pyx_v_self->_yield_curve_ptr->time_from_reference(((struct __pyx_vtabstruct_8_redukti_Date *)__pyx_v_d->__pyx_vtab)->serial(__pyx_v_d, 0));
  goto __pyx_L0;

  /* "_redukti.pyx":934
 *         return self._yield_curve_ptr.forward_rate(d1.serial(), d2.serial())
 * 
 *     cpdef double time_from_reference(self, Date d):             # <<<<<<<<<<<<<<
 *         """
 *         Gets time from the curve's reference date to the given date expressed as a year fraction
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("_redukti.YieldCurve.time_from_reference", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_10YieldCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d); /*proto*/
static char __pyx_doc_8_redukti_10YieldCurve_12time_from_reference[] = "YieldCurve.time_from_reference(self, Date d) -> double\n\n        Gets time from the curve's reference date to the given date expressed as a year fraction\n\n        Args:\n            d: date to be converted\n\n        Returns:\n            A double value expressing the time from curve's reference date\n        ";
static PyObject *__pyx_pw_8_redukti_10YieldCurve_13time_from_reference(PyObject *__pyx_v_self, PyObject *__pyx_v_d) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("time_from_reference (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_d), __pyx_ptype_8_redukti_Date, 1, "d", 0))) __PYX_ERR(0, 934, __pyx_L1_error)
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve_12time_from_reference(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self), ((struct __pyx_obj_8_redukti_Date *)__pyx_v_d));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_10YieldCurve_12time_from_reference(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, struct __pyx_obj_8_redukti_Date *__pyx_v_d) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("time_from_reference", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_f_8_redukti_10YieldCurve_time_from_reference(__pyx_v_self, __pyx_v_d, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 934, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.YieldCurve.time_from_reference", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":946
 *         return self._yield_curve_ptr.time_from_reference(d.serial())
 * 
 *     cdef ADVar get_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):             # <<<<<<<<<<<<<<
 *         cdef curve.CurveSensitivitiesPointerType sensitivities = self._yield_curve_ptr.get_sensitivities(x,
 *                                                                                                          fixed_region_allocator)
 */

static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_10YieldCurve_get_sensitivities_(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, double __pyx_v_x, redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator) {
  redukti::CurveSensitivitiesPointerType __pyx_v_sensitivities;
  redukti_adouble_t *__pyx_v_data;
  struct __pyx_obj_8_redukti_ADVar *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("get_sensitivities_", 0);

  /* "_redukti.pyx":947
 * 
 *     cdef ADVar get_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):
 *         cdef curve.CurveSensitivitiesPointerType sensitivities = self._yield_curve_ptr.get_sensitivities(x,             # <<<<<<<<<<<<<<
 *                                                                                                          fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 */
  __pyx_v_sensitivities = __pyx_v_self->_yield_curve_ptr->get_sensitivities(__pyx_v_x, __pyx_v_fixed_region_allocator);

  /* "_redukti.pyx":949
 *         cdef curve.CurveSensitivitiesPointerType sensitivities = self._yield_curve_ptr.get_sensitivities(x,
 *                                                                                                          fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()             # <<<<<<<<<<<<<<
 *         if data is NULL:
 *             return None
 */
  __pyx_v_data = __pyx_v_sensitivities.get();

  /* "_redukti.pyx":950
 *                                                                                                          fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return ADVar.dup(sensitivities.get())
 */
  __pyx_t_1 = ((__pyx_v_data == NULL) != 0);
  if (__pyx_t_1) {

    /* "_redukti.pyx":951
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:
 *             return None             # <<<<<<<<<<<<<<
 *         return ADVar.dup(sensitivities.get())
 * 
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)Py_None); __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "_redukti.pyx":950
 *                                                                                                          fixed_region_allocator)
 *         cdef autodiff.redukti_adouble_t *data = sensitivities.get()
 *         if data is NULL:             # <<<<<<<<<<<<<<
 *             return None
 *         return ADVar.dup(sensitivities.get())
 */
  }

  /* "_redukti.pyx":952
 *         if data is NULL:
 *             return None
 *         return ADVar.dup(sensitivities.get())             # <<<<<<<<<<<<<<
 * 
 *     cpdef ADVar get_sensitivities(self, double x):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __pyx_t_2 = __pyx_f_8_redukti_5ADVar_dup(__pyx_v_sensitivities.get()); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 952, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_ADVar))))) __PYX_ERR(0, 952, __pyx_L1_error)
  __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_2);
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "_redukti.pyx":946
 *         return self._yield_curve_ptr.time_from_reference(d.serial())
 * 
 *     cdef ADVar get_sensitivities_(self, double x, allocator.FixedRegionAllocator *fixed_region_allocator):             # <<<<<<<<<<<<<<
 *         cdef curve.CurveSensitivitiesPointerType sensitivities = self._yield_curve_ptr.get_sensitivities(x,
 *                                                                                                          fixed_region_allocator)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("_redukti.YieldCurve.get_sensitivities_", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":954
 *         return ADVar.dup(sensitivities.get())
 * 
 *     cpdef ADVar get_sensitivities(self, double x):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains sensitivities of x to the interpolator fixed points.
 */

static PyObject *__pyx_pw_8_redukti_10YieldCurve_15get_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x); /*proto*/
static struct __pyx_obj_8_redukti_ADVar *__pyx_f_8_redukti_10YieldCurve_get_sensitivities(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, double __pyx_v_x, int __pyx_skip_dispatch) {
  redukti::FixedRegionAllocator *__pyx_v_fixed_region_allocator;
  size_t __pyx_v_pos;
  struct __pyx_obj_8_redukti_ADVar *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  redukti::FixedRegionAllocator *__pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  char const *__pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  struct __pyx_obj_8_redukti_ADVar *__pyx_t_16 = NULL;
  __Pyx_RefNannySetupContext("get_sensitivities", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_get_sensitivities); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 954, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_10YieldCurve_15get_sensitivities)) {
        __Pyx_XDECREF(((PyObject *)__pyx_r));
        __pyx_t_3 = PyFloat_FromDouble(__pyx_v_x); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 954, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
          if (likely(__pyx_t_5)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_5);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_4, function);
          }
        }
        __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3);
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 954, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_8_redukti_ADVar))))) __PYX_ERR(0, 954, __pyx_L1_error)
        __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":966
 *             An ADVar containing first order and second order sensitivities depending upon how the interpolator was configured
 *         """
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator             # <<<<<<<<<<<<<<
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:
 */
  __pyx_t_6 = redukti::get_threadspecific_allocators()->tempspace_allocator;
  __pyx_v_fixed_region_allocator = __pyx_t_6;

  /* "_redukti.pyx":967
 *         """
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython             # <<<<<<<<<<<<<<
 *         try:
 *             return self.get_sensitivities_(x, fixed_region_allocator)
 */
  __pyx_v_pos = __pyx_v_fixed_region_allocator->pos();

  /* "_redukti.pyx":968
 *         cdef allocator.FixedRegionAllocator *fixed_region_allocator = allocator.get_threadspecific_allocators().tempspace_allocator
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:             # <<<<<<<<<<<<<<
 *             return self.get_sensitivities_(x, fixed_region_allocator)
 *         finally:
 */
  /*try:*/ {

    /* "_redukti.pyx":969
 *         cdef size_t pos = fixed_region_allocator.pos()  # Since we can't use the FixedRegionAllocatorGuard in Cython
 *         try:
 *             return self.get_sensitivities_(x, fixed_region_allocator)             # <<<<<<<<<<<<<<
 *         finally:
 *             fixed_region_allocator.pos(pos)
 */
    __Pyx_XDECREF(((PyObject *)__pyx_r));
    __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_8_redukti_YieldCurve *)__pyx_v_self->__pyx_vtab)->get_sensitivities_(__pyx_v_self, __pyx_v_x, __pyx_v_fixed_region_allocator)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 969, __pyx_L4_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = ((struct __pyx_obj_8_redukti_ADVar *)__pyx_t_1);
    __pyx_t_1 = 0;
    goto __pyx_L3_return;
  }

  /* "_redukti.pyx":971
 *             return self.get_sensitivities_(x, fixed_region_allocator)
 *         finally:
 *             fixed_region_allocator.pos(pos)             # <<<<<<<<<<<<<<
 * 
 * cdef class InMemoryRequestProcessor:
 */
  /*finally:*/ {
    __pyx_L4_error:;
    /*exception exit:*/{
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12) < 0)) __Pyx_ErrFetch(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_14);
      __Pyx_XGOTREF(__pyx_t_15);
      __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
      {
        __pyx_v_fixed_region_allocator->pos(__pyx_v_pos);
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_13);
        __Pyx_XGIVEREF(__pyx_t_14);
        __Pyx_XGIVEREF(__pyx_t_15);
        __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
      }
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ErrRestore(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_9;
      goto __pyx_L1_error;
    }
    __pyx_L3_return: {
      __pyx_t_16 = __pyx_r;
      __pyx_r = 0;
      __pyx_v_fixed_region_allocator->pos(__pyx_v_pos);
      __pyx_r = __pyx_t_16;
      __pyx_t_16 = 0;
      goto __pyx_L0;
    }
  }

  /* "_redukti.pyx":954
 *         return ADVar.dup(sensitivities.get())
 * 
 *     cpdef ADVar get_sensitivities(self, double x):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains sensitivities of x to the interpolator fixed points.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_redukti.YieldCurve.get_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_10YieldCurve_15get_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x); /*proto*/
static char __pyx_doc_8_redukti_10YieldCurve_14get_sensitivities[] = "YieldCurve.get_sensitivities(self, double x) -> ADVar\n\n        Obtains sensitivities of x to the interpolator fixed points.\n        Note that this is only available on interpolated curves.\n        If you invoke this on a parametric curve you will get ``None`` as the answer.\n\n        Args:\n            x: A value in the range of the interpolator's x-axis\n\n        Returns:\n            An ADVar containing first order and second order sensitivities depending upon how the interpolator was configured\n        ";
static PyObject *__pyx_pw_8_redukti_10YieldCurve_15get_sensitivities(PyObject *__pyx_v_self, PyObject *__pyx_arg_x) {
  double __pyx_v_x;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_sensitivities (wrapper)", 0);
  assert(__pyx_arg_x); {
    __pyx_v_x = __pyx_PyFloat_AsDouble(__pyx_arg_x); if (unlikely((__pyx_v_x == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 954, __pyx_L3_error)
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.YieldCurve.get_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve_14get_sensitivities(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self), ((double)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_10YieldCurve_14get_sensitivities(struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, double __pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("get_sensitivities", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_8_redukti_10YieldCurve_get_sensitivities(__pyx_v_self, __pyx_v_x, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 954, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.YieldCurve.get_sensitivities", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_10YieldCurve_17__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_10YieldCurve_16__reduce_cython__[] = "YieldCurve.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_10YieldCurve_17__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve_16__reduce_cython__(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_10YieldCurve_16__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__61, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.YieldCurve.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_10YieldCurve_19__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_10YieldCurve_18__setstate_cython__[] = "YieldCurve.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_10YieldCurve_19__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_10YieldCurve_18__setstate_cython__(((struct __pyx_obj_8_redukti_YieldCurve *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_10YieldCurve_18__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_YieldCurve *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__62, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.YieldCurve.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":996
 *     cdef request_processor.RequestProcessor *_request_processor_ptr
 * 
 *     def __init__(self, pricing_script):             # <<<<<<<<<<<<<<
 *         """
 *         Args:
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_24InMemoryRequestProcessor_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_24InMemoryRequestProcessor___init__[] = "\n        Args:\n            pricing_script: The path to the Lua pricing script for the CurveBuildingService\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_8_redukti_24InMemoryRequestProcessor___init__;
#endif
static int __pyx_pw_8_redukti_24InMemoryRequestProcessor_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_pricing_script = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pricing_script,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pricing_script)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 996, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_pricing_script = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 996, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InMemoryRequestProcessor.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_24InMemoryRequestProcessor___init__(((struct __pyx_obj_8_redukti_InMemoryRequestProcessor *)__pyx_v_self), __pyx_v_pricing_script);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_24InMemoryRequestProcessor___init__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_pricing_script) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__", 0);

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":1003
 *         pass
 * 
 *     def __cinit__(self, pricing_script):             # <<<<<<<<<<<<<<
 *         pricing_script_byte_s = to_bytes(pricing_script)
 *         cdef const char* c_string = pricing_script_byte_s
 */

/* Python wrapper */
static int __pyx_pw_8_redukti_24InMemoryRequestProcessor_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_8_redukti_24InMemoryRequestProcessor_3__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_pricing_script = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pricing_script,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pricing_script)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 1003, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_pricing_script = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1003, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.InMemoryRequestProcessor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_24InMemoryRequestProcessor_2__cinit__(((struct __pyx_obj_8_redukti_InMemoryRequestProcessor *)__pyx_v_self), __pyx_v_pricing_script);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_8_redukti_24InMemoryRequestProcessor_2__cinit__(struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, PyObject *__pyx_v_pricing_script) {
  PyObject *__pyx_v_pricing_script_byte_s = NULL;
  char const *__pyx_v_c_string;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  char const *__pyx_t_2;
  int __pyx_t_3;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "_redukti.pyx":1004
 * 
 *     def __cinit__(self, pricing_script):
 *         pricing_script_byte_s = to_bytes(pricing_script)             # <<<<<<<<<<<<<<
 *         cdef const char* c_string = pricing_script_byte_s
 *         self._request_processor = request_processor.get_request_processor(c_string)
 */
  __pyx_t_1 = __pyx_f_8_redukti_to_bytes(__pyx_v_pricing_script); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1004, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_pricing_script_byte_s = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "_redukti.pyx":1005
 *     def __cinit__(self, pricing_script):
 *         pricing_script_byte_s = to_bytes(pricing_script)
 *         cdef const char* c_string = pricing_script_byte_s             # <<<<<<<<<<<<<<
 *         self._request_processor = request_processor.get_request_processor(c_string)
 *         self._request_processor_ptr = self._request_processor.get()
 */
  if (unlikely(__pyx_v_pricing_script_byte_s == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "expected bytes, NoneType found");
    __PYX_ERR(0, 1005, __pyx_L1_error)
  }
  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_v_pricing_script_byte_s); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 1005, __pyx_L1_error)
  __pyx_v_c_string = __pyx_t_2;

  /* "_redukti.pyx":1006
 *         pricing_script_byte_s = to_bytes(pricing_script)
 *         cdef const char* c_string = pricing_script_byte_s
 *         self._request_processor = request_processor.get_request_processor(c_string)             # <<<<<<<<<<<<<<
 *         self._request_processor_ptr = self._request_processor.get()
 *         if self._request_processor_ptr is NULL:
 */
  __pyx_v_self->_request_processor = redukti::get_request_processor(__pyx_v_c_string);

  /* "_redukti.pyx":1007
 *         cdef const char* c_string = pricing_script_byte_s
 *         self._request_processor = request_processor.get_request_processor(c_string)
 *         self._request_processor_ptr = self._request_processor.get()             # <<<<<<<<<<<<<<
 *         if self._request_processor_ptr is NULL:
 *             raise Exception('failed to create instance of InMemoryRequestProcessor')
 */
  __pyx_v_self->_request_processor_ptr = __pyx_v_self->_request_processor.get();

  /* "_redukti.pyx":1008
 *         self._request_processor = request_processor.get_request_processor(c_string)
 *         self._request_processor_ptr = self._request_processor.get()
 *         if self._request_processor_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('failed to create instance of InMemoryRequestProcessor')
 * 
 */
  __pyx_t_3 = ((__pyx_v_self->_request_processor_ptr == NULL) != 0);
  if (unlikely(__pyx_t_3)) {

    /* "_redukti.pyx":1009
 *         self._request_processor_ptr = self._request_processor.get()
 *         if self._request_processor_ptr is NULL:
 *             raise Exception('failed to create instance of InMemoryRequestProcessor')             # <<<<<<<<<<<<<<
 * 
 *     cpdef serve(self, request):
 */
    __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__63, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1009, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1009, __pyx_L1_error)

    /* "_redukti.pyx":1008
 *         self._request_processor = request_processor.get_request_processor(c_string)
 *         self._request_processor_ptr = self._request_processor.get()
 *         if self._request_processor_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('failed to create instance of InMemoryRequestProcessor')
 * 
 */
  }

  /* "_redukti.pyx":1003
 *         pass
 * 
 *     def __cinit__(self, pricing_script):             # <<<<<<<<<<<<<<
 *         pricing_script_byte_s = to_bytes(pricing_script)
 *         cdef const char* c_string = pricing_script_byte_s
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InMemoryRequestProcessor.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_pricing_script_byte_s);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "_redukti.pyx":1011
 *             raise Exception('failed to create instance of InMemoryRequestProcessor')
 * 
 *     cpdef serve(self, request):             # <<<<<<<<<<<<<<
 *         """
 *         Simple request processing service, designed to be compatible with the OpenRedukti server protocol.
 */

static PyObject *__pyx_pw_8_redukti_24InMemoryRequestProcessor_5serve(PyObject *__pyx_v_self, PyObject *__pyx_v_request); /*proto*/
static PyObject *__pyx_f_8_redukti_24InMemoryRequestProcessor_serve(struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, PyObject *__pyx_v_request, int __pyx_skip_dispatch) {
  std::string __pyx_v_request_str;
  redukti::Request __pyx_v_cpp_request;
  redukti::Response __pyx_v_cpp_response;
  PyObject *__pyx_v_response = NULL;
  std::string __pyx_v_response_str;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  std::string __pyx_t_7;
  __Pyx_RefNannySetupContext("serve", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      #endif
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_serve); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1011, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)(void*)__pyx_pw_8_redukti_24InMemoryRequestProcessor_5serve)) {
        __Pyx_XDECREF(__pyx_r);
        __Pyx_INCREF(__pyx_t_1);
        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
          }
        }
        __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_request) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_request);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1011, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_r = __pyx_t_2;
        __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        goto __pyx_L0;
      }
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
      if (unlikely(__pyx_type_dict_guard != __pyx_tp_dict_version)) {
        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
      }
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
    }
    #endif
  }

  /* "_redukti.pyx":1019
 *             The result from the request processor
 *         """
 *         if self._request_processor_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('Invalid state')
 *         if not isinstance(request, services_pb2.Request):
 */
  __pyx_t_5 = ((__pyx_v_self->_request_processor_ptr == NULL) != 0);
  if (unlikely(__pyx_t_5)) {

    /* "_redukti.pyx":1020
 *         """
 *         if self._request_processor_ptr is NULL:
 *             raise Exception('Invalid state')             # <<<<<<<<<<<<<<
 *         if not isinstance(request, services_pb2.Request):
 *             raise ValueError('Input must be an instance of services_pb2.Request')
 */
    __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__64, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1020, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1020, __pyx_L1_error)

    /* "_redukti.pyx":1019
 *             The result from the request processor
 *         """
 *         if self._request_processor_ptr is NULL:             # <<<<<<<<<<<<<<
 *             raise Exception('Invalid state')
 *         if not isinstance(request, services_pb2.Request):
 */
  }

  /* "_redukti.pyx":1021
 *         if self._request_processor_ptr is NULL:
 *             raise Exception('Invalid state')
 *         if not isinstance(request, services_pb2.Request):             # <<<<<<<<<<<<<<
 *             raise ValueError('Input must be an instance of services_pb2.Request')
 *         cdef string request_str = request.SerializeToString()
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_services_pb2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1021, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Request); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1021, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = PyObject_IsInstance(__pyx_v_request, __pyx_t_2); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 1021, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
  if (unlikely(__pyx_t_6)) {

    /* "_redukti.pyx":1022
 *             raise Exception('Invalid state')
 *         if not isinstance(request, services_pb2.Request):
 *             raise ValueError('Input must be an instance of services_pb2.Request')             # <<<<<<<<<<<<<<
 *         cdef string request_str = request.SerializeToString()
 *         cdef request_processor.Request cpp_request
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__65, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1022, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 1022, __pyx_L1_error)

    /* "_redukti.pyx":1021
 *         if self._request_processor_ptr is NULL:
 *             raise Exception('Invalid state')
 *         if not isinstance(request, services_pb2.Request):             # <<<<<<<<<<<<<<
 *             raise ValueError('Input must be an instance of services_pb2.Request')
 *         cdef string request_str = request.SerializeToString()
 */
  }

  /* "_redukti.pyx":1023
 *         if not isinstance(request, services_pb2.Request):
 *             raise ValueError('Input must be an instance of services_pb2.Request')
 *         cdef string request_str = request.SerializeToString()             # <<<<<<<<<<<<<<
 *         cdef request_processor.Request cpp_request
 *         if not cpp_request.ParseFromString(request_str):
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_request, __pyx_n_s_SerializeToString); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1023, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1023, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_7 = __pyx_convert_string_from_py_std__in_string(__pyx_t_2); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 1023, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_request_str = __pyx_t_7;

  /* "_redukti.pyx":1025
 *         cdef string request_str = request.SerializeToString()
 *         cdef request_processor.Request cpp_request
 *         if not cpp_request.ParseFromString(request_str):             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot parse the Request object")
 *         cdef request_processor.Response cpp_response
 */
  __pyx_t_6 = ((!(__pyx_v_cpp_request.ParseFromString(__pyx_v_request_str) != 0)) != 0);
  if (unlikely(__pyx_t_6)) {

    /* "_redukti.pyx":1026
 *         cdef request_processor.Request cpp_request
 *         if not cpp_request.ParseFromString(request_str):
 *             raise ValueError("Cannot parse the Request object")             # <<<<<<<<<<<<<<
 *         cdef request_processor.Response cpp_response
 *         self._request_processor_ptr.process(&cpp_request, &cpp_response)
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__66, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1026, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 1026, __pyx_L1_error)

    /* "_redukti.pyx":1025
 *         cdef string request_str = request.SerializeToString()
 *         cdef request_processor.Request cpp_request
 *         if not cpp_request.ParseFromString(request_str):             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot parse the Request object")
 *         cdef request_processor.Response cpp_response
 */
  }

  /* "_redukti.pyx":1028
 *             raise ValueError("Cannot parse the Request object")
 *         cdef request_processor.Response cpp_response
 *         self._request_processor_ptr.process(&cpp_request, &cpp_response)             # <<<<<<<<<<<<<<
 *         response = services_pb2.Response()
 *         cdef string response_str
 */
  (void)(__pyx_v_self->_request_processor_ptr->process((&__pyx_v_cpp_request), (&__pyx_v_cpp_response)));

  /* "_redukti.pyx":1029
 *         cdef request_processor.Response cpp_response
 *         self._request_processor_ptr.process(&cpp_request, &cpp_response)
 *         response = services_pb2.Response()             # <<<<<<<<<<<<<<
 *         cdef string response_str
 *         if not cpp_response.SerializeToString(&response_str):
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_services_pb2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1029, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Response); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1029, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_1) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1029, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_response = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "_redukti.pyx":1031
 *         response = services_pb2.Response()
 *         cdef string response_str
 *         if not cpp_response.SerializeToString(&response_str):             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to parse response from api call')
 *         response.ParseFromString(response_str)
 */
  __pyx_t_6 = ((!(__pyx_v_cpp_response.SerializeToString((&__pyx_v_response_str)) != 0)) != 0);
  if (unlikely(__pyx_t_6)) {

    /* "_redukti.pyx":1032
 *         cdef string response_str
 *         if not cpp_response.SerializeToString(&response_str):
 *             raise Exception('Failed to parse response from api call')             # <<<<<<<<<<<<<<
 *         response.ParseFromString(response_str)
 *         return response
 */
    __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__67, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1032, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 1032, __pyx_L1_error)

    /* "_redukti.pyx":1031
 *         response = services_pb2.Response()
 *         cdef string response_str
 *         if not cpp_response.SerializeToString(&response_str):             # <<<<<<<<<<<<<<
 *             raise Exception('Failed to parse response from api call')
 *         response.ParseFromString(response_str)
 */
  }

  /* "_redukti.pyx":1033
 *         if not cpp_response.SerializeToString(&response_str):
 *             raise Exception('Failed to parse response from api call')
 *         response.ParseFromString(response_str)             # <<<<<<<<<<<<<<
 *         return response
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_response, __pyx_n_s_ParseFromString); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1033, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_v_response_str); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1033, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1033, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "_redukti.pyx":1034
 *             raise Exception('Failed to parse response from api call')
 *         response.ParseFromString(response_str)
 *         return response             # <<<<<<<<<<<<<<
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_response);
  __pyx_r = __pyx_v_response;
  goto __pyx_L0;

  /* "_redukti.pyx":1011
 *             raise Exception('failed to create instance of InMemoryRequestProcessor')
 * 
 *     cpdef serve(self, request):             # <<<<<<<<<<<<<<
 *         """
 *         Simple request processing service, designed to be compatible with the OpenRedukti server protocol.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("_redukti.InMemoryRequestProcessor.serve", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_response);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_24InMemoryRequestProcessor_5serve(PyObject *__pyx_v_self, PyObject *__pyx_v_request); /*proto*/
static char __pyx_doc_8_redukti_24InMemoryRequestProcessor_4serve[] = "InMemoryRequestProcessor.serve(self, request)\n\n        Simple request processing service, designed to be compatible with the OpenRedukti server protocol.\n        Args:\n            request: Request to process, one of the sub requests must be populated\n        Returns:\n            The result from the request processor\n        ";
static PyObject *__pyx_pw_8_redukti_24InMemoryRequestProcessor_5serve(PyObject *__pyx_v_self, PyObject *__pyx_v_request) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("serve (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_24InMemoryRequestProcessor_4serve(((struct __pyx_obj_8_redukti_InMemoryRequestProcessor *)__pyx_v_self), ((PyObject *)__pyx_v_request));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_24InMemoryRequestProcessor_4serve(struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, PyObject *__pyx_v_request) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("serve", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_8_redukti_24InMemoryRequestProcessor_serve(__pyx_v_self, __pyx_v_request, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1011, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InMemoryRequestProcessor.serve", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_24InMemoryRequestProcessor_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_8_redukti_24InMemoryRequestProcessor_6__reduce_cython__[] = "InMemoryRequestProcessor.__reduce_cython__(self)";
static PyObject *__pyx_pw_8_redukti_24InMemoryRequestProcessor_7__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_24InMemoryRequestProcessor_6__reduce_cython__(((struct __pyx_obj_8_redukti_InMemoryRequestProcessor *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_24InMemoryRequestProcessor_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__68, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InMemoryRequestProcessor.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_24InMemoryRequestProcessor_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static char __pyx_doc_8_redukti_24InMemoryRequestProcessor_8__setstate_cython__[] = "InMemoryRequestProcessor.__setstate_cython__(self, __pyx_state)";
static PyObject *__pyx_pw_8_redukti_24InMemoryRequestProcessor_9__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_8_redukti_24InMemoryRequestProcessor_8__setstate_cython__(((struct __pyx_obj_8_redukti_InMemoryRequestProcessor *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_24InMemoryRequestProcessor_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_8_redukti_InMemoryRequestProcessor *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__69, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_redukti.InMemoryRequestProcessor.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __pyx_unpickle_ScheduleGenerator(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
 *     cdef object __pyx_PickleError
 *     cdef object __pyx_result
 */

/* Python wrapper */
static PyObject *__pyx_pw_8_redukti_3__pyx_unpickle_ScheduleGenerator(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8_redukti_2__pyx_unpickle_ScheduleGenerator[] = "__pyx_unpickle_ScheduleGenerator(__pyx_type, long __pyx_checksum, __pyx_state)";
static PyMethodDef __pyx_mdef_8_redukti_3__pyx_unpickle_ScheduleGenerator = {"__pyx_unpickle_ScheduleGenerator", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_3__pyx_unpickle_ScheduleGenerator, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_2__pyx_unpickle_ScheduleGenerator};
static PyObject *__pyx_pw_8_redukti_3__pyx_unpickle_ScheduleGenerator(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v___pyx_type = 0;
  long __pyx_v___pyx_checksum;
  PyObject *__pyx_v___pyx_state = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__pyx_unpickle_ScheduleGenerator (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_pyx_type,&__pyx_n_s_pyx_checksum,&__pyx_n_s_pyx_state,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_type)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_checksum)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_ScheduleGenerator", 1, 3, 3, 1); __PYX_ERR(1, 1, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_pyx_state)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_ScheduleGenerator", 1, 3, 3, 2); __PYX_ERR(1, 1, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__pyx_unpickle_ScheduleGenerator") < 0)) __PYX_ERR(1, 1, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v___pyx_type = values[0];
    __pyx_v___pyx_checksum = __Pyx_PyInt_As_long(values[1]); if (unlikely((__pyx_v___pyx_checksum == (long)-1) && PyErr_Occurred())) __PYX_ERR(1, 1, __pyx_L3_error)
    __pyx_v___pyx_state = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__pyx_unpickle_ScheduleGenerator", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(1, 1, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("_redukti.__pyx_unpickle_ScheduleGenerator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_8_redukti_2__pyx_unpickle_ScheduleGenerator(__pyx_self, __pyx_v___pyx_type, __pyx_v___pyx_checksum, __pyx_v___pyx_state);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_8_redukti_2__pyx_unpickle_ScheduleGenerator(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_v___pyx_PickleError = 0;
  PyObject *__pyx_v___pyx_result = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  __Pyx_RefNannySetupContext("__pyx_unpickle_ScheduleGenerator", 0);

  /* "(tree fragment)":4
 *     cdef object __pyx_PickleError
 *     cdef object __pyx_result
 *     if __pyx_checksum != 0xd41d8cd:             # <<<<<<<<<<<<<<
 *         from pickle import PickleError as __pyx_PickleError
 *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xd41d8cd = ())" % __pyx_checksum)
 */
  __pyx_t_1 = ((__pyx_v___pyx_checksum != 0xd41d8cd) != 0);
  if (__pyx_t_1) {

    /* "(tree fragment)":5
 *     cdef object __pyx_result
 *     if __pyx_checksum != 0xd41d8cd:
 *         from pickle import PickleError as __pyx_PickleError             # <<<<<<<<<<<<<<
 *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xd41d8cd = ())" % __pyx_checksum)
 *     __pyx_result = ScheduleGenerator.__new__(__pyx_type)
 */
    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_n_s_PickleError);
    __Pyx_GIVEREF(__pyx_n_s_PickleError);
    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError);
    __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_t_2);
    __pyx_v___pyx_PickleError = __pyx_t_2;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "(tree fragment)":6
 *     if __pyx_checksum != 0xd41d8cd:
 *         from pickle import PickleError as __pyx_PickleError
 *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xd41d8cd = ())" % __pyx_checksum)             # <<<<<<<<<<<<<<
 *     __pyx_result = ScheduleGenerator.__new__(__pyx_type)
 *     if __pyx_state is not None:
 */
    __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0xd4, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_INCREF(__pyx_v___pyx_PickleError);
    __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(1, 6, __pyx_L1_error)

    /* "(tree fragment)":4
 *     cdef object __pyx_PickleError
 *     cdef object __pyx_result
 *     if __pyx_checksum != 0xd41d8cd:             # <<<<<<<<<<<<<<
 *         from pickle import PickleError as __pyx_PickleError
 *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xd41d8cd = ())" % __pyx_checksum)
 */
  }

  /* "(tree fragment)":7
 *         from pickle import PickleError as __pyx_PickleError
 *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xd41d8cd = ())" % __pyx_checksum)
 *     __pyx_result = ScheduleGenerator.__new__(__pyx_type)             # <<<<<<<<<<<<<<
 *     if __pyx_state is not None:
 *         __pyx_unpickle_ScheduleGenerator__set_state(<ScheduleGenerator> __pyx_result, __pyx_state)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_8_redukti_ScheduleGenerator), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v___pyx_result = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "(tree fragment)":8
 *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xd41d8cd = ())" % __pyx_checksum)
 *     __pyx_result = ScheduleGenerator.__new__(__pyx_type)
 *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
 *         __pyx_unpickle_ScheduleGenerator__set_state(<ScheduleGenerator> __pyx_result, __pyx_state)
 *     return __pyx_result
 */
  __pyx_t_1 = (__pyx_v___pyx_state != Py_None);
  __pyx_t_6 = (__pyx_t_1 != 0);
  if (__pyx_t_6) {

    /* "(tree fragment)":9
 *     __pyx_result = ScheduleGenerator.__new__(__pyx_type)
 *     if __pyx_state is not None:
 *         __pyx_unpickle_ScheduleGenerator__set_state(<ScheduleGenerator> __pyx_result, __pyx_state)             # <<<<<<<<<<<<<<
 *     return __pyx_result
 * cdef __pyx_unpickle_ScheduleGenerator__set_state(ScheduleGenerator __pyx_result, tuple __pyx_state):
 */
    if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "tuple", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error)
    __pyx_t_3 = __pyx_f_8_redukti___pyx_unpickle_ScheduleGenerator__set_state(((struct __pyx_obj_8_redukti_ScheduleGenerator *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "(tree fragment)":8
 *         raise __pyx_PickleError("Incompatible checksums (%s vs 0xd41d8cd = ())" % __pyx_checksum)
 *     __pyx_result = ScheduleGenerator.__new__(__pyx_type)
 *     if __pyx_state is not None:             # <<<<<<<<<<<<<<
 *         __pyx_unpickle_ScheduleGenerator__set_state(<ScheduleGenerator> __pyx_result, __pyx_state)
 *     return __pyx_result
 */
  }

  /* "(tree fragment)":10
 *     if __pyx_state is not None:
 *         __pyx_unpickle_ScheduleGenerator__set_state(<ScheduleGenerator> __pyx_result, __pyx_state)
 *     return __pyx_result             # <<<<<<<<<<<<<<
 * cdef __pyx_unpickle_ScheduleGenerator__set_state(ScheduleGenerator __pyx_result, tuple __pyx_state):
 *     if len(__pyx_state) > 0 and hasattr(__pyx_result, '__dict__'):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v___pyx_result);
  __pyx_r = __pyx_v___pyx_result;
  goto __pyx_L0;

  /* "(tree fragment)":1
 * def __pyx_unpickle_ScheduleGenerator(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
 *     cdef object __pyx_PickleError
 *     cdef object __pyx_result
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("_redukti.__pyx_unpickle_ScheduleGenerator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v___pyx_PickleError);
  __Pyx_XDECREF(__pyx_v___pyx_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":11
 *         __pyx_unpickle_ScheduleGenerator__set_state(<ScheduleGenerator> __pyx_result, __pyx_state)
 *     return __pyx_result
 * cdef __pyx_unpickle_ScheduleGenerator__set_state(ScheduleGenerator __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
 *     if len(__pyx_state) > 0 and hasattr(__pyx_result, '__dict__'):
 *         __pyx_result.__dict__.update(__pyx_state[0])
 */

static PyObject *__pyx_f_8_redukti___pyx_unpickle_ScheduleGenerator__set_state(struct __pyx_obj_8_redukti_ScheduleGenerator *__pyx_v___pyx_result, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  Py_ssize_t __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("__pyx_unpickle_ScheduleGenerator__set_state", 0);

  /* "(tree fragment)":12
 *     return __pyx_result
 * cdef __pyx_unpickle_ScheduleGenerator__set_state(ScheduleGenerator __pyx_result, tuple __pyx_state):
 *     if len(__pyx_state) > 0 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
 *         __pyx_result.__dict__.update(__pyx_state[0])
 */
  if (unlikely(__pyx_v___pyx_state == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(1, 12, __pyx_L1_error)
  }
  __pyx_t_2 = PyTuple_GET_SIZE(__pyx_v___pyx_state); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(1, 12, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_2 > 0) != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = __Pyx_HasAttr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(1, 12, __pyx_L1_error)
  __pyx_t_4 = (__pyx_t_3 != 0);
  __pyx_t_1 = __pyx_t_4;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "(tree fragment)":13
 * cdef __pyx_unpickle_ScheduleGenerator__set_state(ScheduleGenerator __pyx_result, tuple __pyx_state):
 *     if len(__pyx_state) > 0 and hasattr(__pyx_result, '__dict__'):
 *         __pyx_result.__dict__.update(__pyx_state[0])             # <<<<<<<<<<<<<<
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v___pyx_result), __pyx_n_s_dict); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 13, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_update); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 13, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(__pyx_v___pyx_state == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(1, 13, __pyx_L1_error)
    }
    __pyx_t_6 = __Pyx_GetItemInt_Tuple(__pyx_v___pyx_state, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(1, 13, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 13, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "(tree fragment)":12
 *     return __pyx_result
 * cdef __pyx_unpickle_ScheduleGenerator__set_state(ScheduleGenerator __pyx_result, tuple __pyx_state):
 *     if len(__pyx_state) > 0 and hasattr(__pyx_result, '__dict__'):             # <<<<<<<<<<<<<<
 *         __pyx_result.__dict__.update(__pyx_state[0])
 */
  }

  /* "(tree fragment)":11
 *         __pyx_unpickle_ScheduleGenerator__set_state(<ScheduleGenerator> __pyx_result, __pyx_state)
 *     return __pyx_result
 * cdef __pyx_unpickle_ScheduleGenerator__set_state(ScheduleGenerator __pyx_result, tuple __pyx_state):             # <<<<<<<<<<<<<<
 *     if len(__pyx_state) > 0 and hasattr(__pyx_result, '__dict__'):
 *         __pyx_result.__dict__.update(__pyx_state[0])
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("_redukti.__pyx_unpickle_ScheduleGenerator__set_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":93
 *             __data_union data
 * 
 *         def __getbuffer__(self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fulfill the PEP.
 */

/* Python wrapper */
static CYTHON_UNUSED int __pyx_pw_7cpython_5array_5array_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
static CYTHON_UNUSED int __pyx_pw_7cpython_5array_5array_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7cpython_5array_5array___getbuffer__(((arrayobject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7cpython_5array_5array___getbuffer__(arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info, CYTHON_UNUSED int __pyx_v_flags) {
  PyObject *__pyx_v_item_count = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  char *__pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  int __pyx_t_6;
  char __pyx_t_7;
  if (__pyx_v_info == NULL) {
    PyErr_SetString(PyExc_BufferError, "PyObject_GetBuffer: view==NULL argument is obsolete");
    return -1;
  }
  __Pyx_RefNannySetupContext("__getbuffer__", 0);
  __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(__pyx_v_info->obj);

  /* "array.pxd":98
 *             # In particular strided access is always provided regardless
 *             # of flags
 *             item_count = Py_SIZE(self)             # <<<<<<<<<<<<<<
 * 
 *             info.suboffsets = NULL
 */
  __pyx_t_1 = PyInt_FromSsize_t(Py_SIZE(((PyObject *)__pyx_v_self))); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 98, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_item_count = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "array.pxd":100
 *             item_count = Py_SIZE(self)
 * 
 *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
 *             info.buf = self.data.as_chars
 *             info.readonly = 0
 */
  __pyx_v_info->suboffsets = NULL;

  /* "array.pxd":101
 * 
 *             info.suboffsets = NULL
 *             info.buf = self.data.as_chars             # <<<<<<<<<<<<<<
 *             info.readonly = 0
 *             info.ndim = 1
 */
  __pyx_t_2 = __pyx_v_self->data.as_chars;
  __pyx_v_info->buf = __pyx_t_2;

  /* "array.pxd":102
 *             info.suboffsets = NULL
 *             info.buf = self.data.as_chars
 *             info.readonly = 0             # <<<<<<<<<<<<<<
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 */
  __pyx_v_info->readonly = 0;

  /* "array.pxd":103
 *             info.buf = self.data.as_chars
 *             info.readonly = 0
 *             info.ndim = 1             # <<<<<<<<<<<<<<
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 *             info.len = info.itemsize * item_count
 */
  __pyx_v_info->ndim = 1;

  /* "array.pxd":104
 *             info.readonly = 0
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)             # <<<<<<<<<<<<<<
 *             info.len = info.itemsize * item_count
 * 
 */
  __pyx_t_3 = __pyx_v_self->ob_descr->itemsize;
  __pyx_v_info->itemsize = __pyx_t_3;

  /* "array.pxd":105
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 *             info.len = info.itemsize * item_count             # <<<<<<<<<<<<<<
 * 
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)
 */
  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_info->itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 105, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyNumber_Multiply(__pyx_t_1, __pyx_v_item_count); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 105, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __Pyx_PyIndex_AsSsize_t(__pyx_t_4); if (unlikely((__pyx_t_5 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 105, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_info->len = __pyx_t_5;

  /* "array.pxd":107
 *             info.len = info.itemsize * item_count
 * 
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)             # <<<<<<<<<<<<<<
 *             if not info.shape:
 *                 raise MemoryError()
 */
  __pyx_v_info->shape = ((Py_ssize_t *)PyObject_Malloc(((sizeof(Py_ssize_t)) + 2)));

  /* "array.pxd":108
 * 
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)
 *             if not info.shape:             # <<<<<<<<<<<<<<
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing
 */
  __pyx_t_6 = ((!(__pyx_v_info->shape != 0)) != 0);
  if (unlikely(__pyx_t_6)) {

    /* "array.pxd":109
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)
 *             if not info.shape:
 *                 raise MemoryError()             # <<<<<<<<<<<<<<
 *             info.shape[0] = item_count      # constant regardless of resizing
 *             info.strides = &info.itemsize
 */
    PyErr_NoMemory(); __PYX_ERR(2, 109, __pyx_L1_error)

    /* "array.pxd":108
 * 
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)
 *             if not info.shape:             # <<<<<<<<<<<<<<
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing
 */
  }

  /* "array.pxd":110
 *             if not info.shape:
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing             # <<<<<<<<<<<<<<
 *             info.strides = &info.itemsize
 * 
 */
  __pyx_t_5 = __Pyx_PyIndex_AsSsize_t(__pyx_v_item_count); if (unlikely((__pyx_t_5 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 110, __pyx_L1_error)
  (__pyx_v_info->shape[0]) = __pyx_t_5;

  /* "array.pxd":111
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing
 *             info.strides = &info.itemsize             # <<<<<<<<<<<<<<
 * 
 *             info.format = <char*> (info.shape + 1)
 */
  __pyx_v_info->strides = (&__pyx_v_info->itemsize);

  /* "array.pxd":113
 *             info.strides = &info.itemsize
 * 
 *             info.format = <char*> (info.shape + 1)             # <<<<<<<<<<<<<<
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0
 */
  __pyx_v_info->format = ((char *)(__pyx_v_info->shape + 1));

  /* "array.pxd":114
 * 
 *             info.format = <char*> (info.shape + 1)
 *             info.format[0] = self.ob_descr.typecode             # <<<<<<<<<<<<<<
 *             info.format[1] = 0
 *             info.obj = self
 */
  __pyx_t_7 = __pyx_v_self->ob_descr->typecode;
  (__pyx_v_info->format[0]) = __pyx_t_7;

  /* "array.pxd":115
 *             info.format = <char*> (info.shape + 1)
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0             # <<<<<<<<<<<<<<
 *             info.obj = self
 * 
 */
  (__pyx_v_info->format[1]) = 0;

  /* "array.pxd":116
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0
 *             info.obj = self             # <<<<<<<<<<<<<<
 * 
 *         def __releasebuffer__(self, Py_buffer* info):
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  __Pyx_GOTREF(__pyx_v_info->obj);
  __Pyx_DECREF(__pyx_v_info->obj);
  __pyx_v_info->obj = ((PyObject *)__pyx_v_self);

  /* "array.pxd":93
 *             __data_union data
 * 
 *         def __getbuffer__(self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fulfill the PEP.
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("cpython.array.array.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  if (__pyx_v_info->obj != NULL) {
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
  }
  goto __pyx_L2;
  __pyx_L0:;
  if (__pyx_v_info->obj == Py_None) {
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = 0;
  }
  __pyx_L2:;
  __Pyx_XDECREF(__pyx_v_item_count);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":118
 *             info.obj = self
 * 
 *         def __releasebuffer__(self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             PyObject_Free(info.shape)
 * 
 */

/* Python wrapper */
static CYTHON_UNUSED void __pyx_pw_7cpython_5array_5array_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
static CYTHON_UNUSED void __pyx_pw_7cpython_5array_5array_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__ (wrapper)", 0);
  __pyx_pf_7cpython_5array_5array_2__releasebuffer__(((arrayobject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7cpython_5array_5array_2__releasebuffer__(CYTHON_UNUSED arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__", 0);

  /* "array.pxd":119
 * 
 *         def __releasebuffer__(self, Py_buffer* info):
 *             PyObject_Free(info.shape)             # <<<<<<<<<<<<<<
 * 
 *     array newarrayobject(PyTypeObject* type, Py_ssize_t size, arraydescr *descr)
 */
  PyObject_Free(__pyx_v_info->shape);

  /* "array.pxd":118
 *             info.obj = self
 * 
 *         def __releasebuffer__(self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             PyObject_Free(info.shape)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "array.pxd":130
 * 
 * 
 * cdef inline array clone(array template, Py_ssize_t length, bint zero):             # <<<<<<<<<<<<<<
 *     """ fast creation of a new array, given a template array.
 *     type will be same as template.
 */

static CYTHON_INLINE arrayobject *__pyx_f_7cpython_5array_clone(arrayobject *__pyx_v_template, Py_ssize_t __pyx_v_length, int __pyx_v_zero) {
  arrayobject *__pyx_v_op = NULL;
  arrayobject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("clone", 0);

  /* "array.pxd":134
 *     type will be same as template.
 *     if zero is true, new array will be initialized with zeroes."""
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)             # <<<<<<<<<<<<<<
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 */
  __pyx_t_1 = ((PyObject *)newarrayobject(Py_TYPE(((PyObject *)__pyx_v_template)), __pyx_v_length, __pyx_v_template->ob_descr)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 134, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_op = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "array.pxd":135
 *     if zero is true, new array will be initialized with zeroes."""
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)
 *     if zero and op is not None:             # <<<<<<<<<<<<<<
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 *     return op
 */
  __pyx_t_3 = (__pyx_v_zero != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_2 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = (((PyObject *)__pyx_v_op) != Py_None);
  __pyx_t_4 = (__pyx_t_3 != 0);
  __pyx_t_2 = __pyx_t_4;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_2) {

    /* "array.pxd":136
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 *     return op
 * 
 */
    (void)(memset(__pyx_v_op->data.as_chars, 0, (__pyx_v_length * __pyx_v_op->ob_descr->itemsize)));

    /* "array.pxd":135
 *     if zero is true, new array will be initialized with zeroes."""
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)
 *     if zero and op is not None:             # <<<<<<<<<<<<<<
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 *     return op
 */
  }

  /* "array.pxd":137
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 *     return op             # <<<<<<<<<<<<<<
 * 
 * cdef inline array copy(array self):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_op));
  __pyx_r = __pyx_v_op;
  goto __pyx_L0;

  /* "array.pxd":130
 * 
 * 
 * cdef inline array clone(array template, Py_ssize_t length, bint zero):             # <<<<<<<<<<<<<<
 *     """ fast creation of a new array, given a template array.
 *     type will be same as template.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.array.clone", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_op);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":139
 *     return op
 * 
 * cdef inline array copy(array self):             # <<<<<<<<<<<<<<
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 */

static CYTHON_INLINE arrayobject *__pyx_f_7cpython_5array_copy(arrayobject *__pyx_v_self) {
  arrayobject *__pyx_v_op = NULL;
  arrayobject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("copy", 0);

  /* "array.pxd":141
 * cdef inline array copy(array self):
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)             # <<<<<<<<<<<<<<
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)
 *     return op
 */
  __pyx_t_1 = ((PyObject *)newarrayobject(Py_TYPE(((PyObject *)__pyx_v_self)), Py_SIZE(((PyObject *)__pyx_v_self)), __pyx_v_self->ob_descr)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 141, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_op = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "array.pxd":142
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 *     return op
 * 
 */
  (void)(memcpy(__pyx_v_op->data.as_chars, __pyx_v_self->data.as_chars, (Py_SIZE(((PyObject *)__pyx_v_op)) * __pyx_v_op->ob_descr->itemsize)));

  /* "array.pxd":143
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)
 *     return op             # <<<<<<<<<<<<<<
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_op));
  __pyx_r = __pyx_v_op;
  goto __pyx_L0;

  /* "array.pxd":139
 *     return op
 * 
 * cdef inline array copy(array self):             # <<<<<<<<<<<<<<
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.array.copy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_op);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":145
 *     return op
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:             # <<<<<<<<<<<<<<
 *     """ efficient appending of new stuff of same type
 *     (e.g. of same array type)
 */

static CYTHON_INLINE int __pyx_f_7cpython_5array_extend_buffer(arrayobject *__pyx_v_self, char *__pyx_v_stuff, Py_ssize_t __pyx_v_n) {
  Py_ssize_t __pyx_v_itemsize;
  Py_ssize_t __pyx_v_origsize;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("extend_buffer", 0);

  /* "array.pxd":149
 *     (e.g. of same array type)
 *     n: number of elements (not number of bytes!) """
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)
 */
  __pyx_t_1 = __pyx_v_self->ob_descr->itemsize;
  __pyx_v_itemsize = __pyx_t_1;

  /* "array.pxd":150
 *     n: number of elements (not number of bytes!) """
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize
 *     cdef Py_ssize_t origsize = Py_SIZE(self)             # <<<<<<<<<<<<<<
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 */
  __pyx_v_origsize = Py_SIZE(((PyObject *)__pyx_v_self));

  /* "array.pxd":151
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)             # <<<<<<<<<<<<<<
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 *     return 0
 */
  __pyx_t_1 = resize_smart(__pyx_v_self, (__pyx_v_origsize + __pyx_v_n)); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 151, __pyx_L1_error)

  /* "array.pxd":152
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)             # <<<<<<<<<<<<<<
 *     return 0
 * 
 */
  (void)(memcpy((__pyx_v_self->data.as_chars + (__pyx_v_origsize * __pyx_v_itemsize)), __pyx_v_stuff, (__pyx_v_n * __pyx_v_itemsize)));

  /* "array.pxd":153
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 *     return 0             # <<<<<<<<<<<<<<
 * 
 * cdef inline int extend(array self, array other) except -1:
 */
  __pyx_r = 0;
  goto __pyx_L0;

  /* "array.pxd":145
 *     return op
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:             # <<<<<<<<<<<<<<
 *     """ efficient appending of new stuff of same type
 *     (e.g. of same array type)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("cpython.array.extend_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":155
 *     return 0
 * 
 * cdef inline int extend(array self, array other) except -1:             # <<<<<<<<<<<<<<
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 */

static CYTHON_INLINE int __pyx_f_7cpython_5array_extend(arrayobject *__pyx_v_self, arrayobject *__pyx_v_other) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("extend", 0);

  /* "array.pxd":157
 * cdef inline int extend(array self, array other) except -1:
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:             # <<<<<<<<<<<<<<
 *         PyErr_BadArgument()
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 */
  __pyx_t_1 = ((__pyx_v_self->ob_descr->typecode != __pyx_v_other->ob_descr->typecode) != 0);
  if (__pyx_t_1) {

    /* "array.pxd":158
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 *         PyErr_BadArgument()             # <<<<<<<<<<<<<<
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 */
    __pyx_t_2 = PyErr_BadArgument(); if (unlikely(__pyx_t_2 == ((int)0))) __PYX_ERR(2, 158, __pyx_L1_error)

    /* "array.pxd":157
 * cdef inline int extend(array self, array other) except -1:
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:             # <<<<<<<<<<<<<<
 *         PyErr_BadArgument()
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 */
  }

  /* "array.pxd":159
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 *         PyErr_BadArgument()
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))             # <<<<<<<<<<<<<<
 * 
 * cdef inline void zero(array self):
 */
  __pyx_t_2 = __pyx_f_7cpython_5array_extend_buffer(__pyx_v_self, __pyx_v_other->data.as_chars, Py_SIZE(((PyObject *)__pyx_v_other))); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(2, 159, __pyx_L1_error)
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  /* "array.pxd":155
 *     return 0
 * 
 * cdef inline int extend(array self, array other) except -1:             # <<<<<<<<<<<<<<
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("cpython.array.extend", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":161
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 * cdef inline void zero(array self):             # <<<<<<<<<<<<<<
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)
 */

static CYTHON_INLINE void __pyx_f_7cpython_5array_zero(arrayobject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("zero", 0);

  /* "array.pxd":163
 * cdef inline void zero(array self):
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 */
  (void)(memset(__pyx_v_self->data.as_chars, 0, (Py_SIZE(((PyObject *)__pyx_v_self)) * __pyx_v_self->ob_descr->itemsize)));

  /* "array.pxd":161
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 * cdef inline void zero(array self):             # <<<<<<<<<<<<<<
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_std__in_string")
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
  Py_ssize_t __pyx_v_length;
  char const *__pyx_v_data;
  std::string __pyx_r;
  __Pyx_RefNannyDeclarations
  char const *__pyx_t_1;
  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);

  /* "string.from_py":15
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
 *     cdef Py_ssize_t length
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
 *     return string(data, length)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
  __pyx_v_data = __pyx_t_1;

  /* "string.from_py":16
 *     cdef Py_ssize_t length
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 *     return string(data, length)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
  goto __pyx_L0;

  /* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_std__in_string")
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_pretend_to_initialize(&__pyx_r);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":31
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__in_string", 0);

  /* "string.to_py":32
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyUnicode_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":31
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__in_string", 0);

  /* "string.to_py":38
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyStr_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 38, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":43
 * 
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyStr_string_to_py_std__in_string", 0);

  /* "string.to_py":44
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyBytes_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyStr_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 44, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":43
 * 
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":49
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__in_string", 0);

  /* "string.to_py":50
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyByteArray_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 50, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":49
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__in_string", 0);

  /* "string.to_py":56
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyByteArray_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 56, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static struct __pyx_vtabstruct_8_redukti_ADVar __pyx_vtable_8_redukti_ADVar;

static PyObject *__pyx_tp_new_8_redukti_ADVar(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_ADVar *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_ADVar *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_ADVar;
  if (unlikely(__pyx_pw_8_redukti_5ADVar_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_ADVar(PyObject *o) {
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_8_redukti_5ADVar_5__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_ADVar[] = {
  {"assign", (PyCFunction)__pyx_pw_8_redukti_5ADVar_7assign, METH_O, __pyx_doc_8_redukti_5ADVar_6assign},
  {"value", (PyCFunction)__pyx_pw_8_redukti_5ADVar_9value, METH_NOARGS, __pyx_doc_8_redukti_5ADVar_8value},
  {"gradient", (PyCFunction)__pyx_pw_8_redukti_5ADVar_11gradient, METH_NOARGS, __pyx_doc_8_redukti_5ADVar_10gradient},
  {"hessian", (PyCFunction)__pyx_pw_8_redukti_5ADVar_13hessian, METH_NOARGS, __pyx_doc_8_redukti_5ADVar_12hessian},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_5ADVar_15__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_5ADVar_14__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_5ADVar_17__setstate_cython__, METH_O, __pyx_doc_8_redukti_5ADVar_16__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_ADVar = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.ADVar", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_ADVar), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_ADVar, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "ADVar(int n_vars, int order, int variable, double initial_value)\n\n    ADVar represents an automatically differentiated variable.\n\n    An ADVar object contains a numeric value, but additionally it may\n    contain a gradient vector and a 2-dimensional hessian matrix. \n\n    Each ADVar object has a variable id which must be unique within the\n    context of a calculation. Variable ids start with ``0``, and if there are 3 variables\n    in a calculation, then the variables would have ids ``0``, ``1``, and ``2``.\n\n    Note that all ADVars in a calculation must have the same number size and order.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_ADVar, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_5ADVar_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_ADVar, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_Date __pyx_vtable_8_redukti_Date;

static PyObject *__pyx_tp_new_8_redukti_Date(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_Date *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_Date *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_Date;
  if (unlikely(__pyx_pw_8_redukti_4Date_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_Date(PyObject *o) {
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_Date[] = {
  {"day", (PyCFunction)__pyx_pw_8_redukti_4Date_5day, METH_NOARGS, __pyx_doc_8_redukti_4Date_4day},
  {"month", (PyCFunction)__pyx_pw_8_redukti_4Date_7month, METH_NOARGS, __pyx_doc_8_redukti_4Date_6month},
  {"year", (PyCFunction)__pyx_pw_8_redukti_4Date_9year, METH_NOARGS, __pyx_doc_8_redukti_4Date_8year},
  {"serial", (PyCFunction)__pyx_pw_8_redukti_4Date_11serial, METH_NOARGS, __pyx_doc_8_redukti_4Date_10serial},
  {"dmy", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_4Date_13dmy, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_4Date_12dmy},
  {"advance", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_4Date_15advance, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_4Date_14advance},
  {"parse", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_4Date_17parse, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_4Date_16parse},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_4Date_19__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_4Date_18__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_4Date_21__setstate_cython__, METH_O, __pyx_doc_8_redukti_4Date_20__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_Date = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.Date", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_Date), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_Date, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Date(int value)\n\n    Holds a date value as the number of days since civil 1899-12-31.\n\n    Negative values indicate days prior to 1899-12-31.\n    Note that OpenRedukti requires dates to be in the range ``1901-01-01`` and ``2199-12-31``.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_Date, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_4Date_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_Date, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};

static PyObject *__pyx_tp_new_8_redukti_ScheduleGenerator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  return o;
}

static void __pyx_tp_dealloc_8_redukti_ScheduleGenerator(PyObject *o) {
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_ScheduleGenerator[] = {
  {"generate_schedule", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_17ScheduleGenerator_1generate_schedule, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_17ScheduleGenerator_generate_schedule},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_17ScheduleGenerator_3__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_17ScheduleGenerator_2__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_17ScheduleGenerator_5__setstate_cython__, METH_O, __pyx_doc_8_redukti_17ScheduleGenerator_4__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_ScheduleGenerator = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.ScheduleGenerator", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_ScheduleGenerator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_ScheduleGenerator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    Utilities for generating schedules for interest rate products.\n    The algorithm is based upon the FpML specifications.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_ScheduleGenerator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_ScheduleGenerator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_Calendar __pyx_vtable_8_redukti_Calendar;

static PyObject *__pyx_tp_new_8_redukti_Calendar(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_Calendar *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_Calendar *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_Calendar;
  if (unlikely(__pyx_pw_8_redukti_8Calendar_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_Calendar(PyObject *o) {
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_Calendar[] = {
  {"is_holiday", (PyCFunction)__pyx_pw_8_redukti_8Calendar_5is_holiday, METH_O, __pyx_doc_8_redukti_8Calendar_4is_holiday},
  {"last_day_of_month", (PyCFunction)__pyx_pw_8_redukti_8Calendar_7last_day_of_month, METH_O, __pyx_doc_8_redukti_8Calendar_6last_day_of_month},
  {"advance", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_8Calendar_9advance, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_8Calendar_8advance},
  {"adjust", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_8Calendar_11adjust, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_8Calendar_10adjust},
  {"register_calendar", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_8Calendar_13register_calendar, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_8Calendar_12register_calendar},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_8Calendar_15__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_8Calendar_14__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_8Calendar_17__setstate_cython__, METH_O, __pyx_doc_8_redukti_8Calendar_16__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_Calendar = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.Calendar", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_Calendar), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_Calendar, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "Calendar(list business_centres)\n\n    Represents a Business/Holiday Calendar for a business center or a combination of business centers.\n\n    The Calendar interface provides the means to determine whether\n    a given date is a holiday for a business center or not. Also\n    the interface provides methods for adjusting dates as per the\n    holiday calendar.\n    \n    Calendar instances are immutable.\n\n    Currently in-built business centers are ``AUSY``, ``USNY``, ``GBLO``, ``EUTA``, ``JPTO`` and ``BRSP``\n    Calendars can be overridden or added for other business centers using the ``register_calendar()`` method\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_Calendar, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_8Calendar_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_Calendar, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_DayFraction __pyx_vtable_8_redukti_DayFraction;

static PyObject *__pyx_tp_new_8_redukti_DayFraction(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_DayFraction *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_DayFraction *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_DayFraction;
  if (unlikely(__pyx_pw_8_redukti_11DayFraction_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_DayFraction(PyObject *o) {
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_DayFraction[] = {
  {"year_fraction", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_11DayFraction_5year_fraction, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_11DayFraction_4year_fraction},
  {"year_fraction_with_finalperiod", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_11DayFraction_7year_fraction_with_finalperiod, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_11DayFraction_6year_fraction_with_finalperiod},
  {"year_fraction_with_refdates", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_11DayFraction_9year_fraction_with_refdates, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_11DayFraction_8year_fraction_with_refdates},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_11DayFraction_11__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_11DayFraction_10__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_11DayFraction_13__setstate_cython__, METH_O, __pyx_doc_8_redukti_11DayFraction_12__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_DayFraction = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.DayFraction", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_DayFraction), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_DayFraction, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "DayFraction(DayCountFraction dfc)\n\n    Day Count Fraction calculator.\n\n    Computes the difference between dates as per Day Count Convention.\n    The difference is measured in factional units of a year, where one year 1.0.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_DayFraction, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_11DayFraction_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_DayFraction, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_InterestRateIndex __pyx_vtable_8_redukti_InterestRateIndex;

static PyObject *__pyx_tp_new_8_redukti_InterestRateIndex(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_8_redukti_InterestRateIndex *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_InterestRateIndex *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_InterestRateIndex;
  if (unlikely(__pyx_pw_8_redukti_17InterestRateIndex_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_InterestRateIndex(PyObject *o) {
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_InterestRateIndex[] = {
  {"get_index_by_isdaindex", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_17InterestRateIndex_3get_index_by_isdaindex, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_17InterestRateIndex_2get_index_by_isdaindex},
  {"get_index", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_17InterestRateIndex_5get_index, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_17InterestRateIndex_4get_index},
  {"value_date", (PyCFunction)__pyx_pw_8_redukti_17InterestRateIndex_7value_date, METH_O, __pyx_doc_8_redukti_17InterestRateIndex_6value_date},
  {"fixing_date", (PyCFunction)__pyx_pw_8_redukti_17InterestRateIndex_9fixing_date, METH_O, __pyx_doc_8_redukti_17InterestRateIndex_8fixing_date},
  {"maturity_date", (PyCFunction)__pyx_pw_8_redukti_17InterestRateIndex_11maturity_date, METH_O, __pyx_doc_8_redukti_17InterestRateIndex_10maturity_date},
  {"date_components", (PyCFunction)__pyx_pw_8_redukti_17InterestRateIndex_13date_components, METH_O, __pyx_doc_8_redukti_17InterestRateIndex_12date_components},
  {"adjust_date", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_17InterestRateIndex_15adjust_date, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_17InterestRateIndex_14adjust_date},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_17InterestRateIndex_17__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_17InterestRateIndex_16__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_17InterestRateIndex_19__setstate_cython__, METH_O, __pyx_doc_8_redukti_17InterestRateIndex_18__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_InterestRateIndex = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.InterestRateIndex", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_InterestRateIndex), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_InterestRateIndex, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    An interest rate index representation.\n    \n    An object of this type is immutable.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_InterestRateIndex, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_InterestRateIndex, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_Interpolator __pyx_vtable_8_redukti_Interpolator;

static PyObject *__pyx_tp_new_8_redukti_Interpolator(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_Interpolator *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_Interpolator *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_Interpolator;
  p->_x = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  p->_y = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_8_redukti_12Interpolator_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_Interpolator(PyObject *o) {
  struct __pyx_obj_8_redukti_Interpolator *p = (struct __pyx_obj_8_redukti_Interpolator *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_8_redukti_12Interpolator_5__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->_x);
  Py_CLEAR(p->_y);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_8_redukti_Interpolator(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_8_redukti_Interpolator *p = (struct __pyx_obj_8_redukti_Interpolator *)o;
  if (p->_x) {
    e = (*v)(((PyObject *)p->_x), a); if (e) return e;
  }
  if (p->_y) {
    e = (*v)(((PyObject *)p->_y), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_8_redukti_Interpolator(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_8_redukti_Interpolator *p = (struct __pyx_obj_8_redukti_Interpolator *)o;
  tmp = ((PyObject*)p->_x);
  p->_x = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->_y);
  p->_y = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_8_redukti_Interpolator[] = {
  {"interpolate", (PyCFunction)__pyx_pw_8_redukti_12Interpolator_7interpolate, METH_O, __pyx_doc_8_redukti_12Interpolator_6interpolate},
  {"interpolate_with_sensitivities", (PyCFunction)__pyx_pw_8_redukti_12Interpolator_9interpolate_with_sensitivities, METH_O, __pyx_doc_8_redukti_12Interpolator_8interpolate_with_sensitivities},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_12Interpolator_11__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_12Interpolator_10__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_12Interpolator_13__setstate_cython__, METH_O, __pyx_doc_8_redukti_12Interpolator_12__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_Interpolator = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.Interpolator", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_Interpolator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_Interpolator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "Interpolator(InterpolatorType interpolator_type, array x, array y, int order=0)\n\n    An Interpolator computes values between ranges based upon an interpolation method.\n\n    Several methods are supported.\n    Interpolators can not only interpolate values, but also compute sensitivities to the\n    fixed points in the x-axis.\n\n    Note that the Interpolators operate on the arrays supplied by the user; these\n    are not copied. Since some interpolators pre-compute data, if the underlying arrays\n    change these changes will not be reflected hence please do not change the input arrays.\n\n    TODO prevent extrapolation\n    ", /*tp_doc*/
  __pyx_tp_traverse_8_redukti_Interpolator, /*tp_traverse*/
  __pyx_tp_clear_8_redukti_Interpolator, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_Interpolator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_12Interpolator_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_Interpolator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_CurveId __pyx_vtable_8_redukti_CurveId;

static PyObject *__pyx_tp_new_8_redukti_CurveId(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_CurveId *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_CurveId *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_CurveId;
  if (unlikely(__pyx_pw_8_redukti_7CurveId_1__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_CurveId(PyObject *o) {
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_CurveId[] = {
  {"id", (PyCFunction)__pyx_pw_8_redukti_7CurveId_3id, METH_NOARGS, __pyx_doc_8_redukti_7CurveId_2id},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_7CurveId_5__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_7CurveId_4__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_7CurveId_7__setstate_cython__, METH_O, __pyx_doc_8_redukti_7CurveId_6__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_CurveId = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.CurveId", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_CurveId), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_CurveId, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_CurveId, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_CurveId, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_InterpolatedYieldCurve __pyx_vtable_8_redukti_InterpolatedYieldCurve;

static PyObject *__pyx_tp_new_8_redukti_InterpolatedYieldCurve(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_InterpolatedYieldCurve *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_InterpolatedYieldCurve;
  p->_maturities = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  p->_values = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_8_redukti_22InterpolatedYieldCurve_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_InterpolatedYieldCurve(PyObject *o) {
  struct __pyx_obj_8_redukti_InterpolatedYieldCurve *p = (struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_8_redukti_22InterpolatedYieldCurve_5__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->_maturities);
  Py_CLEAR(p->_values);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_8_redukti_InterpolatedYieldCurve(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_8_redukti_InterpolatedYieldCurve *p = (struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)o;
  if (p->_maturities) {
    e = (*v)(((PyObject *)p->_maturities), a); if (e) return e;
  }
  if (p->_values) {
    e = (*v)(((PyObject *)p->_values), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_8_redukti_InterpolatedYieldCurve(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_8_redukti_InterpolatedYieldCurve *p = (struct __pyx_obj_8_redukti_InterpolatedYieldCurve *)o;
  tmp = ((PyObject*)p->_maturities);
  p->_maturities = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->_values);
  p->_values = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_8_redukti_InterpolatedYieldCurve[] = {
  {"discount", (PyCFunction)__pyx_pw_8_redukti_22InterpolatedYieldCurve_7discount, METH_O, __pyx_doc_8_redukti_22InterpolatedYieldCurve_6discount},
  {"zero_rate", (PyCFunction)__pyx_pw_8_redukti_22InterpolatedYieldCurve_9zero_rate, METH_O, __pyx_doc_8_redukti_22InterpolatedYieldCurve_8zero_rate},
  {"forward_rate", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_22InterpolatedYieldCurve_11forward_rate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_22InterpolatedYieldCurve_10forward_rate},
  {"time_from_reference", (PyCFunction)__pyx_pw_8_redukti_22InterpolatedYieldCurve_13time_from_reference, METH_O, __pyx_doc_8_redukti_22InterpolatedYieldCurve_12time_from_reference},
  {"get_sensitivities", (PyCFunction)__pyx_pw_8_redukti_22InterpolatedYieldCurve_15get_sensitivities, METH_O, __pyx_doc_8_redukti_22InterpolatedYieldCurve_14get_sensitivities},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_22InterpolatedYieldCurve_17__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_22InterpolatedYieldCurve_16__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_22InterpolatedYieldCurve_19__setstate_cython__, METH_O, __pyx_doc_8_redukti_22InterpolatedYieldCurve_18__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_InterpolatedYieldCurve = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.InterpolatedYieldCurve", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_InterpolatedYieldCurve), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_InterpolatedYieldCurve, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "InterpolatedYieldCurve(long long id, Date as_of_date, list maturities, list values, InterpolatorType interpolator_type, IRRateType rate_type, int deriv_order, DayCountFraction fraction)\n\n    YieldCurve that operates on top of an interpolator.\n\n    The curve can interpolate on discount factors or zero rates, except for \n    ``MonotoneConvex`` which can only interpolate on zero rates.\n    ", /*tp_doc*/
  __pyx_tp_traverse_8_redukti_InterpolatedYieldCurve, /*tp_traverse*/
  __pyx_tp_clear_8_redukti_InterpolatedYieldCurve, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_InterpolatedYieldCurve, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_22InterpolatedYieldCurve_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_InterpolatedYieldCurve, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_SvenssonCurve __pyx_vtable_8_redukti_SvenssonCurve;

static PyObject *__pyx_tp_new_8_redukti_SvenssonCurve(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_SvenssonCurve *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_SvenssonCurve *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_SvenssonCurve;
  p->_parameters = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_8_redukti_13SvenssonCurve_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_SvenssonCurve(PyObject *o) {
  struct __pyx_obj_8_redukti_SvenssonCurve *p = (struct __pyx_obj_8_redukti_SvenssonCurve *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_8_redukti_13SvenssonCurve_5__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->_parameters);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_8_redukti_SvenssonCurve(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_8_redukti_SvenssonCurve *p = (struct __pyx_obj_8_redukti_SvenssonCurve *)o;
  if (p->_parameters) {
    e = (*v)(((PyObject *)p->_parameters), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_8_redukti_SvenssonCurve(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_8_redukti_SvenssonCurve *p = (struct __pyx_obj_8_redukti_SvenssonCurve *)o;
  tmp = ((PyObject*)p->_parameters);
  p->_parameters = ((arrayobject *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_8_redukti_SvenssonCurve[] = {
  {"discount", (PyCFunction)__pyx_pw_8_redukti_13SvenssonCurve_7discount, METH_O, __pyx_doc_8_redukti_13SvenssonCurve_6discount},
  {"zero_rate", (PyCFunction)__pyx_pw_8_redukti_13SvenssonCurve_9zero_rate, METH_O, __pyx_doc_8_redukti_13SvenssonCurve_8zero_rate},
  {"forward_rate", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_13SvenssonCurve_11forward_rate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_13SvenssonCurve_10forward_rate},
  {"time_from_reference", (PyCFunction)__pyx_pw_8_redukti_13SvenssonCurve_13time_from_reference, METH_O, __pyx_doc_8_redukti_13SvenssonCurve_12time_from_reference},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_13SvenssonCurve_15__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_13SvenssonCurve_14__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_13SvenssonCurve_17__setstate_cython__, METH_O, __pyx_doc_8_redukti_13SvenssonCurve_16__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_SvenssonCurve = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.SvenssonCurve", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_SvenssonCurve), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_SvenssonCurve, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "SvenssonCurve(long long id, Date as_of_date, list parameters, DayCountFraction fraction)\n\n    Svensson YieldCurve - this is a parametric yield curve.\n\n    This parametric yield curve computes rates using a formula that uses six parameters.\n    For details please check documents on Svensson Yield curve.\n\n    As this is a parametric curve, it does not support computing rate sensitivities.\n    ", /*tp_doc*/
  __pyx_tp_traverse_8_redukti_SvenssonCurve, /*tp_traverse*/
  __pyx_tp_clear_8_redukti_SvenssonCurve, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_SvenssonCurve, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_13SvenssonCurve_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_SvenssonCurve, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_YieldCurve __pyx_vtable_8_redukti_YieldCurve;

static PyObject *__pyx_tp_new_8_redukti_YieldCurve(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_YieldCurve *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_YieldCurve *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_YieldCurve;
  new((void*)&(p->_definition)) redukti::IRCurveDefinition();
  new((void*)&(p->_underlying_curve)) redukti::ZeroCurve();
  if (unlikely(__pyx_pw_8_redukti_10YieldCurve_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_YieldCurve(PyObject *o) {
  struct __pyx_obj_8_redukti_YieldCurve *p = (struct __pyx_obj_8_redukti_YieldCurve *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_8_redukti_10YieldCurve_5__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  __Pyx_call_destructor(p->_definition);
  __Pyx_call_destructor(p->_underlying_curve);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_YieldCurve[] = {
  {"discount", (PyCFunction)__pyx_pw_8_redukti_10YieldCurve_7discount, METH_O, __pyx_doc_8_redukti_10YieldCurve_6discount},
  {"zero_rate", (PyCFunction)__pyx_pw_8_redukti_10YieldCurve_9zero_rate, METH_O, __pyx_doc_8_redukti_10YieldCurve_8zero_rate},
  {"forward_rate", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_8_redukti_10YieldCurve_11forward_rate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8_redukti_10YieldCurve_10forward_rate},
  {"time_from_reference", (PyCFunction)__pyx_pw_8_redukti_10YieldCurve_13time_from_reference, METH_O, __pyx_doc_8_redukti_10YieldCurve_12time_from_reference},
  {"get_sensitivities", (PyCFunction)__pyx_pw_8_redukti_10YieldCurve_15get_sensitivities, METH_O, __pyx_doc_8_redukti_10YieldCurve_14get_sensitivities},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_10YieldCurve_17__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_10YieldCurve_16__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_10YieldCurve_19__setstate_cython__, METH_O, __pyx_doc_8_redukti_10YieldCurve_18__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_YieldCurve = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.YieldCurve", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_YieldCurve), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_YieldCurve, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "YieldCurve(Date business_date, curve_defn, zero_curve, int deriv_order=2, PricingCurveType type=enums.PRICING_CURVE_TYPE_FORWARD, MarketDataQualifier mdq=enums.MDQ_NORMAL, int cycle=0, int scenario=0)\n\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_YieldCurve, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_10YieldCurve_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_YieldCurve, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};
static struct __pyx_vtabstruct_8_redukti_InMemoryRequestProcessor __pyx_vtable_8_redukti_InMemoryRequestProcessor;

static PyObject *__pyx_tp_new_8_redukti_InMemoryRequestProcessor(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_8_redukti_InMemoryRequestProcessor *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_8_redukti_InMemoryRequestProcessor *)o);
  p->__pyx_vtab = __pyx_vtabptr_8_redukti_InMemoryRequestProcessor;
  new((void*)&(p->_request_processor)) std::unique_ptr<redukti::RequestProcessor> ();
  if (unlikely(__pyx_pw_8_redukti_24InMemoryRequestProcessor_3__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_8_redukti_InMemoryRequestProcessor(PyObject *o) {
  struct __pyx_obj_8_redukti_InMemoryRequestProcessor *p = (struct __pyx_obj_8_redukti_InMemoryRequestProcessor *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_request_processor);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_8_redukti_InMemoryRequestProcessor[] = {
  {"serve", (PyCFunction)__pyx_pw_8_redukti_24InMemoryRequestProcessor_5serve, METH_O, __pyx_doc_8_redukti_24InMemoryRequestProcessor_4serve},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_8_redukti_24InMemoryRequestProcessor_7__reduce_cython__, METH_NOARGS, __pyx_doc_8_redukti_24InMemoryRequestProcessor_6__reduce_cython__},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_8_redukti_24InMemoryRequestProcessor_9__setstate_cython__, METH_O, __pyx_doc_8_redukti_24InMemoryRequestProcessor_8__setstate_cython__},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_8_redukti_InMemoryRequestProcessor = {
  PyVarObject_HEAD_INIT(0, 0)
  "_redukti.InMemoryRequestProcessor", /*tp_name*/
  sizeof(struct __pyx_obj_8_redukti_InMemoryRequestProcessor), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_8_redukti_InMemoryRequestProcessor, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "InMemoryRequestProcessor(pricing_script)\n\n    The InMemoryRequestProcessor creates internal instance of the OpenRedukti RequestProcessor\n    class. This instance contains internal instances of the OpenRedukti CurveBuilderService\n    and ValuationService and hence can process all requests that would normally be submitted to\n    the OpenRedukti server over gRPC protocol.\n\n    The InMemoryRequestProcessor is useful when you only want to use the OpenRedukti\n    functions internally in Python and do not need to interact with the OpenRedukti server.\n\n    The downside of this internal instance is that if there is a bug in the tOpenRedukti\n    code it can crash your Python instance. Hence this type of use is not recommended unless\n    you have tested your interactions thoroughly and are confident that there will not be any\n    issues.\n\n    Note that the InMemoryRequestProcessor is a relatively heavyweight object and some of\n    its computations may take a while to run. Internally threads may be started by the linear\n    algebra library used, additionally the CurveBuilderService creates its own Lua scripting\n    VM.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_8_redukti_InMemoryRequestProcessor, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_8_redukti_24InMemoryRequestProcessor_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_8_redukti_InMemoryRequestProcessor, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1
  0, /*tp_vectorcall*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
#if CYTHON_PEP489_MULTI_PHASE_INIT
static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
static int __pyx_pymod_exec__redukti(PyObject* module); /*proto*/
static PyModuleDef_Slot __pyx_moduledef_slots[] = {
  {Py_mod_create, (void*)__pyx_pymod_create},
  {Py_mod_exec, (void*)__pyx_pymod_exec__redukti},
  {0, NULL}
};
#endif

static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    "_redukti",
    __pyx_k_Implements_the_interface_to_Ope, /* m_doc */
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    0, /* m_size */
  #else
    -1, /* m_size */
  #endif
    __pyx_methods /* m_methods */,
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    __pyx_moduledef_slots, /* m_slots */
  #else
    NULL, /* m_reload */
  #endif
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif
#ifndef CYTHON_SMALL_CODE
#if defined(__clang__)
    #define CYTHON_SMALL_CODE
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
    #define CYTHON_SMALL_CODE __attribute__((cold))
#else
    #define CYTHON_SMALL_CODE
#endif
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_n_s_ADVar, __pyx_k_ADVar, sizeof(__pyx_k_ADVar), 0, 0, 1, 1},
  {&__pyx_kp_u_Beta0_tau1_and_tau2_must_be_posi, __pyx_k_Beta0_tau1_and_tau2_must_be_posi, sizeof(__pyx_k_Beta0_tau1_and_tau2_must_be_posi), 0, 1, 0, 0},
  {&__pyx_kp_u_Business_centers_must_be_specifi, __pyx_k_Business_centers_must_be_specifi, sizeof(__pyx_k_Business_centers_must_be_specifi), 0, 1, 0, 0},
  {&__pyx_n_s_Calendar, __pyx_k_Calendar, sizeof(__pyx_k_Calendar), 0, 0, 1, 1},
  {&__pyx_kp_u_Cannot_parse_the_IRCurveDefiniti, __pyx_k_Cannot_parse_the_IRCurveDefiniti, sizeof(__pyx_k_Cannot_parse_the_IRCurveDefiniti), 0, 1, 0, 0},
  {&__pyx_kp_u_Cannot_parse_the_Request_object, __pyx_k_Cannot_parse_the_Request_object, sizeof(__pyx_k_Cannot_parse_the_Request_object), 0, 1, 0, 0},
  {&__pyx_kp_u_Cannot_parse_the_ZeroCurve, __pyx_k_Cannot_parse_the_ZeroCurve, sizeof(__pyx_k_Cannot_parse_the_ZeroCurve), 0, 1, 0, 0},
  {&__pyx_kp_u_Cannot_parse_the_schedule_parame, __pyx_k_Cannot_parse_the_schedule_parame, sizeof(__pyx_k_Cannot_parse_the_schedule_parame), 0, 1, 0, 0},
  {&__pyx_kp_u_Could_not_convert_to_bytes, __pyx_k_Could_not_convert_to_bytes, sizeof(__pyx_k_Could_not_convert_to_bytes), 0, 1, 0, 0},
  {&__pyx_n_s_CurveId, __pyx_k_CurveId, sizeof(__pyx_k_CurveId), 0, 0, 1, 1},
  {&__pyx_n_s_Date, __pyx_k_Date, sizeof(__pyx_k_Date), 0, 0, 1, 1},
  {&__pyx_n_s_DayFraction, __pyx_k_DayFraction, sizeof(__pyx_k_DayFraction), 0, 0, 1, 1},
  {&__pyx_kp_u_Expected_values_of_redukti_Date, __pyx_k_Expected_values_of_redukti_Date, sizeof(__pyx_k_Expected_values_of_redukti_Date), 0, 1, 0, 0},
  {&__pyx_kp_u_Failed_to_create_instance_of_Int, __pyx_k_Failed_to_create_instance_of_Int, sizeof(__pyx_k_Failed_to_create_instance_of_Int), 0, 1, 0, 0},
  {&__pyx_kp_u_Failed_to_create_instance_of_Sve, __pyx_k_Failed_to_create_instance_of_Sve, sizeof(__pyx_k_Failed_to_create_instance_of_Sve), 0, 1, 0, 0},
  {&__pyx_kp_u_Failed_to_generate_schedule, __pyx_k_Failed_to_generate_schedule, sizeof(__pyx_k_Failed_to_generate_schedule), 0, 1, 0, 0},
  {&__pyx_kp_u_Failed_to_parse_response_from_ap, __pyx_k_Failed_to_parse_response_from_ap, sizeof(__pyx_k_Failed_to_parse_response_from_ap), 0, 1, 0, 0},
  {&__pyx_kp_u_Failed_to_parse_result_from_api, __pyx_k_Failed_to_parse_result_from_api, sizeof(__pyx_k_Failed_to_parse_result_from_api), 0, 1, 0, 0},
  {&__pyx_n_s_InMemoryRequestProcessor, __pyx_k_InMemoryRequestProcessor, sizeof(__pyx_k_InMemoryRequestProcessor), 0, 0, 1, 1},
  {&__pyx_kp_s_Incompatible_checksums_s_vs_0xd4, __pyx_k_Incompatible_checksums_s_vs_0xd4, sizeof(__pyx_k_Incompatible_checksums_s_vs_0xd4), 0, 0, 1, 0},
  {&__pyx_kp_u_Incorrect_number_of_values_in_bu, __pyx_k_Incorrect_number_of_values_in_bu, sizeof(__pyx_k_Incorrect_number_of_values_in_bu), 0, 1, 0, 0},
  {&__pyx_kp_u_Index_not_defined_for_given_Curr, __pyx_k_Index_not_defined_for_given_Curr, sizeof(__pyx_k_Index_not_defined_for_given_Curr), 0, 1, 0, 0},
  {&__pyx_kp_u_Index_not_defined_for_given_Isda, __pyx_k_Index_not_defined_for_given_Isda, sizeof(__pyx_k_Index_not_defined_for_given_Isda), 0, 1, 0, 0},
  {&__pyx_kp_u_Index_object_is_not_initialized, __pyx_k_Index_object_is_not_initialized, sizeof(__pyx_k_Index_object_is_not_initialized), 0, 1, 0, 0},
  {&__pyx_kp_u_Input_must_be_an_instance_of_sch, __pyx_k_Input_must_be_an_instance_of_sch, sizeof(__pyx_k_Input_must_be_an_instance_of_sch), 0, 1, 0, 0},
  {&__pyx_kp_u_Input_must_be_an_instance_of_ser, __pyx_k_Input_must_be_an_instance_of_ser, sizeof(__pyx_k_Input_must_be_an_instance_of_ser), 0, 1, 0, 0},
  {&__pyx_n_s_InterestRateIndex, __pyx_k_InterestRateIndex, sizeof(__pyx_k_InterestRateIndex), 0, 0, 1, 1},
  {&__pyx_n_s_InterpolatedYieldCurve, __pyx_k_InterpolatedYieldCurve, sizeof(__pyx_k_InterpolatedYieldCurve), 0, 0, 1, 1},
  {&__pyx_n_s_Interpolator, __pyx_k_Interpolator, sizeof(__pyx_k_Interpolator), 0, 0, 1, 1},
  {&__pyx_kp_u_Invalid_Currency_specified, __pyx_k_Invalid_Currency_specified, sizeof(__pyx_k_Invalid_Currency_specified), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_DayCountFraction_specifi, __pyx_k_Invalid_DayCountFraction_specifi, sizeof(__pyx_k_Invalid_DayCountFraction_specifi), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_IndexFamily_specified, __pyx_k_Invalid_IndexFamily_specified, sizeof(__pyx_k_Invalid_IndexFamily_specified), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_InterpolatorType_specifi, __pyx_k_Invalid_InterpolatorType_specifi, sizeof(__pyx_k_Invalid_InterpolatorType_specifi), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_IsdaIndex_specified, __pyx_k_Invalid_IsdaIndex_specified, sizeof(__pyx_k_Invalid_IsdaIndex_specified), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_PeriodUnit_specified, __pyx_k_Invalid_PeriodUnit_specified, sizeof(__pyx_k_Invalid_PeriodUnit_specified), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_Tenor_specified, __pyx_k_Invalid_Tenor_specified, sizeof(__pyx_k_Invalid_Tenor_specified), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_business_center, __pyx_k_Invalid_business_center, sizeof(__pyx_k_Invalid_business_center), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_date_cannot_parse, __pyx_k_Invalid_date_cannot_parse, sizeof(__pyx_k_Invalid_date_cannot_parse), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_size_of_maturities_or_va, __pyx_k_Invalid_size_of_maturities_or_va, sizeof(__pyx_k_Invalid_size_of_maturities_or_va), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_size_of_parameters_six_p, __pyx_k_Invalid_size_of_parameters_six_p, sizeof(__pyx_k_Invalid_size_of_parameters_six_p), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_size_of_x_or_y_minimum_4, __pyx_k_Invalid_size_of_x_or_y_minimum_4, sizeof(__pyx_k_Invalid_size_of_x_or_y_minimum_4), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_state, __pyx_k_Invalid_state, sizeof(__pyx_k_Invalid_state), 0, 1, 0, 0},
  {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
  {&__pyx_kp_u_NULL_value_supplied, __pyx_k_NULL_value_supplied, sizeof(__pyx_k_NULL_value_supplied), 0, 1, 0, 0},
  {&__pyx_kp_u_Number_of_variables_in_ADVar_mus, __pyx_k_Number_of_variables_in_ADVar_mus, sizeof(__pyx_k_Number_of_variables_in_ADVar_mus), 0, 1, 0, 0},
  {&__pyx_kp_u_Order_must_be_between_0_and_2, __pyx_k_Order_must_be_between_0_and_2, sizeof(__pyx_k_Order_must_be_between_0_and_2), 0, 1, 0, 0},
  {&__pyx_n_s_ParseFromString, __pyx_k_ParseFromString, sizeof(__pyx_k_ParseFromString), 0, 0, 1, 1},
  {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
  {&__pyx_n_s_Request, __pyx_k_Request, sizeof(__pyx_k_Request), 0, 0, 1, 1},
  {&__pyx_n_s_Response, __pyx_k_Response, sizeof(__pyx_k_Response), 0, 0, 1, 1},
  {&__pyx_n_s_Schedule, __pyx_k_Schedule, sizeof(__pyx_k_Schedule), 0, 0, 1, 1},
  {&__pyx_n_s_ScheduleGenerator, __pyx_k_ScheduleGenerator, sizeof(__pyx_k_ScheduleGenerator), 0, 0, 1, 1},
  {&__pyx_n_s_ScheduleParameters, __pyx_k_ScheduleParameters, sizeof(__pyx_k_ScheduleParameters), 0, 0, 1, 1},
  {&__pyx_n_s_SerializeToString, __pyx_k_SerializeToString, sizeof(__pyx_k_SerializeToString), 0, 0, 1, 1},
  {&__pyx_kp_u_Supplied_arrays_must_be_of_type, __pyx_k_Supplied_arrays_must_be_of_type, sizeof(__pyx_k_Supplied_arrays_must_be_of_type), 0, 1, 0, 0},
  {&__pyx_kp_u_Supplied_values_are_not_of_the_s, __pyx_k_Supplied_values_are_not_of_the_s, sizeof(__pyx_k_Supplied_values_are_not_of_the_s), 0, 1, 0, 0},
  {&__pyx_n_s_SvenssonCurve, __pyx_k_SvenssonCurve, sizeof(__pyx_k_SvenssonCurve), 0, 0, 1, 1},
  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
  {&__pyx_kp_u_UTF_8, __pyx_k_UTF_8, sizeof(__pyx_k_UTF_8), 0, 1, 0, 0},
  {&__pyx_kp_u_Unable_to_construct_a_calendar_f, __pyx_k_Unable_to_construct_a_calendar_f, sizeof(__pyx_k_Unable_to_construct_a_calendar_f), 0, 1, 0, 0},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_kp_u_Variable_index_is_out_of_range, __pyx_k_Variable_index_is_out_of_range, sizeof(__pyx_k_Variable_index_is_out_of_range), 0, 1, 0, 0},
  {&__pyx_n_s_YieldCurve, __pyx_k_YieldCurve, sizeof(__pyx_k_YieldCurve), 0, 0, 1, 1},
  {&__pyx_n_s_adjust_date, __pyx_k_adjust_date, sizeof(__pyx_k_adjust_date), 0, 0, 1, 1},
  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
  {&__pyx_n_s_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 0, 1, 1},
  {&__pyx_n_s_as_of_date, __pyx_k_as_of_date, sizeof(__pyx_k_as_of_date), 0, 0, 1, 1},
  {&__pyx_n_s_business_centres, __pyx_k_business_centres, sizeof(__pyx_k_business_centres), 0, 0, 1, 1},
  {&__pyx_n_s_business_date, __pyx_k_business_date, sizeof(__pyx_k_business_date), 0, 0, 1, 1},
  {&__pyx_n_s_byte_s, __pyx_k_byte_s, sizeof(__pyx_k_byte_s), 0, 0, 1, 1},
  {&__pyx_n_s_c_string, __pyx_k_c_string, sizeof(__pyx_k_c_string), 0, 0, 1, 1},
  {&__pyx_n_s_ccy, __pyx_k_ccy, sizeof(__pyx_k_ccy), 0, 0, 1, 1},
  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_convention, __pyx_k_convention, sizeof(__pyx_k_convention), 0, 0, 1, 1},
  {&__pyx_n_s_convert_to_date_array, __pyx_k_convert_to_date_array, sizeof(__pyx_k_convert_to_date_array), 0, 0, 1, 1},
  {&__pyx_n_s_currency, __pyx_k_currency, sizeof(__pyx_k_currency), 0, 0, 1, 1},
  {&__pyx_n_s_curve_defn, __pyx_k_curve_defn, sizeof(__pyx_k_curve_defn), 0, 0, 1, 1},
  {&__pyx_n_s_cycle, __pyx_k_cycle, sizeof(__pyx_k_cycle), 0, 0, 1, 1},
  {&__pyx_n_s_d, __pyx_k_d, sizeof(__pyx_k_d), 0, 0, 1, 1},
  {&__pyx_n_u_d, __pyx_k_d, sizeof(__pyx_k_d), 0, 1, 0, 1},
  {&__pyx_n_s_d1, __pyx_k_d1, sizeof(__pyx_k_d1), 0, 0, 1, 1},
  {&__pyx_n_s_d2, __pyx_k_d2, sizeof(__pyx_k_d2), 0, 0, 1, 1},
  {&__pyx_n_s_date, __pyx_k_date, sizeof(__pyx_k_date), 0, 0, 1, 1},
  {&__pyx_n_s_date_array, __pyx_k_date_array, sizeof(__pyx_k_date_array), 0, 0, 1, 1},
  {&__pyx_n_s_dates, __pyx_k_dates, sizeof(__pyx_k_dates), 0, 0, 1, 1},
  {&__pyx_n_s_day, __pyx_k_day, sizeof(__pyx_k_day), 0, 0, 1, 1},
  {&__pyx_n_s_days, __pyx_k_days, sizeof(__pyx_k_days), 0, 0, 1, 1},
  {&__pyx_n_s_deriv_order, __pyx_k_deriv_order, sizeof(__pyx_k_deriv_order), 0, 0, 1, 1},
  {&__pyx_n_s_dfc, __pyx_k_dfc, sizeof(__pyx_k_dfc), 0, 0, 1, 1},
  {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
  {&__pyx_n_s_discount, __pyx_k_discount, sizeof(__pyx_k_discount), 0, 0, 1, 1},
  {&__pyx_n_s_dmy, __pyx_k_dmy, sizeof(__pyx_k_dmy), 0, 0, 1, 1},
  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
  {&__pyx_kp_u_failed_to_create_instance_of_InM, __pyx_k_failed_to_create_instance_of_InM, sizeof(__pyx_k_failed_to_create_instance_of_InM), 0, 1, 0, 0},
  {&__pyx_n_s_final_period, __pyx_k_final_period, sizeof(__pyx_k_final_period), 0, 0, 1, 1},
  {&__pyx_n_s_fixing_date, __pyx_k_fixing_date, sizeof(__pyx_k_fixing_date), 0, 0, 1, 1},
  {&__pyx_n_s_forward_rate, __pyx_k_forward_rate, sizeof(__pyx_k_forward_rate), 0, 0, 1, 1},
  {&__pyx_n_s_fraction, __pyx_k_fraction, sizeof(__pyx_k_fraction), 0, 0, 1, 1},
  {&__pyx_n_s_generate_schedule, __pyx_k_generate_schedule, sizeof(__pyx_k_generate_schedule), 0, 0, 1, 1},
  {&__pyx_n_s_get_index, __pyx_k_get_index, sizeof(__pyx_k_get_index), 0, 0, 1, 1},
  {&__pyx_n_s_get_index_by_isdaindex, __pyx_k_get_index_by_isdaindex, sizeof(__pyx_k_get_index_by_isdaindex), 0, 0, 1, 1},
  {&__pyx_n_s_get_sensitivities, __pyx_k_get_sensitivities, sizeof(__pyx_k_get_sensitivities), 0, 0, 1, 1},
  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
  {&__pyx_n_s_holidays, __pyx_k_holidays, sizeof(__pyx_k_holidays), 0, 0, 1, 1},
  {&__pyx_n_u_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 1, 0, 1},
  {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
  {&__pyx_n_s_idx, __pyx_k_idx, sizeof(__pyx_k_idx), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_index_family, __pyx_k_index_family, sizeof(__pyx_k_index_family), 0, 0, 1, 1},
  {&__pyx_n_s_initial_value, __pyx_k_initial_value, sizeof(__pyx_k_initial_value), 0, 0, 1, 1},
  {&__pyx_n_s_interpolate, __pyx_k_interpolate, sizeof(__pyx_k_interpolate), 0, 0, 1, 1},
  {&__pyx_n_s_interpolate_with_sensitivities, __pyx_k_interpolate_with_sensitivities, sizeof(__pyx_k_interpolate_with_sensitivities), 0, 0, 1, 1},
  {&__pyx_n_s_interpolator_type, __pyx_k_interpolator_type, sizeof(__pyx_k_interpolator_type), 0, 0, 1, 1},
  {&__pyx_n_s_is_eom, __pyx_k_is_eom, sizeof(__pyx_k_is_eom), 0, 0, 1, 1},
  {&__pyx_n_s_is_holiday, __pyx_k_is_holiday, sizeof(__pyx_k_is_holiday), 0, 0, 1, 1},
  {&__pyx_n_s_isda_index, __pyx_k_isda_index, sizeof(__pyx_k_isda_index), 0, 0, 1, 1},
  {&__pyx_n_s_m, __pyx_k_m, sizeof(__pyx_k_m), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_maturities, __pyx_k_maturities, sizeof(__pyx_k_maturities), 0, 0, 1, 1},
  {&__pyx_n_s_maturity_date, __pyx_k_maturity_date, sizeof(__pyx_k_maturity_date), 0, 0, 1, 1},
  {&__pyx_n_s_mdq, __pyx_k_mdq, sizeof(__pyx_k_mdq), 0, 0, 1, 1},
  {&__pyx_n_s_month, __pyx_k_month, sizeof(__pyx_k_month), 0, 0, 1, 1},
  {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
  {&__pyx_n_s_n_vars, __pyx_k_n_vars, sizeof(__pyx_k_n_vars), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
  {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
  {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
  {&__pyx_n_s_order, __pyx_k_order, sizeof(__pyx_k_order), 0, 0, 1, 1},
  {&__pyx_n_s_parameters, __pyx_k_parameters, sizeof(__pyx_k_parameters), 0, 0, 1, 1},
  {&__pyx_n_s_parameters_2, __pyx_k_parameters_2, sizeof(__pyx_k_parameters_2), 0, 0, 1, 1},
  {&__pyx_n_s_parse, __pyx_k_parse, sizeof(__pyx_k_parse), 0, 0, 1, 1},
  {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
  {&__pyx_n_s_pricing_curve_type, __pyx_k_pricing_curve_type, sizeof(__pyx_k_pricing_curve_type), 0, 0, 1, 1},
  {&__pyx_n_s_pricing_script, __pyx_k_pricing_script, sizeof(__pyx_k_pricing_script), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_unpickle_ScheduleGenerator, __pyx_k_pyx_unpickle_ScheduleGenerator, sizeof(__pyx_k_pyx_unpickle_ScheduleGenerator), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_qual, __pyx_k_qual, sizeof(__pyx_k_qual), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_rate_type, __pyx_k_rate_type, sizeof(__pyx_k_rate_type), 0, 0, 1, 1},
  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
  {&__pyx_n_s_redukti, __pyx_k_redukti, sizeof(__pyx_k_redukti), 0, 0, 1, 1},
  {&__pyx_n_s_redukti_2, __pyx_k_redukti_2, sizeof(__pyx_k_redukti_2), 0, 0, 1, 1},
  {&__pyx_kp_s_redukti_pyx, __pyx_k_redukti_pyx, sizeof(__pyx_k_redukti_pyx), 0, 0, 1, 0},
  {&__pyx_n_s_ref_date1, __pyx_k_ref_date1, sizeof(__pyx_k_ref_date1), 0, 0, 1, 1},
  {&__pyx_n_s_ref_date2, __pyx_k_ref_date2, sizeof(__pyx_k_ref_date2), 0, 0, 1, 1},
  {&__pyx_n_s_register_calendar, __pyx_k_register_calendar, sizeof(__pyx_k_register_calendar), 0, 0, 1, 1},
  {&__pyx_n_s_result, __pyx_k_result, sizeof(__pyx_k_result), 0, 0, 1, 1},
  {&__pyx_n_s_result_str, __pyx_k_result_str, sizeof(__pyx_k_result_str), 0, 0, 1, 1},
  {&__pyx_n_s_s, __pyx_k_s, sizeof(__pyx_k_s), 0, 0, 1, 1},
  {&__pyx_n_s_scenario, __pyx_k_scenario, sizeof(__pyx_k_scenario), 0, 0, 1, 1},
  {&__pyx_n_s_schedule, __pyx_k_schedule, sizeof(__pyx_k_schedule), 0, 0, 1, 1},
  {&__pyx_n_s_schedule_parameters, __pyx_k_schedule_parameters, sizeof(__pyx_k_schedule_parameters), 0, 0, 1, 1},
  {&__pyx_n_s_schedule_pb2, __pyx_k_schedule_pb2, sizeof(__pyx_k_schedule_pb2), 0, 0, 1, 1},
  {&__pyx_n_s_serial, __pyx_k_serial, sizeof(__pyx_k_serial), 0, 0, 1, 1},
  {&__pyx_n_s_serve, __pyx_k_serve, sizeof(__pyx_k_serve), 0, 0, 1, 1},
  {&__pyx_n_s_services_pb2, __pyx_k_services_pb2, sizeof(__pyx_k_services_pb2), 0, 0, 1, 1},
  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
  {&__pyx_n_s_staticmethod, __pyx_k_staticmethod, sizeof(__pyx_k_staticmethod), 0, 0, 1, 1},
  {&__pyx_n_s_status, __pyx_k_status, sizeof(__pyx_k_status), 0, 0, 1, 1},
  {&__pyx_n_s_str, __pyx_k_str, sizeof(__pyx_k_str), 0, 0, 1, 1},
  {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
  {&__pyx_n_s_tenor, __pyx_k_tenor, sizeof(__pyx_k_tenor), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_time_from_reference, __pyx_k_time_from_reference, sizeof(__pyx_k_time_from_reference), 0, 0, 1, 1},
  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
  {&__pyx_n_s_typecode, __pyx_k_typecode, sizeof(__pyx_k_typecode), 0, 0, 1, 1},
  {&__pyx_n_s_unadjusted, __pyx_k_unadjusted, sizeof(__pyx_k_unadjusted), 0, 0, 1, 1},
  {&__pyx_n_s_unit, __pyx_k_unit, sizeof(__pyx_k_unit), 0, 0, 1, 1},
  {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
  {&__pyx_n_s_v, __pyx_k_v, sizeof(__pyx_k_v), 0, 0, 1, 1},
  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
  {&__pyx_n_s_value_date, __pyx_k_value_date, sizeof(__pyx_k_value_date), 0, 0, 1, 1},
  {&__pyx_n_s_values, __pyx_k_values, sizeof(__pyx_k_values), 0, 0, 1, 1},
  {&__pyx_n_s_variable, __pyx_k_variable, sizeof(__pyx_k_variable), 0, 0, 1, 1},
  {&__pyx_n_s_x, __pyx_k_x, sizeof(__pyx_k_x), 0, 0, 1, 1},
  {&__pyx_n_s_xdata, __pyx_k_xdata, sizeof(__pyx_k_xdata), 0, 0, 1, 1},
  {&__pyx_n_s_y, __pyx_k_y, sizeof(__pyx_k_y), 0, 0, 1, 1},
  {&__pyx_n_s_year, __pyx_k_year, sizeof(__pyx_k_year), 0, 0, 1, 1},
  {&__pyx_n_s_year_fraction, __pyx_k_year_fraction, sizeof(__pyx_k_year_fraction), 0, 0, 1, 1},
  {&__pyx_n_s_year_fraction_with_finalperiod, __pyx_k_year_fraction_with_finalperiod, sizeof(__pyx_k_year_fraction_with_finalperiod), 0, 0, 1, 1},
  {&__pyx_n_s_year_fraction_with_refdates, __pyx_k_year_fraction_with_refdates, sizeof(__pyx_k_year_fraction_with_refdates), 0, 0, 1, 1},
  {&__pyx_n_s_zero_curve, __pyx_k_zero_curve, sizeof(__pyx_k_zero_curve), 0, 0, 1, 1},
  {&__pyx_n_s_zero_rate, __pyx_k_zero_rate, sizeof(__pyx_k_zero_rate), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_staticmethod = __Pyx_GetBuiltinName(__pyx_n_s_staticmethod); if (!__pyx_builtin_staticmethod) __PYX_ERR(0, 189, __pyx_L1_error)
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 62, __pyx_L1_error)
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 122, __pyx_L1_error)
  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(2, 109, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "_redukti.pyx":62
 *     def __cinit__(self, int n_vars, int order, int variable, double initial_value):
 *         if n_vars <= 0:
 *             raise ValueError('Number of variables in ADVar must be > 0')             # <<<<<<<<<<<<<<
 *         if order < 0 or order > 2:
 *             raise ValueError('Order must be between 0 and 2')
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_Number_of_variables_in_ADVar_mus); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 62, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "_redukti.pyx":64
 *             raise ValueError('Number of variables in ADVar must be > 0')
 *         if order < 0 or order > 2:
 *             raise ValueError('Order must be between 0 and 2')             # <<<<<<<<<<<<<<
 *         if variable < -1 or variable >= n_vars:
 *             raise ValueError('Variable index is out of range')
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_Order_must_be_between_0_and_2); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 64, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "_redukti.pyx":66
 *             raise ValueError('Order must be between 0 and 2')
 *         if variable < -1 or variable >= n_vars:
 *             raise ValueError('Variable index is out of range')             # <<<<<<<<<<<<<<
 *         cdef size_t size = autodiff.redukti_adouble_alloc_size(n_vars, order)
 *         self._ad = <autodiff.redukti_adouble_t*> PyMem_Malloc(size)
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_Variable_index_is_out_of_range); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 66, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "_redukti.pyx":87
 *         is_compatible = self._vars == other._vars and self._order == other._order
 *         if not is_compatible:
 *             raise ValueError('Supplied values are not of the same order or size')             # <<<<<<<<<<<<<<
 *         autodiff.redukti_adouble_assign(self._ad, other._ad)
 * 
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_Supplied_values_are_not_of_the_s); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 87, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "_redukti.pyx":102
 *         """
 *         if value is NULL:
 *             raise ValueError('NULL value supplied')             # <<<<<<<<<<<<<<
 *         cdef int n_vars = autodiff.redukti_adouble_get_nvars(value)
 *         cdef int order = autodiff.redukti_adouble_get_order(value)
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_u_NULL_value_supplied); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 102, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "_redukti.pyx":142
 * cdef validate_periodunit(enums.PeriodUnit unit):
 *     if unit < 1 or unit > enums.YEARS:
 *         raise ValueError('Invalid PeriodUnit specified')             # <<<<<<<<<<<<<<
 * 
 * cdef bytes to_bytes(s):
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_u_Invalid_PeriodUnit_specified); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 142, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "_redukti.pyx":152
 *         return bytes(s)
 *     else:
 *         raise TypeError("Could not convert to bytes.")             # <<<<<<<<<<<<<<
 * 
 * cdef class Date:
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Could_not_convert_to_bytes); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 152, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "_redukti.pyx":237
 *         cdef const char*c_string = byte_s
 *         if not date.parse_date(c_string, &d):
 *             raise ValueError('Invalid date: cannot parse')             # <<<<<<<<<<<<<<
 *         return Date(d)
 * 
 */
  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_Invalid_date_cannot_parse); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__11);
  __Pyx_GIVEREF(__pyx_tuple__11);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__12);
  __Pyx_GIVEREF(__pyx_tuple__12);

  /* "_redukti.pyx":258
 *         """
 *         if not isinstance(schedule_parameters, schedule_pb2.ScheduleParameters):
 *             raise ValueError('Input must be an instance of schedule_pb2.ScheduleParameters')             # <<<<<<<<<<<<<<
 *         cdef string str = schedule_parameters.SerializeToString()
 *         cdef schedule.ScheduleParameters _parameters
 */
  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_u_Input_must_be_an_instance_of_sch); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__13);
  __Pyx_GIVEREF(__pyx_tuple__13);

  /* "_redukti.pyx":262
 *         cdef schedule.ScheduleParameters _parameters
 *         if not _parameters.ParseFromString(str):
 *             raise ValueError("Cannot parse the schedule parameters")             # <<<<<<<<<<<<<<
 *         cdef schedule.Schedule _schedule
 *         status = schedule.build_schedule(_parameters, _schedule)
 */
  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_u_Cannot_parse_the_schedule_parame); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 262, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);

  /* "_redukti.pyx":266
 *         status = schedule.build_schedule(_parameters, _schedule)
 *         if not status == enums.ResponseSubCode.kOk:
 *             raise Exception('Failed to generate schedule')             # <<<<<<<<<<<<<<
 *         result = schedule_pb2.Schedule()
 *         cdef string result_str
 */
  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_generate_schedule); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(0, 266, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__15);
  __Pyx_GIVEREF(__pyx_tuple__15);

  /* "_redukti.pyx":270
 *         cdef string result_str
 *         if not _schedule.SerializeToString(&result_str):
 *             raise Exception('Failed to parse result from api call')             # <<<<<<<<<<<<<<
 *         result.ParseFromString(result_str)
 *         return result
 */
  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_parse_result_from_api); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__16);
  __Pyx_GIVEREF(__pyx_tuple__16);

  /* "_redukti.pyx":276
 * cdef validate_business_centers(list business_centres):
 *     if len(business_centres) == 0:
 *         raise ValueError('Business centers must be specified')             # <<<<<<<<<<<<<<
 *     for center in business_centres:
 *         if center < 1 or center > enums.BRSP:
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_u_Business_centers_must_be_specifi); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "_redukti.pyx":279
 *     for center in business_centres:
 *         if center < 1 or center > enums.BRSP:
 *             raise ValueError('Invalid business center')             # <<<<<<<<<<<<<<
 * 
 * def convert_to_date_array(list values):
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_u_Invalid_business_center); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 279, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);

  /* "_redukti.pyx":287
 *             date_array.append(v.serial())
 *         else:
 *             raise ValueError('Expected values of redukti.Date type in list')             # <<<<<<<<<<<<<<
 *     return date_array
 * 
 */
  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_u_Expected_values_of_redukti_Date); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 287, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__19);
  __Pyx_GIVEREF(__pyx_tuple__19);

  /* "_redukti.pyx":335
 *             self._calendar = calendar.get_calendar_factory().get_calendar(joint_calendars)
 *         else:
 *             raise ValueError('Incorrect number of values in business centres list, max of 4 allowed')             # <<<<<<<<<<<<<<
 *         if self._calendar is NULL:
 *             raise ValueError('Unable to construct a calendar from given parameters')
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_u_Incorrect_number_of_values_in_bu); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 335, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "_redukti.pyx":337
 *             raise ValueError('Incorrect number of values in business centres list, max of 4 allowed')
 *         if self._calendar is NULL:
 *             raise ValueError('Unable to construct a calendar from given parameters')             # <<<<<<<<<<<<<<
 * 
 *     cpdef bint is_holiday(self, Date d):
 */
  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_u_Unable_to_construct_a_calendar_f); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__24);
  __Pyx_GIVEREF(__pyx_tuple__24);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "_redukti.pyx":410
 * cdef validate_daycountfraction(enums.DayCountFraction dfc):
 *     if dfc < 1 or dfc > enums.BUS_252:
 *         raise ValueError('Invalid DayCountFraction specified')             # <<<<<<<<<<<<<<
 * 
 * cdef class DayFraction:
 */
  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_u_Invalid_DayCountFraction_specifi); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 410, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);

  /* "_redukti.pyx":478
 * cdef validate_isda_index(enums.IsdaIndex index):
 *     if index < 1 or index > enums.ZAR_JIBAR_SAFEX:
 *         raise ValueError('Invalid IsdaIndex specified')             # <<<<<<<<<<<<<<
 * 
 * cdef validate_index_family(enums.IndexFamily family):
 */
  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_u_Invalid_IsdaIndex_specified); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 478, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__29);
  __Pyx_GIVEREF(__pyx_tuple__29);

  /* "_redukti.pyx":482
 * cdef validate_index_family(enums.IndexFamily family):
 *     if family < 1 or family > enums.REPO_CURVE:
 *         raise ValueError('Invalid IndexFamily specified')             # <<<<<<<<<<<<<<
 * 
 * cdef validate_tenor(enums.Tenor tenor):
 */
  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_u_Invalid_IndexFamily_specified); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 482, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);

  /* "_redukti.pyx":486
 * cdef validate_tenor(enums.Tenor tenor):
 *     if tenor < 0 or tenor > enums.TENOR_1T:
 *         raise ValueError('Invalid Tenor specified')             # <<<<<<<<<<<<<<
 * 
 * cdef validate_currency(enums.Currency ccy):
 */
  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_u_Invalid_Tenor_specified); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 486, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__31);
  __Pyx_GIVEREF(__pyx_tuple__31);

  /* "_redukti.pyx":490
 * cdef validate_currency(enums.Currency ccy):
 *     if ccy < 0 or ccy > enums.PLN:
 *         raise ValueError('Invalid Currency specified')             # <<<<<<<<<<<<<<
 * 
 * cdef validate_interpolator_type(enums.InterpolatorType t):
 */
  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_u_Invalid_Currency_specified); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);

  /* "_redukti.pyx":494
 * cdef validate_interpolator_type(enums.InterpolatorType t):
 *     if t < 0 or t > enums.CUBIC_SPLINE_CLAMPED:
 *         raise ValueError('Invalid InterpolatorType specified')             # <<<<<<<<<<<<<<
 * 
 * cdef class InterestRateIndex:
 */
  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_u_Invalid_InterpolatorType_specifi); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 494, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__33);
  __Pyx_GIVEREF(__pyx_tuple__33);

  /* "_redukti.pyx":517
 *         cdef const index.InterestRateIndex *idx = index.get_default_index_service().get_index(isda_index, tenor)
 *         if idx is NULL:
 *             raise ValueError('Index not defined for given IsdaIndex and Tenor')             # <<<<<<<<<<<<<<
 *         cdef InterestRateIndex obj = InterestRateIndex()
 *         obj._index = idx
 */
  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_kp_u_Index_not_defined_for_given_Isda); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 517, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);

  /* "_redukti.pyx":533
 *                                                                                               tenor)
 *         if idx is NULL:
 *             raise ValueError('Index not defined for given Currency, IndexFamily and Tenor')             # <<<<<<<<<<<<<<
 *         cdef InterestRateIndex obj = InterestRateIndex()
 *         obj._index = idx
 */
  __pyx_tuple__35 = PyTuple_Pack(1, __pyx_kp_u_Index_not_defined_for_given_Curr); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 533, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__35);
  __Pyx_GIVEREF(__pyx_tuple__35);

  /* "_redukti.pyx":545
 *         """
 *         if self._index is NULL:
 *             return Exception('Index object is not initialized')             # <<<<<<<<<<<<<<
 *         return Date(self._index.value_date(fixing_date.serial()))
 * 
 */
  __pyx_tuple__36 = PyTuple_Pack(1, __pyx_kp_u_Index_object_is_not_initialized); if (unlikely(!__pyx_tuple__36)) __PYX_ERR(0, 545, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__36);
  __Pyx_GIVEREF(__pyx_tuple__36);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__37 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__37);
  __Pyx_GIVEREF(__pyx_tuple__37);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__38 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__38)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__38);
  __Pyx_GIVEREF(__pyx_tuple__38);

  /* "_redukti.pyx":616
 *         validate_interpolator_type(interpolator_type)
 *         if x.typecode != 'd' or y.typecode != 'd':
 *             raise ValueError('Supplied arrays must be of type double')             # <<<<<<<<<<<<<<
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:
 *             raise ValueError('Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)')
 */
  __pyx_tuple__39 = PyTuple_Pack(1, __pyx_kp_u_Supplied_arrays_must_be_of_type); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 616, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__39);
  __Pyx_GIVEREF(__pyx_tuple__39);

  /* "_redukti.pyx":618
 *             raise ValueError('Supplied arrays must be of type double')
 *         if len(x) != len(y) or len(x) < 4 or len(x) > 50:
 *             raise ValueError('Invalid size of x or y: minimum 4 elements required and len(x) must be == len(y)')             # <<<<<<<<<<<<<<
 *         self._x = x
 *         self._y = y
 */
  __pyx_tuple__40 = PyTuple_Pack(1, __pyx_kp_u_Invalid_size_of_x_or_y_minimum_4); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 618, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__40);
  __Pyx_GIVEREF(__pyx_tuple__40);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__41 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__41);
  __Pyx_GIVEREF(__pyx_tuple__41);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__42 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__42);
  __Pyx_GIVEREF(__pyx_tuple__42);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__44 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__44);
  __Pyx_GIVEREF(__pyx_tuple__44);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);

  /* "_redukti.pyx":686
 *         validate_interpolator_type(interpolator_type)
 *         if len(maturities) != len(values) or len(maturities) < 4 or len(maturities) > 50:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 'Invalid size of maturities or values: minimum 4 elements required and len(maturies) must be == len(values)')
 *         self._maturities = convert_to_date_array(maturities)
 */
  __pyx_tuple__46 = PyTuple_Pack(1, __pyx_kp_u_Invalid_size_of_maturities_or_va); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 686, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__46);
  __Pyx_GIVEREF(__pyx_tuple__46);

  /* "_redukti.pyx":697
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:
 *             raise Exception('Failed to create instance of InterpolatedYieldCurve: please check inputs are correct')             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_tuple__47 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_create_instance_of_Int); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 697, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__47);
  __Pyx_GIVEREF(__pyx_tuple__47);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__48 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__48);
  __Pyx_GIVEREF(__pyx_tuple__48);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__49 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__49);
  __Pyx_GIVEREF(__pyx_tuple__49);

  /* "_redukti.pyx":797
 *     def __cinit__(self, long long id, Date as_of_date, list parameters, enums.DayCountFraction fraction):
 *         if len(parameters) != 6:
 *             raise ValueError('Invalid size of parameters: six parameters required')             # <<<<<<<<<<<<<<
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:
 *             raise ValueError('Beta0, tau1 and tau2 must be positive')
 */
  __pyx_tuple__50 = PyTuple_Pack(1, __pyx_kp_u_Invalid_size_of_parameters_six_p); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 797, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__50);
  __Pyx_GIVEREF(__pyx_tuple__50);

  /* "_redukti.pyx":799
 *             raise ValueError('Invalid size of parameters: six parameters required')
 *         if parameters[0] < 0.0 or parameters[4] < 0.0 or parameters[5] < 0.0:
 *             raise ValueError('Beta0, tau1 and tau2 must be positive')             # <<<<<<<<<<<<<<
 *         self._parameters = array.array('d', parameters)
 *         cdef double *ydata = <double *> self._parameters.data.as_voidptr
 */
  __pyx_tuple__51 = PyTuple_Pack(1, __pyx_kp_u_Beta0_tau1_and_tau2_must_be_posi); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 799, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__51);
  __Pyx_GIVEREF(__pyx_tuple__51);

  /* "_redukti.pyx":807
 *         self._yield_curve_ptr = self._yield_curve.get()
 *         if self._yield_curve_ptr is NULL:
 *             raise Exception('Failed to create instance of SvenssonCurve: please check inputs are correct')             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_tuple__52 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_create_instance_of_Sve); if (unlikely(!__pyx_tuple__52)) __PYX_ERR(0, 807, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__52);
  __Pyx_GIVEREF(__pyx_tuple__52);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__53 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__54 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__54)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__54);
  __Pyx_GIVEREF(__pyx_tuple__54);

  /* "_redukti.pyx":883
 *         cdef string str = curve_defn.SerializeToString()
 *         if not self._definition.ParseFromString(str):
 *             raise ValueError("Cannot parse the IRCurveDefinition")             # <<<<<<<<<<<<<<
 *         str = zero_curve.SerializeToString()
 *         if not self._underlying_curve.ParseFromString(str):
 */
  __pyx_tuple__59 = PyTuple_Pack(1, __pyx_kp_u_Cannot_parse_the_IRCurveDefiniti); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 883, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);

  /* "_redukti.pyx":886
 *         str = zero_curve.SerializeToString()
 *         if not self._underlying_curve.ParseFromString(str):
 *             raise ValueError("Cannot parse the ZeroCurve")             # <<<<<<<<<<<<<<
 *         self._yield_curve = curve.make_curve(business_date.serial(), &self._definition, self._underlying_curve,
 *                                              deriv_order, type, mdq, cycle, scenario)
 */
  __pyx_tuple__60 = PyTuple_Pack(1, __pyx_kp_u_Cannot_parse_the_ZeroCurve); if (unlikely(!__pyx_tuple__60)) __PYX_ERR(0, 886, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__60);
  __Pyx_GIVEREF(__pyx_tuple__60);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__61 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__62 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__62)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__62);
  __Pyx_GIVEREF(__pyx_tuple__62);

  /* "_redukti.pyx":1009
 *         self._request_processor_ptr = self._request_processor.get()
 *         if self._request_processor_ptr is NULL:
 *             raise Exception('failed to create instance of InMemoryRequestProcessor')             # <<<<<<<<<<<<<<
 * 
 *     cpdef serve(self, request):
 */
  __pyx_tuple__63 = PyTuple_Pack(1, __pyx_kp_u_failed_to_create_instance_of_InM); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(0, 1009, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__63);
  __Pyx_GIVEREF(__pyx_tuple__63);

  /* "_redukti.pyx":1020
 *         """
 *         if self._request_processor_ptr is NULL:
 *             raise Exception('Invalid state')             # <<<<<<<<<<<<<<
 *         if not isinstance(request, services_pb2.Request):
 *             raise ValueError('Input must be an instance of services_pb2.Request')
 */
  __pyx_tuple__64 = PyTuple_Pack(1, __pyx_kp_u_Invalid_state); if (unlikely(!__pyx_tuple__64)) __PYX_ERR(0, 1020, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__64);
  __Pyx_GIVEREF(__pyx_tuple__64);

  /* "_redukti.pyx":1022
 *             raise Exception('Invalid state')
 *         if not isinstance(request, services_pb2.Request):
 *             raise ValueError('Input must be an instance of services_pb2.Request')             # <<<<<<<<<<<<<<
 *         cdef string request_str = request.SerializeToString()
 *         cdef request_processor.Request cpp_request
 */
  __pyx_tuple__65 = PyTuple_Pack(1, __pyx_kp_u_Input_must_be_an_instance_of_ser); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 1022, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);

  /* "_redukti.pyx":1026
 *         cdef request_processor.Request cpp_request
 *         if not cpp_request.ParseFromString(request_str):
 *             raise ValueError("Cannot parse the Request object")             # <<<<<<<<<<<<<<
 *         cdef request_processor.Response cpp_response
 *         self._request_processor_ptr.process(&cpp_request, &cpp_response)
 */
  __pyx_tuple__66 = PyTuple_Pack(1, __pyx_kp_u_Cannot_parse_the_Request_object); if (unlikely(!__pyx_tuple__66)) __PYX_ERR(0, 1026, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__66);
  __Pyx_GIVEREF(__pyx_tuple__66);

  /* "_redukti.pyx":1032
 *         cdef string response_str
 *         if not cpp_response.SerializeToString(&response_str):
 *             raise Exception('Failed to parse response from api call')             # <<<<<<<<<<<<<<
 *         response.ParseFromString(response_str)
 *         return response
 */
  __pyx_tuple__67 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_parse_response_from_ap); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 1032, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__67);
  __Pyx_GIVEREF(__pyx_tuple__67);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__68 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__68)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__68);
  __Pyx_GIVEREF(__pyx_tuple__68);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__69 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__69);
  __Pyx_GIVEREF(__pyx_tuple__69);

  /* "_redukti.pyx":190
 * 
 *     @staticmethod
 *     def dmy(unsigned d, unsigned m, int y):             # <<<<<<<<<<<<<<
 *         """
 *         Constructs a Date object from day, month, year.
 */
  __pyx_tuple__70 = PyTuple_Pack(3, __pyx_n_s_d, __pyx_n_s_m, __pyx_n_s_y); if (unlikely(!__pyx_tuple__70)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__70);
  __Pyx_GIVEREF(__pyx_tuple__70);
  __pyx_codeobj__71 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__70, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_redukti_pyx, __pyx_n_s_dmy, 190, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__71)) __PYX_ERR(0, 190, __pyx_L1_error)

  /* "_redukti.pyx":217
 * 
 *     @staticmethod
 *     def parse(s):             # <<<<<<<<<<<<<<
 *         """
 *         Parses a string representation of date.
 */
  __pyx_tuple__72 = PyTuple_Pack(4, __pyx_n_s_s, __pyx_n_s_d, __pyx_n_s_byte_s, __pyx_n_s_c_string); if (unlikely(!__pyx_tuple__72)) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__72);
  __Pyx_GIVEREF(__pyx_tuple__72);
  __pyx_codeobj__73 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__72, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_redukti_pyx, __pyx_n_s_parse, 217, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__73)) __PYX_ERR(0, 217, __pyx_L1_error)

  /* "_redukti.pyx":247
 * 
 *     @staticmethod
 *     def generate_schedule(schedule_parameters):             # <<<<<<<<<<<<<<
 *         """
 *         Generates a schedule
 */
  __pyx_tuple__74 = PyTuple_Pack(7, __pyx_n_s_schedule_parameters, __pyx_n_s_str, __pyx_n_s_parameters_2, __pyx_n_s_schedule, __pyx_n_s_status, __pyx_n_s_result, __pyx_n_s_result_str); if (unlikely(!__pyx_tuple__74)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__74);
  __Pyx_GIVEREF(__pyx_tuple__74);
  __pyx_codeobj__75 = (PyObject*)__Pyx_PyCode_New(1, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__74, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_redukti_pyx, __pyx_n_s_generate_schedule, 247, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__75)) __PYX_ERR(0, 247, __pyx_L1_error)

  /* "_redukti.pyx":281
 *             raise ValueError('Invalid business center')
 * 
 * def convert_to_date_array(list values):             # <<<<<<<<<<<<<<
 *     cdef array.array date_array = array.array('i', [])
 *     for v in values:
 */
  __pyx_tuple__76 = PyTuple_Pack(3, __pyx_n_s_values, __pyx_n_s_date_array, __pyx_n_s_v); if (unlikely(!__pyx_tuple__76)) __PYX_ERR(0, 281, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__76);
  __Pyx_GIVEREF(__pyx_tuple__76);
  __pyx_codeobj__77 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__76, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_redukti_pyx, __pyx_n_s_convert_to_date_array, 281, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__77)) __PYX_ERR(0, 281, __pyx_L1_error)

  /* "_redukti.pyx":395
 * 
 *     @staticmethod
 *     def register_calendar(enums.BusinessCenter id, list holidays):             # <<<<<<<<<<<<<<
 *         """
 *         Creates a calendar from a set of holidays and assign it to the business center
 */
  __pyx_tuple__78 = PyTuple_Pack(4, __pyx_n_s_id, __pyx_n_s_holidays, __pyx_n_s_dates, __pyx_n_s_xdata); if (unlikely(!__pyx_tuple__78)) __PYX_ERR(0, 395, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__78);
  __Pyx_GIVEREF(__pyx_tuple__78);
  __pyx_codeobj__79 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__78, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_redukti_pyx, __pyx_n_s_register_calendar, 395, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__79)) __PYX_ERR(0, 395, __pyx_L1_error)

  /* "_redukti.pyx":509
 * 
 *     @staticmethod
 *     def get_index_by_isdaindex(enums.IsdaIndex isda_index, enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains an instance by IsdaIndex and Tenor
 */
  __pyx_tuple__80 = PyTuple_Pack(4, __pyx_n_s_isda_index, __pyx_n_s_tenor, __pyx_n_s_idx, __pyx_n_s_obj); if (unlikely(!__pyx_tuple__80)) __PYX_ERR(0, 509, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__80);
  __Pyx_GIVEREF(__pyx_tuple__80);
  __pyx_codeobj__81 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__80, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_redukti_pyx, __pyx_n_s_get_index_by_isdaindex, 509, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__81)) __PYX_ERR(0, 509, __pyx_L1_error)

  /* "_redukti.pyx":523
 * 
 *     @staticmethod
 *     def get_index(enums.Currency currency, enums.IndexFamily index_family, enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains an instance by Currency, IndexFamily and Tenor
 */
  __pyx_tuple__82 = PyTuple_Pack(5, __pyx_n_s_currency, __pyx_n_s_index_family, __pyx_n_s_tenor, __pyx_n_s_idx, __pyx_n_s_obj); if (unlikely(!__pyx_tuple__82)) __PYX_ERR(0, 523, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__82);
  __Pyx_GIVEREF(__pyx_tuple__82);
  __pyx_codeobj__83 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__82, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_redukti_pyx, __pyx_n_s_get_index, 523, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__83)) __PYX_ERR(0, 523, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __pyx_unpickle_ScheduleGenerator(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
 *     cdef object __pyx_PickleError
 *     cdef object __pyx_result
 */
  __pyx_tuple__84 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__84)) __PYX_ERR(1, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__84);
  __Pyx_GIVEREF(__pyx_tuple__84);
  __pyx_codeobj__85 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__84, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_ScheduleGenerator, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__85)) __PYX_ERR(1, 1, __pyx_L1_error)
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  __pyx_float_0_0 = PyFloat_FromDouble(0.0); if (unlikely(!__pyx_float_0_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_222419149 = PyInt_FromLong(222419149L); if (unlikely(!__pyx_int_222419149)) __PYX_ERR(0, 1, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/

static int __Pyx_modinit_global_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
  /*--- Global init code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_variable_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
  /*--- Variable export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
  /*--- Function export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_type_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
  /*--- Type init code ---*/
  __pyx_vtabptr_8_redukti_ADVar = &__pyx_vtable_8_redukti_ADVar;
  __pyx_vtable_8_redukti_ADVar.dup = (PyObject *(*)(redukti_adouble_t *))__pyx_f_8_redukti_5ADVar_dup;
  if (PyType_Ready(&__pyx_type_8_redukti_ADVar) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_ADVar.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_ADVar.tp_dictoffset && __pyx_type_8_redukti_ADVar.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_ADVar.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_8_redukti_ADVar, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 30, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_8_redukti_5ADVar___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_8_redukti_5ADVar___init__.doc = __pyx_doc_8_redukti_5ADVar___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_8_redukti_5ADVar___init__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_8_redukti_ADVar.tp_dict, __pyx_vtabptr_8_redukti_ADVar) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ADVar, (PyObject *)&__pyx_type_8_redukti_ADVar) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_ADVar) < 0) __PYX_ERR(0, 30, __pyx_L1_error)
  __pyx_ptype_8_redukti_ADVar = &__pyx_type_8_redukti_ADVar;
  __pyx_vtabptr_8_redukti_Date = &__pyx_vtable_8_redukti_Date;
  __pyx_vtable_8_redukti_Date.day = (int (*)(struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_4Date_day;
  __pyx_vtable_8_redukti_Date.month = (int (*)(struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_4Date_month;
  __pyx_vtable_8_redukti_Date.year = (int (*)(struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_4Date_year;
  __pyx_vtable_8_redukti_Date.serial = (int (*)(struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_4Date_serial;
  if (PyType_Ready(&__pyx_type_8_redukti_Date) < 0) __PYX_ERR(0, 154, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_Date.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_Date.tp_dictoffset && __pyx_type_8_redukti_Date.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_Date.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_8_redukti_Date, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 154, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_8_redukti_4Date___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_8_redukti_4Date___init__.doc = __pyx_doc_8_redukti_4Date___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_8_redukti_4Date___init__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_8_redukti_Date.tp_dict, __pyx_vtabptr_8_redukti_Date) < 0) __PYX_ERR(0, 154, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Date, (PyObject *)&__pyx_type_8_redukti_Date) < 0) __PYX_ERR(0, 154, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_Date) < 0) __PYX_ERR(0, 154, __pyx_L1_error)
  __pyx_ptype_8_redukti_Date = &__pyx_type_8_redukti_Date;
  if (PyType_Ready(&__pyx_type_8_redukti_ScheduleGenerator) < 0) __PYX_ERR(0, 240, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_ScheduleGenerator.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_ScheduleGenerator.tp_dictoffset && __pyx_type_8_redukti_ScheduleGenerator.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_ScheduleGenerator.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_ScheduleGenerator, (PyObject *)&__pyx_type_8_redukti_ScheduleGenerator) < 0) __PYX_ERR(0, 240, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_ScheduleGenerator) < 0) __PYX_ERR(0, 240, __pyx_L1_error)
  __pyx_ptype_8_redukti_ScheduleGenerator = &__pyx_type_8_redukti_ScheduleGenerator;
  __pyx_vtabptr_8_redukti_Calendar = &__pyx_vtable_8_redukti_Calendar;
  __pyx_vtable_8_redukti_Calendar.is_holiday = (int (*)(struct __pyx_obj_8_redukti_Calendar *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_8Calendar_is_holiday;
  if (PyType_Ready(&__pyx_type_8_redukti_Calendar) < 0) __PYX_ERR(0, 290, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_Calendar.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_Calendar.tp_dictoffset && __pyx_type_8_redukti_Calendar.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_Calendar.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_8_redukti_Calendar, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 290, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_8_redukti_8Calendar___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_8_redukti_8Calendar___init__.doc = __pyx_doc_8_redukti_8Calendar___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_8_redukti_8Calendar___init__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_8_redukti_Calendar.tp_dict, __pyx_vtabptr_8_redukti_Calendar) < 0) __PYX_ERR(0, 290, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Calendar, (PyObject *)&__pyx_type_8_redukti_Calendar) < 0) __PYX_ERR(0, 290, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_Calendar) < 0) __PYX_ERR(0, 290, __pyx_L1_error)
  __pyx_ptype_8_redukti_Calendar = &__pyx_type_8_redukti_Calendar;
  __pyx_vtabptr_8_redukti_DayFraction = &__pyx_vtable_8_redukti_DayFraction;
  __pyx_vtable_8_redukti_DayFraction.year_fraction = (double (*)(struct __pyx_obj_8_redukti_DayFraction *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_11DayFraction_year_fraction;
  __pyx_vtable_8_redukti_DayFraction.year_fraction_with_finalperiod = (double (*)(struct __pyx_obj_8_redukti_DayFraction *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int, int __pyx_skip_dispatch))__pyx_f_8_redukti_11DayFraction_year_fraction_with_finalperiod;
  __pyx_vtable_8_redukti_DayFraction.year_fraction_with_refdates = (double (*)(struct __pyx_obj_8_redukti_DayFraction *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_11DayFraction_year_fraction_with_refdates;
  if (PyType_Ready(&__pyx_type_8_redukti_DayFraction) < 0) __PYX_ERR(0, 412, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_DayFraction.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_DayFraction.tp_dictoffset && __pyx_type_8_redukti_DayFraction.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_DayFraction.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_8_redukti_DayFraction, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 412, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_8_redukti_11DayFraction___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_8_redukti_11DayFraction___init__.doc = __pyx_doc_8_redukti_11DayFraction___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_8_redukti_11DayFraction___init__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_8_redukti_DayFraction.tp_dict, __pyx_vtabptr_8_redukti_DayFraction) < 0) __PYX_ERR(0, 412, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_DayFraction, (PyObject *)&__pyx_type_8_redukti_DayFraction) < 0) __PYX_ERR(0, 412, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_DayFraction) < 0) __PYX_ERR(0, 412, __pyx_L1_error)
  __pyx_ptype_8_redukti_DayFraction = &__pyx_type_8_redukti_DayFraction;
  __pyx_vtabptr_8_redukti_InterestRateIndex = &__pyx_vtable_8_redukti_InterestRateIndex;
  __pyx_vtable_8_redukti_InterestRateIndex.value_date = (struct __pyx_obj_8_redukti_Date *(*)(struct __pyx_obj_8_redukti_InterestRateIndex *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_17InterestRateIndex_value_date;
  __pyx_vtable_8_redukti_InterestRateIndex.fixing_date = (struct __pyx_obj_8_redukti_Date *(*)(struct __pyx_obj_8_redukti_InterestRateIndex *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_17InterestRateIndex_fixing_date;
  __pyx_vtable_8_redukti_InterestRateIndex.maturity_date = (struct __pyx_obj_8_redukti_Date *(*)(struct __pyx_obj_8_redukti_InterestRateIndex *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_17InterestRateIndex_maturity_date;
  __pyx_vtable_8_redukti_InterestRateIndex.adjust_date = (struct __pyx_obj_8_redukti_Date *(*)(struct __pyx_obj_8_redukti_InterestRateIndex *, struct __pyx_obj_8_redukti_Date *, int, int __pyx_skip_dispatch))__pyx_f_8_redukti_17InterestRateIndex_adjust_date;
  if (PyType_Ready(&__pyx_type_8_redukti_InterestRateIndex) < 0) __PYX_ERR(0, 496, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_InterestRateIndex.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_InterestRateIndex.tp_dictoffset && __pyx_type_8_redukti_InterestRateIndex.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_InterestRateIndex.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_8_redukti_InterestRateIndex.tp_dict, __pyx_vtabptr_8_redukti_InterestRateIndex) < 0) __PYX_ERR(0, 496, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_InterestRateIndex, (PyObject *)&__pyx_type_8_redukti_InterestRateIndex) < 0) __PYX_ERR(0, 496, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_InterestRateIndex) < 0) __PYX_ERR(0, 496, __pyx_L1_error)
  __pyx_ptype_8_redukti_InterestRateIndex = &__pyx_type_8_redukti_InterestRateIndex;
  __pyx_vtabptr_8_redukti_Interpolator = &__pyx_vtable_8_redukti_Interpolator;
  __pyx_vtable_8_redukti_Interpolator.interpolate = (double (*)(struct __pyx_obj_8_redukti_Interpolator *, double, int __pyx_skip_dispatch))__pyx_f_8_redukti_12Interpolator_interpolate;
  __pyx_vtable_8_redukti_Interpolator.interpolate_with_sensitivities_ = (struct __pyx_obj_8_redukti_ADVar *(*)(struct __pyx_obj_8_redukti_Interpolator *, double, redukti::FixedRegionAllocator *))__pyx_f_8_redukti_12Interpolator_interpolate_with_sensitivities_;
  __pyx_vtable_8_redukti_Interpolator.interpolate_with_sensitivities = (struct __pyx_obj_8_redukti_ADVar *(*)(struct __pyx_obj_8_redukti_Interpolator *, double, int __pyx_skip_dispatch))__pyx_f_8_redukti_12Interpolator_interpolate_with_sensitivities;
  if (PyType_Ready(&__pyx_type_8_redukti_Interpolator) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_Interpolator.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_Interpolator.tp_dictoffset && __pyx_type_8_redukti_Interpolator.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_Interpolator.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_8_redukti_Interpolator.tp_dict, __pyx_vtabptr_8_redukti_Interpolator) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Interpolator, (PyObject *)&__pyx_type_8_redukti_Interpolator) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_Interpolator) < 0) __PYX_ERR(0, 591, __pyx_L1_error)
  __pyx_ptype_8_redukti_Interpolator = &__pyx_type_8_redukti_Interpolator;
  __pyx_vtabptr_8_redukti_CurveId = &__pyx_vtable_8_redukti_CurveId;
  __pyx_vtable_8_redukti_CurveId.id = (PY_LONG_LONG (*)(struct __pyx_obj_8_redukti_CurveId *, int __pyx_skip_dispatch))__pyx_f_8_redukti_7CurveId_id;
  if (PyType_Ready(&__pyx_type_8_redukti_CurveId) < 0) __PYX_ERR(0, 652, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_CurveId.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_CurveId.tp_dictoffset && __pyx_type_8_redukti_CurveId.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_CurveId.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_8_redukti_CurveId.tp_dict, __pyx_vtabptr_8_redukti_CurveId) < 0) __PYX_ERR(0, 652, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_CurveId, (PyObject *)&__pyx_type_8_redukti_CurveId) < 0) __PYX_ERR(0, 652, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_CurveId) < 0) __PYX_ERR(0, 652, __pyx_L1_error)
  __pyx_ptype_8_redukti_CurveId = &__pyx_type_8_redukti_CurveId;
  __pyx_vtabptr_8_redukti_InterpolatedYieldCurve = &__pyx_vtable_8_redukti_InterpolatedYieldCurve;
  __pyx_vtable_8_redukti_InterpolatedYieldCurve.discount = (double (*)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_22InterpolatedYieldCurve_discount;
  __pyx_vtable_8_redukti_InterpolatedYieldCurve.zero_rate = (double (*)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_22InterpolatedYieldCurve_zero_rate;
  __pyx_vtable_8_redukti_InterpolatedYieldCurve.forward_rate = (double (*)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_22InterpolatedYieldCurve_forward_rate;
  __pyx_vtable_8_redukti_InterpolatedYieldCurve.time_from_reference = (double (*)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_22InterpolatedYieldCurve_time_from_reference;
  __pyx_vtable_8_redukti_InterpolatedYieldCurve.get_sensitivities_ = (struct __pyx_obj_8_redukti_ADVar *(*)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, double, redukti::FixedRegionAllocator *))__pyx_f_8_redukti_22InterpolatedYieldCurve_get_sensitivities_;
  __pyx_vtable_8_redukti_InterpolatedYieldCurve.get_sensitivities = (struct __pyx_obj_8_redukti_ADVar *(*)(struct __pyx_obj_8_redukti_InterpolatedYieldCurve *, double, int __pyx_skip_dispatch))__pyx_f_8_redukti_22InterpolatedYieldCurve_get_sensitivities;
  if (PyType_Ready(&__pyx_type_8_redukti_InterpolatedYieldCurve) < 0) __PYX_ERR(0, 664, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_InterpolatedYieldCurve.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_InterpolatedYieldCurve.tp_dictoffset && __pyx_type_8_redukti_InterpolatedYieldCurve.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_InterpolatedYieldCurve.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_8_redukti_InterpolatedYieldCurve.tp_dict, __pyx_vtabptr_8_redukti_InterpolatedYieldCurve) < 0) __PYX_ERR(0, 664, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_InterpolatedYieldCurve, (PyObject *)&__pyx_type_8_redukti_InterpolatedYieldCurve) < 0) __PYX_ERR(0, 664, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_InterpolatedYieldCurve) < 0) __PYX_ERR(0, 664, __pyx_L1_error)
  __pyx_ptype_8_redukti_InterpolatedYieldCurve = &__pyx_type_8_redukti_InterpolatedYieldCurve;
  __pyx_vtabptr_8_redukti_SvenssonCurve = &__pyx_vtable_8_redukti_SvenssonCurve;
  __pyx_vtable_8_redukti_SvenssonCurve.discount = (double (*)(struct __pyx_obj_8_redukti_SvenssonCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_13SvenssonCurve_discount;
  __pyx_vtable_8_redukti_SvenssonCurve.zero_rate = (double (*)(struct __pyx_obj_8_redukti_SvenssonCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_13SvenssonCurve_zero_rate;
  __pyx_vtable_8_redukti_SvenssonCurve.forward_rate = (double (*)(struct __pyx_obj_8_redukti_SvenssonCurve *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_13SvenssonCurve_forward_rate;
  __pyx_vtable_8_redukti_SvenssonCurve.time_from_reference = (double (*)(struct __pyx_obj_8_redukti_SvenssonCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_13SvenssonCurve_time_from_reference;
  if (PyType_Ready(&__pyx_type_8_redukti_SvenssonCurve) < 0) __PYX_ERR(0, 778, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_SvenssonCurve.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_SvenssonCurve.tp_dictoffset && __pyx_type_8_redukti_SvenssonCurve.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_SvenssonCurve.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_8_redukti_SvenssonCurve.tp_dict, __pyx_vtabptr_8_redukti_SvenssonCurve) < 0) __PYX_ERR(0, 778, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_SvenssonCurve, (PyObject *)&__pyx_type_8_redukti_SvenssonCurve) < 0) __PYX_ERR(0, 778, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_SvenssonCurve) < 0) __PYX_ERR(0, 778, __pyx_L1_error)
  __pyx_ptype_8_redukti_SvenssonCurve = &__pyx_type_8_redukti_SvenssonCurve;
  __pyx_vtabptr_8_redukti_YieldCurve = &__pyx_vtable_8_redukti_YieldCurve;
  __pyx_vtable_8_redukti_YieldCurve.discount = (double (*)(struct __pyx_obj_8_redukti_YieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_10YieldCurve_discount;
  __pyx_vtable_8_redukti_YieldCurve.zero_rate = (double (*)(struct __pyx_obj_8_redukti_YieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_10YieldCurve_zero_rate;
  __pyx_vtable_8_redukti_YieldCurve.forward_rate = (double (*)(struct __pyx_obj_8_redukti_YieldCurve *, struct __pyx_obj_8_redukti_Date *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_10YieldCurve_forward_rate;
  __pyx_vtable_8_redukti_YieldCurve.time_from_reference = (double (*)(struct __pyx_obj_8_redukti_YieldCurve *, struct __pyx_obj_8_redukti_Date *, int __pyx_skip_dispatch))__pyx_f_8_redukti_10YieldCurve_time_from_reference;
  __pyx_vtable_8_redukti_YieldCurve.get_sensitivities_ = (struct __pyx_obj_8_redukti_ADVar *(*)(struct __pyx_obj_8_redukti_YieldCurve *, double, redukti::FixedRegionAllocator *))__pyx_f_8_redukti_10YieldCurve_get_sensitivities_;
  __pyx_vtable_8_redukti_YieldCurve.get_sensitivities = (struct __pyx_obj_8_redukti_ADVar *(*)(struct __pyx_obj_8_redukti_YieldCurve *, double, int __pyx_skip_dispatch))__pyx_f_8_redukti_10YieldCurve_get_sensitivities;
  if (PyType_Ready(&__pyx_type_8_redukti_YieldCurve) < 0) __PYX_ERR(0, 864, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_YieldCurve.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_YieldCurve.tp_dictoffset && __pyx_type_8_redukti_YieldCurve.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_YieldCurve.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  if (__Pyx_SetVtable(__pyx_type_8_redukti_YieldCurve.tp_dict, __pyx_vtabptr_8_redukti_YieldCurve) < 0) __PYX_ERR(0, 864, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_YieldCurve, (PyObject *)&__pyx_type_8_redukti_YieldCurve) < 0) __PYX_ERR(0, 864, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_YieldCurve) < 0) __PYX_ERR(0, 864, __pyx_L1_error)
  __pyx_ptype_8_redukti_YieldCurve = &__pyx_type_8_redukti_YieldCurve;
  __pyx_vtabptr_8_redukti_InMemoryRequestProcessor = &__pyx_vtable_8_redukti_InMemoryRequestProcessor;
  __pyx_vtable_8_redukti_InMemoryRequestProcessor.serve = (PyObject *(*)(struct __pyx_obj_8_redukti_InMemoryRequestProcessor *, PyObject *, int __pyx_skip_dispatch))__pyx_f_8_redukti_24InMemoryRequestProcessor_serve;
  if (PyType_Ready(&__pyx_type_8_redukti_InMemoryRequestProcessor) < 0) __PYX_ERR(0, 973, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_8_redukti_InMemoryRequestProcessor.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_8_redukti_InMemoryRequestProcessor.tp_dictoffset && __pyx_type_8_redukti_InMemoryRequestProcessor.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_8_redukti_InMemoryRequestProcessor.tp_getattro = __Pyx_PyObject_GenericGetAttr;
  }
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_8_redukti_InMemoryRequestProcessor, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 973, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_8_redukti_24InMemoryRequestProcessor___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_8_redukti_24InMemoryRequestProcessor___init__.doc = __pyx_doc_8_redukti_24InMemoryRequestProcessor___init__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_8_redukti_24InMemoryRequestProcessor___init__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_8_redukti_InMemoryRequestProcessor.tp_dict, __pyx_vtabptr_8_redukti_InMemoryRequestProcessor) < 0) __PYX_ERR(0, 973, __pyx_L1_error)
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_InMemoryRequestProcessor, (PyObject *)&__pyx_type_8_redukti_InMemoryRequestProcessor) < 0) __PYX_ERR(0, 973, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_8_redukti_InMemoryRequestProcessor) < 0) __PYX_ERR(0, 973, __pyx_L1_error)
  __pyx_ptype_8_redukti_InMemoryRequestProcessor = &__pyx_type_8_redukti_InMemoryRequestProcessor;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_modinit_type_import_code(void) {
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
  /*--- Type import code ---*/
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 9, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
  #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
  sizeof(PyTypeObject),
  #else
  sizeof(PyHeapTypeObject),
  #endif
  __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 8, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_4bool_bool) __PYX_ERR(4, 8, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(5, 15, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_7complex_complex) __PYX_ERR(5, 15, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyImport_ImportModule("array"); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 58, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_ptype_7cpython_5array_array = __Pyx_ImportType(__pyx_t_1, "array", "array", sizeof(arrayobject), __Pyx_ImportType_CheckSize_Warn);
   if (!__pyx_ptype_7cpython_5array_array) __PYX_ERR(2, 58, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_modinit_variable_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
  /*--- Variable import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
  /*--- Function import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}


#if PY_MAJOR_VERSION < 3
#ifdef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC void
#else
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#endif
#else
#ifdef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC PyObject *
#else
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#endif
#endif


#if PY_MAJOR_VERSION < 3
__Pyx_PyMODINIT_FUNC init_redukti(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC init_redukti(void)
#else
__Pyx_PyMODINIT_FUNC PyInit__redukti(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC PyInit__redukti(void)
#if CYTHON_PEP489_MULTI_PHASE_INIT
{
  return PyModuleDef_Init(&__pyx_moduledef);
}
static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
    #if PY_VERSION_HEX >= 0x030700A1
    static PY_INT64_T main_interpreter_id = -1;
    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
    if (main_interpreter_id == -1) {
        main_interpreter_id = current_id;
        return (unlikely(current_id == -1)) ? -1 : 0;
    } else if (unlikely(main_interpreter_id != current_id))
    #else
    static PyInterpreterState *main_interpreter = NULL;
    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
    if (!main_interpreter) {
        main_interpreter = current_interpreter;
    } else if (unlikely(main_interpreter != current_interpreter))
    #endif
    {
        PyErr_SetString(
            PyExc_ImportError,
            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
        return -1;
    }
    return 0;
}
static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
    PyObject *value = PyObject_GetAttrString(spec, from_name);
    int result = 0;
    if (likely(value)) {
        if (allow_none || value != Py_None) {
            result = PyDict_SetItemString(moddict, to_name, value);
        }
        Py_DECREF(value);
    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Clear();
    } else {
        result = -1;
    }
    return result;
}
static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
    PyObject *module = NULL, *moddict, *modname;
    if (__Pyx_check_single_interpreter())
        return NULL;
    if (__pyx_m)
        return __Pyx_NewRef(__pyx_m);
    modname = PyObject_GetAttrString(spec, "name");
    if (unlikely(!modname)) goto bad;
    module = PyModule_NewObject(modname);
    Py_DECREF(modname);
    if (unlikely(!module)) goto bad;
    moddict = PyModule_GetDict(module);
    if (unlikely(!moddict)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
    return module;
bad:
    Py_XDECREF(module);
    return NULL;
}


static CYTHON_SMALL_CODE int __pyx_pymod_exec__redukti(PyObject *__pyx_pyinit_module)
#endif
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannyDeclarations
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  if (__pyx_m) {
    if (__pyx_m == __pyx_pyinit_module) return 0;
    PyErr_SetString(PyExc_RuntimeError, "Module '_redukti' has already been imported. Re-initialisation is not supported.");
    return -1;
  }
  #elif PY_MAJOR_VERSION >= 3
  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
  #endif
  #if CYTHON_REFNANNY
__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
if (!__Pyx_RefNanny) {
  PyErr_Clear();
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
  if (!__Pyx_RefNanny)
      Py_FatalError("failed to import 'refnanny' module");
}
#endif
  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit__redukti(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pxy_PyFrame_Initialize_Offsets
  __Pxy_PyFrame_Initialize_Offsets();
  #endif
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_AsyncGen_USED
  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  __pyx_m = __pyx_pyinit_module;
  Py_INCREF(__pyx_m);
  #else
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("_redukti", __pyx_methods, __pyx_k_Implements_the_interface_to_Ope, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_b);
  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_cython_runtime);
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main__redukti) {
    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "_redukti")) {
      if (unlikely(PyDict_SetItemString(modules, "_redukti", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global type/function init code ---*/
  (void)__Pyx_modinit_global_init_code();
  (void)__Pyx_modinit_variable_export_code();
  (void)__Pyx_modinit_function_export_code();
  if (unlikely(__Pyx_modinit_type_init_code() != 0)) goto __pyx_L1_error;
  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;
  (void)__Pyx_modinit_variable_import_code();
  (void)__Pyx_modinit_function_import_code();
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "_redukti.pyx":22
 * from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free
 * cimport autodiff, date, enums, schedule, calendar, dayfraction, index, allocator, interpolator, curve, request_processor
 * from redukti import schedule_pb2             # <<<<<<<<<<<<<<
 * from redukti import services_pb2
 * from libcpp.string cimport string
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 22, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_schedule_pb2);
  __Pyx_GIVEREF(__pyx_n_s_schedule_pb2);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_schedule_pb2);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_redukti, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 22, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_schedule_pb2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 22, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_schedule_pb2, __pyx_t_1) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "_redukti.pyx":23
 * cimport autodiff, date, enums, schedule, calendar, dayfraction, index, allocator, interpolator, curve, request_processor
 * from redukti import schedule_pb2
 * from redukti import services_pb2             # <<<<<<<<<<<<<<
 * from libcpp.string cimport string
 * from libcpp.memory cimport unique_ptr
 */
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 23, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_services_pb2);
  __Pyx_GIVEREF(__pyx_n_s_services_pb2);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_services_pb2);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_redukti, __pyx_t_2, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 23, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_services_pb2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 23, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_services_pb2, __pyx_t_2) < 0) __PYX_ERR(0, 23, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":27
 * from libcpp.memory cimport unique_ptr
 * from cpython cimport array
 * import array             # <<<<<<<<<<<<<<
 * cimport cython
 * 
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_array, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 27, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array, __pyx_t_1) < 0) __PYX_ERR(0, 27, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":190
 * 
 *     @staticmethod
 *     def dmy(unsigned d, unsigned m, int y):             # <<<<<<<<<<<<<<
 *         """
 *         Constructs a Date object from day, month, year.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_8_redukti_4Date_13dmy, NULL, __pyx_n_s_redukti_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_Date->tp_dict, __pyx_n_s_dmy, __pyx_t_1) < 0) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_Date);

  /* "_redukti.pyx":189
 *         return self._serial
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def dmy(unsigned d, unsigned m, int y):
 *         """
 */
  __Pyx_GetNameInClass(__pyx_t_1, (PyObject *)__pyx_ptype_8_redukti_Date, __pyx_n_s_dmy); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_Date->tp_dict, __pyx_n_s_dmy, __pyx_t_2) < 0) __PYX_ERR(0, 190, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_Date);

  /* "_redukti.pyx":217
 * 
 *     @staticmethod
 *     def parse(s):             # <<<<<<<<<<<<<<
 *         """
 *         Parses a string representation of date.
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_8_redukti_4Date_17parse, NULL, __pyx_n_s_redukti_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_Date->tp_dict, __pyx_n_s_parse, __pyx_t_2) < 0) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_Date);

  /* "_redukti.pyx":216
 *         return Date(date.advance(self.serial(), n, unit))
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def parse(s):
 *         """
 */
  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_8_redukti_Date, __pyx_n_s_parse); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 216, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_Date->tp_dict, __pyx_n_s_parse, __pyx_t_1) < 0) __PYX_ERR(0, 217, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_Date);

  /* "_redukti.pyx":247
 * 
 *     @staticmethod
 *     def generate_schedule(schedule_parameters):             # <<<<<<<<<<<<<<
 *         """
 *         Generates a schedule
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_8_redukti_17ScheduleGenerator_1generate_schedule, NULL, __pyx_n_s_redukti_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_ScheduleGenerator->tp_dict, __pyx_n_s_generate_schedule, __pyx_t_1) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_ScheduleGenerator);

  /* "_redukti.pyx":246
 *     """
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def generate_schedule(schedule_parameters):
 *         """
 */
  __Pyx_GetNameInClass(__pyx_t_1, (PyObject *)__pyx_ptype_8_redukti_ScheduleGenerator, __pyx_n_s_generate_schedule); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 246, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_ScheduleGenerator->tp_dict, __pyx_n_s_generate_schedule, __pyx_t_2) < 0) __PYX_ERR(0, 247, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_ScheduleGenerator);

  /* "_redukti.pyx":281
 *             raise ValueError('Invalid business center')
 * 
 * def convert_to_date_array(list values):             # <<<<<<<<<<<<<<
 *     cdef array.array date_array = array.array('i', [])
 *     for v in values:
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_8_redukti_1convert_to_date_array, NULL, __pyx_n_s_redukti_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 281, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_convert_to_date_array, __pyx_t_2) < 0) __PYX_ERR(0, 281, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "_redukti.pyx":364
 * 
 *     def advance(self, Date date, int n, enums.PeriodUnit unit,
 *                 enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING, bint is_eom = False):             # <<<<<<<<<<<<<<
 *         """
 *         Advances the given date by the given period and if the resulting date is a holiday then adjusts it to be on a business day.
 */
  __pyx_k__22 = redukti::FOLLOWING;

  /* "_redukti.pyx":381
 *         return Date(self._calendar.advance(date.serial(), n, unit, convention, is_eom))
 * 
 *     def adjust(self, Date date, enums.BusinessDayConvention convention = enums.BusinessDayConvention.FOLLOWING):             # <<<<<<<<<<<<<<
 *         """
 *         If given date falls on holiday then a new date is computed that is a business day, else same date is returned
 */
  __pyx_k__23 = redukti::FOLLOWING;

  /* "_redukti.pyx":395
 * 
 *     @staticmethod
 *     def register_calendar(enums.BusinessCenter id, list holidays):             # <<<<<<<<<<<<<<
 *         """
 *         Creates a calendar from a set of holidays and assign it to the business center
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_8_redukti_8Calendar_13register_calendar, NULL, __pyx_n_s_redukti_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 395, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_Calendar->tp_dict, __pyx_n_s_register_calendar, __pyx_t_2) < 0) __PYX_ERR(0, 395, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_Calendar);

  /* "_redukti.pyx":394
 *         return Date(self._calendar.adjust(date.serial(), convention))
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def register_calendar(enums.BusinessCenter id, list holidays):
 *         """
 */
  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_8_redukti_Calendar, __pyx_n_s_register_calendar); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 395, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_Calendar->tp_dict, __pyx_n_s_register_calendar, __pyx_t_1) < 0) __PYX_ERR(0, 395, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_Calendar);

  /* "_redukti.pyx":509
 * 
 *     @staticmethod
 *     def get_index_by_isdaindex(enums.IsdaIndex isda_index, enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains an instance by IsdaIndex and Tenor
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_8_redukti_17InterestRateIndex_3get_index_by_isdaindex, NULL, __pyx_n_s_redukti_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 509, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_InterestRateIndex->tp_dict, __pyx_n_s_get_index_by_isdaindex, __pyx_t_1) < 0) __PYX_ERR(0, 509, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_InterestRateIndex);

  /* "_redukti.pyx":508
 *         self._index = NULL
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def get_index_by_isdaindex(enums.IsdaIndex isda_index, enums.Tenor tenor):
 *         """
 */
  __Pyx_GetNameInClass(__pyx_t_1, (PyObject *)__pyx_ptype_8_redukti_InterestRateIndex, __pyx_n_s_get_index_by_isdaindex); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 509, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 508, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_InterestRateIndex->tp_dict, __pyx_n_s_get_index_by_isdaindex, __pyx_t_2) < 0) __PYX_ERR(0, 509, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_InterestRateIndex);

  /* "_redukti.pyx":523
 * 
 *     @staticmethod
 *     def get_index(enums.Currency currency, enums.IndexFamily index_family, enums.Tenor tenor):             # <<<<<<<<<<<<<<
 *         """
 *         Obtains an instance by Currency, IndexFamily and Tenor
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_8_redukti_17InterestRateIndex_5get_index, NULL, __pyx_n_s_redukti_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 523, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_InterestRateIndex->tp_dict, __pyx_n_s_get_index, __pyx_t_2) < 0) __PYX_ERR(0, 523, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_InterestRateIndex);

  /* "_redukti.pyx":522
 *         return obj
 * 
 *     @staticmethod             # <<<<<<<<<<<<<<
 *     def get_index(enums.Currency currency, enums.IndexFamily index_family, enums.Tenor tenor):
 *         """
 */
  __Pyx_GetNameInClass(__pyx_t_2, (PyObject *)__pyx_ptype_8_redukti_InterestRateIndex, __pyx_n_s_get_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 523, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 522, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_8_redukti_InterestRateIndex->tp_dict, __pyx_n_s_get_index, __pyx_t_1) < 0) __PYX_ERR(0, 523, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_8_redukti_InterestRateIndex);

  /* "_redukti.pyx":657
 *     def __cinit__(self, enums.PricingCurveType pricing_curve_type, enums.Currency ccy, enums.IndexFamily index_family,
 *                   enums.Tenor tenor,
 *                   Date as_of_date, int cycle = 0, enums.MarketDataQualifier qual = enums.MDQ_NORMAL, int scenario = 0):             # <<<<<<<<<<<<<<
 *         self._id = curve.make_curve_id(pricing_curve_type, ccy, index_family, tenor, as_of_date.serial(),
 *                                        cycle, qual, scenario)
 */
  __pyx_k__43 = redukti::MDQ_NORMAL;

  /* "_redukti.pyx":874
 * 
 *     def __init__(self, Date business_date, curve_defn, zero_curve, int deriv_order = 2,
 *                   enums.PricingCurveType type = enums.PRICING_CURVE_TYPE_FORWARD,             # <<<<<<<<<<<<<<
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):
 *         pass
 */
  __pyx_k__55 = redukti::PRICING_CURVE_TYPE_FORWARD;

  /* "_redukti.pyx":875
 *     def __init__(self, Date business_date, curve_defn, zero_curve, int deriv_order = 2,
 *                   enums.PricingCurveType type = enums.PRICING_CURVE_TYPE_FORWARD,
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):             # <<<<<<<<<<<<<<
 *         pass
 * 
 */
  __pyx_k__56 = redukti::MDQ_NORMAL;

  /* "_redukti.pyx":879
 * 
 *     def __cinit__(self, Date business_date, curve_defn, zero_curve, int deriv_order = 2,
 *                   enums.PricingCurveType type = enums.PRICING_CURVE_TYPE_FORWARD,             # <<<<<<<<<<<<<<
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):
 *         cdef string str = curve_defn.SerializeToString()
 */
  __pyx_k__57 = redukti::PRICING_CURVE_TYPE_FORWARD;

  /* "_redukti.pyx":880
 *     def __cinit__(self, Date business_date, curve_defn, zero_curve, int deriv_order = 2,
 *                   enums.PricingCurveType type = enums.PRICING_CURVE_TYPE_FORWARD,
 *                   enums.MarketDataQualifier mdq = enums.MDQ_NORMAL, int cycle = 0, int scenario = 0):             # <<<<<<<<<<<<<<
 *         cdef string str = curve_defn.SerializeToString()
 *         if not self._definition.ParseFromString(str):
 */
  __pyx_k__58 = redukti::MDQ_NORMAL;

  /* "(tree fragment)":1
 * def __pyx_unpickle_ScheduleGenerator(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
 *     cdef object __pyx_PickleError
 *     cdef object __pyx_result
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_8_redukti_3__pyx_unpickle_ScheduleGenerator, NULL, __pyx_n_s_redukti_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_ScheduleGenerator, __pyx_t_1) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "_redukti.pyx":1
 * # DO NOT REMOVE COPYRIGHT NOTICES OR THIS HEADER.             # <<<<<<<<<<<<<<
 * #
 * # Contributor(s):
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init _redukti", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_CLEAR(__pyx_m);
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init _redukti");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  return (__pyx_m != NULL) ? 0 : -1;
  #elif PY_MAJOR_VERSION >= 3
  return __pyx_m;
  #else
  return;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule(modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, "RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* PyObjectGetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyErrFetchRestore */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* RaiseException */
#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
    if (cause) {
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = __Pyx_PyThreadState_Current;
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* ArgTypeTest */
static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    else if (exact) {
        #if PY_MAJOR_VERSION == 2
        if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(__Pyx_TypeCheck(obj, type))) return 1;
    }
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
    return 0;
}

/* PyCFunctionFastCall */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    int flags = PyCFunction_GET_FLAGS(func);
    assert(PyCFunction_Check(func));
    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
    assert(nargs >= 0);
    assert(nargs == 0 || args != NULL);
    /* _PyCFunction_FastCallDict() must not be called with an exception set,
       because it may clear it (directly or indirectly) and so the
       caller loses its exception */
    assert(!PyErr_Occurred());
    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
    } else {
        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
    }
}
#endif

/* PyFunctionFastCall */
#if CYTHON_FAST_PYCALL
static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                               PyObject *globals) {
    PyFrameObject *f;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;
    assert(globals != NULL);
    /* XXX Perhaps we should create a specialized
       PyFrame_New() that doesn't take locals, but does
       take builtins without sanity checking them.
       */
    assert(tstate != NULL);
    f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
    for (i = 0; i < na; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
    ++tstate->recursion_depth;
    Py_DECREF(f);
    --tstate->recursion_depth;
    return result;
}
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs) {
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
    PyObject *globals = PyFunction_GET_GLOBALS(func);
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    PyObject *closure;
#if PY_MAJOR_VERSION >= 3
    PyObject *kwdefs;
#endif
    PyObject *kwtuple, **k;
    PyObject **d;
    Py_ssize_t nd;
    Py_ssize_t nk;
    PyObject *result;
    assert(kwargs == NULL || PyDict_Check(kwargs));
    nk = kwargs ? PyDict_Size(kwargs) : 0;
    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
        return NULL;
    }
    if (
#if PY_MAJOR_VERSION >= 3
            co->co_kwonlyargcount == 0 &&
#endif
            likely(kwargs == NULL || nk == 0) &&
            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
        if (argdefs == NULL && co->co_argcount == nargs) {
            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
            goto done;
        }
        else if (nargs == 0 && argdefs != NULL
                 && co->co_argcount == Py_SIZE(argdefs)) {
            /* function called with no arguments, but all parameters have
               a default value: use default values as arguments .*/
            args = &PyTuple_GET_ITEM(argdefs, 0);
            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
            goto done;
        }
    }
    if (kwargs != NULL) {
        Py_ssize_t pos, i;
        kwtuple = PyTuple_New(2 * nk);
        if (kwtuple == NULL) {
            result = NULL;
            goto done;
        }
        k = &PyTuple_GET_ITEM(kwtuple, 0);
        pos = i = 0;
        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        }
        nk = i / 2;
    }
    else {
        kwtuple = NULL;
        k = NULL;
    }
    closure = PyFunction_GET_CLOSURE(func);
#if PY_MAJOR_VERSION >= 3
    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
#endif
    if (argdefs != NULL) {
        d = &PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
#if PY_MAJOR_VERSION >= 3
    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, kwdefs, closure);
#else
    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, closure);
#endif
    Py_XDECREF(kwtuple);
done:
    Py_LeaveRecursiveCall();
    return result;
}
#endif
#endif

/* PyObjectCall2Args */
static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
    PyObject *args, *result = NULL;
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(function)) {
        PyObject *args[2] = {arg1, arg2};
        return __Pyx_PyFunction_FastCall(function, args, 2);
    }
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(function)) {
        PyObject *args[2] = {arg1, arg2};
        return __Pyx_PyCFunction_FastCall(function, args, 2);
    }
    #endif
    args = PyTuple_New(2);
    if (unlikely(!args)) goto done;
    Py_INCREF(arg1);
    PyTuple_SET_ITEM(args, 0, arg1);
    Py_INCREF(arg2);
    PyTuple_SET_ITEM(args, 1, arg2);
    Py_INCREF(function);
    result = __Pyx_PyObject_Call(function, args, NULL);
    Py_DECREF(args);
    Py_DECREF(function);
done:
    return result;
}

/* PyObjectCallMethO */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, &arg, 1);
    }
#endif
    if (likely(PyCFunction_Check(func))) {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
#if CYTHON_FAST_PYCCALL
        } else if (PyCFunction_GET_FLAGS(func) & METH_FASTCALL) {
            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
#endif
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* PyDictVersioning */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
    PyObject **dictptr = NULL;
    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
    if (offset) {
#if CYTHON_COMPILING_IN_CPYTHON
        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
#else
        dictptr = _PyObject_GetDictPtr(obj);
#endif
    }
    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
}
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
        return 0;
    return obj_dict_version == __Pyx_get_object_dict_version(obj);
}
#endif

/* PyObjectCallNoArg */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, NULL, 0);
    }
#endif
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || __Pyx_CyFunction_Check(func)))
#else
    if (likely(PyCFunction_Check(func)))
#endif
    {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* WriteUnraisableException */
static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback, CYTHON_UNUSED int nogil) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_PyThreadState_declare
#ifdef WITH_THREAD
    PyGILState_STATE state;
    if (nogil)
        state = PyGILState_Ensure();
#ifdef _MSC_VER
    else state = (PyGILState_STATE)-1;
#endif
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
#ifdef WITH_THREAD
    if (nogil)
        PyGILState_Release(state);
#endif
}

/* GetModuleGlobalName */
#if CYTHON_USE_DICT_VERSIONS
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
#else
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
#endif
{
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    } else if (unlikely(PyErr_Occurred())) {
        return NULL;
    }
#else
    result = PyDict_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
#endif
#else
    result = PyObject_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
    PyErr_Clear();
#endif
    return __Pyx_GetBuiltinName(name);
}

/* PyErrExceptionMatches */
#if CYTHON_FAST_THREAD_STATE
static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
    PyObject *exc_type = tstate->curexc_type;
    if (exc_type == err) return 1;
    if (unlikely(!exc_type)) return 0;
    if (unlikely(PyTuple_Check(err)))
        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
}
#endif

/* GetAttr */
static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
#if CYTHON_USE_TYPE_SLOTS
#if PY_MAJOR_VERSION >= 3
    if (likely(PyUnicode_Check(n)))
#else
    if (likely(PyString_Check(n)))
#endif
        return __Pyx_PyObject_GetAttrStr(o, n);
#endif
    return PyObject_GetAttr(o, n);
}

/* GetAttr3 */
static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
        return NULL;
    __Pyx_PyErr_Clear();
    Py_INCREF(d);
    return d;
}
static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
    PyObject *r = __Pyx_GetAttr(o, n);
    return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
}

/* PyObjectGetMethod */
static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
    PyObject *attr;
#if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
    PyTypeObject *tp = Py_TYPE(obj);
    PyObject *descr;
    descrgetfunc f = NULL;
    PyObject **dictptr, *dict;
    int meth_found = 0;
    assert (*method == NULL);
    if (unlikely(tp->tp_getattro != PyObject_GenericGetAttr)) {
        attr = __Pyx_PyObject_GetAttrStr(obj, name);
        goto try_unpack;
    }
    if (unlikely(tp->tp_dict == NULL) && unlikely(PyType_Ready(tp) < 0)) {
        return 0;
    }
    descr = _PyType_Lookup(tp, name);
    if (likely(descr != NULL)) {
        Py_INCREF(descr);
#if PY_MAJOR_VERSION >= 3
        #ifdef __Pyx_CyFunction_USED
        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
        #else
        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type)))
        #endif
#else
        #ifdef __Pyx_CyFunction_USED
        if (likely(PyFunction_Check(descr) || __Pyx_CyFunction_Check(descr)))
        #else
        if (likely(PyFunction_Check(descr)))
        #endif
#endif
        {
            meth_found = 1;
        } else {
            f = Py_TYPE(descr)->tp_descr_get;
            if (f != NULL && PyDescr_IsData(descr)) {
                attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
                Py_DECREF(descr);
                goto try_unpack;
            }
        }
    }
    dictptr = _PyObject_GetDictPtr(obj);
    if (dictptr != NULL && (dict = *dictptr) != NULL) {
        Py_INCREF(dict);
        attr = __Pyx_PyDict_GetItemStr(dict, name);
        if (attr != NULL) {
            Py_INCREF(attr);
            Py_DECREF(dict);
            Py_XDECREF(descr);
            goto try_unpack;
        }
        Py_DECREF(dict);
    }
    if (meth_found) {
        *method = descr;
        return 1;
    }
    if (f != NULL) {
        attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
        Py_DECREF(descr);
        goto try_unpack;
    }
    if (descr != NULL) {
        *method = descr;
        return 0;
    }
    PyErr_Format(PyExc_AttributeError,
#if PY_MAJOR_VERSION >= 3
                 "'%.50s' object has no attribute '%U'",
                 tp->tp_name, name);
#else
                 "'%.50s' object has no attribute '%.400s'",
                 tp->tp_name, PyString_AS_STRING(name));
#endif
    return 0;
#else
    attr = __Pyx_PyObject_GetAttrStr(obj, name);
    goto try_unpack;
#endif
try_unpack:
#if CYTHON_UNPACK_METHODS
    if (likely(attr) && PyMethod_Check(attr) && likely(PyMethod_GET_SELF(attr) == obj)) {
        PyObject *function = PyMethod_GET_FUNCTION(attr);
        Py_INCREF(function);
        Py_DECREF(attr);
        *method = function;
        return 1;
    }
#endif
    *method = attr;
    return 0;
}

/* PyObjectCallMethod1 */
static PyObject* __Pyx__PyObject_CallMethod1(PyObject* method, PyObject* arg) {
    PyObject *result = __Pyx_PyObject_CallOneArg(method, arg);
    Py_DECREF(method);
    return result;
}
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
    PyObject *method = NULL, *result;
    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
    if (likely(is_method)) {
        result = __Pyx_PyObject_Call2Args(method, obj, arg);
        Py_DECREF(method);
        return result;
    }
    if (unlikely(!method)) return NULL;
    return __Pyx__PyObject_CallMethod1(method, arg);
}

/* append */
static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
    if (likely(PyList_CheckExact(L))) {
        if (unlikely(__Pyx_PyList_Append(L, x) < 0)) return -1;
    } else {
        PyObject* retval = __Pyx_PyObject_CallMethod1(L, __pyx_n_s_append, x);
        if (unlikely(!retval))
            return -1;
        Py_DECREF(retval);
    }
    return 0;
}

/* GetItemInt */
static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    Py_ssize_t wrapped_i = i;
    if (wraparound & unlikely(i < 0)) {
        wrapped_i += PyList_GET_SIZE(o);
    }
    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    Py_ssize_t wrapped_i = i;
    if (wraparound & unlikely(i < 0)) {
        wrapped_i += PyTuple_GET_SIZE(o);
    }
    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
                                                     CYTHON_NCP_UNUSED int wraparound,
                                                     CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return NULL;
                    PyErr_Clear();
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

/* ExtTypeTest */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(__Pyx_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

/* KeywordStringCheck */
static int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

/* BytesEquals */
static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
    if (s1 == s2) {
        return (equals == Py_EQ);
    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
        const char *ps1, *ps2;
        Py_ssize_t length = PyBytes_GET_SIZE(s1);
        if (length != PyBytes_GET_SIZE(s2))
            return (equals == Py_NE);
        ps1 = PyBytes_AS_STRING(s1);
        ps2 = PyBytes_AS_STRING(s2);
        if (ps1[0] != ps2[0]) {
            return (equals == Py_NE);
        } else if (length == 1) {
            return (equals == Py_EQ);
        } else {
            int result;
#if CYTHON_USE_UNICODE_INTERNALS
            Py_hash_t hash1, hash2;
            hash1 = ((PyBytesObject*)s1)->ob_shash;
            hash2 = ((PyBytesObject*)s2)->ob_shash;
            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                return (equals == Py_NE);
            }
#endif
            result = memcmp(ps1, ps2, (size_t)length);
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
        return (equals == Py_NE);
    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
        return (equals == Py_NE);
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
#endif
}

/* UnicodeEquals */
static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
#if PY_MAJOR_VERSION < 3
    PyObject* owned_ref = NULL;
#endif
    int s1_is_unicode, s2_is_unicode;
    if (s1 == s2) {
        goto return_eq;
    }
    s1_is_unicode = PyUnicode_CheckExact(s1);
    s2_is_unicode = PyUnicode_CheckExact(s2);
#if PY_MAJOR_VERSION < 3
    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
        owned_ref = PyUnicode_FromObject(s2);
        if (unlikely(!owned_ref))
            return -1;
        s2 = owned_ref;
        s2_is_unicode = 1;
    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
        owned_ref = PyUnicode_FromObject(s1);
        if (unlikely(!owned_ref))
            return -1;
        s1 = owned_ref;
        s1_is_unicode = 1;
    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
        return __Pyx_PyBytes_Equals(s1, s2, equals);
    }
#endif
    if (s1_is_unicode & s2_is_unicode) {
        Py_ssize_t length;
        int kind;
        void *data1, *data2;
        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
            return -1;
        length = __Pyx_PyUnicode_GET_LENGTH(s1);
        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
            goto return_ne;
        }
#if CYTHON_USE_UNICODE_INTERNALS
        {
            Py_hash_t hash1, hash2;
        #if CYTHON_PEP393_ENABLED
            hash1 = ((PyASCIIObject*)s1)->hash;
            hash2 = ((PyASCIIObject*)s2)->hash;
        #else
            hash1 = ((PyUnicodeObject*)s1)->hash;
            hash2 = ((PyUnicodeObject*)s2)->hash;
        #endif
            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                goto return_ne;
            }
        }
#endif
        kind = __Pyx_PyUnicode_KIND(s1);
        if (kind != __Pyx_PyUnicode_KIND(s2)) {
            goto return_ne;
        }
        data1 = __Pyx_PyUnicode_DATA(s1);
        data2 = __Pyx_PyUnicode_DATA(s2);
        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
            goto return_ne;
        } else if (length == 1) {
            goto return_eq;
        } else {
            int result = memcmp(data1, data2, (size_t)(length * kind));
            #if PY_MAJOR_VERSION < 3
            Py_XDECREF(owned_ref);
            #endif
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & s2_is_unicode) {
        goto return_ne;
    } else if ((s2 == Py_None) & s1_is_unicode) {
        goto return_ne;
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        #if PY_MAJOR_VERSION < 3
        Py_XDECREF(owned_ref);
        #endif
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
return_eq:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_EQ);
return_ne:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_NE);
#endif
}

/* GetException */
#if CYTHON_FAST_THREAD_STATE
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
#endif
{
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_FAST_THREAD_STATE
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_FAST_THREAD_STATE
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_FAST_THREAD_STATE
    #if CYTHON_USE_EXC_INFO_STACK
    {
        _PyErr_StackItem *exc_info = tstate->exc_info;
        tmp_type = exc_info->exc_type;
        tmp_value = exc_info->exc_value;
        tmp_tb = exc_info->exc_traceback;
        exc_info->exc_type = local_type;
        exc_info->exc_value = local_value;
        exc_info->exc_traceback = local_tb;
    }
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

/* SwapException */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = tstate->exc_info;
    tmp_type = exc_info->exc_type;
    tmp_value = exc_info->exc_value;
    tmp_tb = exc_info->exc_traceback;
    exc_info->exc_type = *type;
    exc_info->exc_value = *value;
    exc_info->exc_traceback = *tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
    #endif
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
    PyErr_SetExcInfo(*type, *value, *tb);
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#endif

/* GetTopmostException */
#if CYTHON_USE_EXC_INFO_STACK
static _PyErr_StackItem *
__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
{
    _PyErr_StackItem *exc_info = tstate->exc_info;
    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
           exc_info->previous_item != NULL)
    {
        exc_info = exc_info->previous_item;
    }
    return exc_info;
}
#endif

/* SaveResetException */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
    *type = exc_info->exc_type;
    *value = exc_info->exc_value;
    *tb = exc_info->exc_traceback;
    #else
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    #endif
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = tstate->exc_info;
    tmp_type = exc_info->exc_type;
    tmp_value = exc_info->exc_value;
    tmp_tb = exc_info->exc_traceback;
    exc_info->exc_type = type;
    exc_info->exc_value = value;
    exc_info->exc_traceback = tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
#endif

/* Import */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_MAJOR_VERSION < 3
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* ImportFrom */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

/* HasAttr */
static CYTHON_INLINE int __Pyx_HasAttr(PyObject *o, PyObject *n) {
    PyObject *r;
    if (unlikely(!__Pyx_PyBaseString_Check(n))) {
        PyErr_SetString(PyExc_TypeError,
                        "hasattr(): attribute name must be string");
        return -1;
    }
    r = __Pyx_GetAttr(o, n);
    if (unlikely(!r)) {
        PyErr_Clear();
        return 0;
    } else {
        Py_DECREF(r);
        return 1;
    }
}

/* PyObject_GenericGetAttrNoDict */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
    PyErr_Format(PyExc_AttributeError,
#if PY_MAJOR_VERSION >= 3
                 "'%.50s' object has no attribute '%U'",
                 tp->tp_name, attr_name);
#else
                 "'%.50s' object has no attribute '%.400s'",
                 tp->tp_name, PyString_AS_STRING(attr_name));
#endif
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
    PyObject *descr;
    PyTypeObject *tp = Py_TYPE(obj);
    if (unlikely(!PyString_Check(attr_name))) {
        return PyObject_GenericGetAttr(obj, attr_name);
    }
    assert(!tp->tp_dictoffset);
    descr = _PyType_Lookup(tp, attr_name);
    if (unlikely(!descr)) {
        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
    }
    Py_INCREF(descr);
    #if PY_MAJOR_VERSION < 3
    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
    #endif
    {
        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
        if (unlikely(f)) {
            PyObject *res = f(descr, obj, (PyObject *)tp);
            Py_DECREF(descr);
            return res;
        }
    }
    return descr;
}
#endif

/* PyObject_GenericGetAttr */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
    if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
        return PyObject_GenericGetAttr(obj, attr_name);
    }
    return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
}
#endif

/* SetVTable */
static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

/* SetupReduce */
static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
  int ret;
  PyObject *name_attr;
  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name);
  if (likely(name_attr)) {
      ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
  } else {
      ret = -1;
  }
  if (unlikely(ret < 0)) {
      PyErr_Clear();
      ret = 0;
  }
  Py_XDECREF(name_attr);
  return ret;
}
static int __Pyx_setup_reduce(PyObject* type_obj) {
    int ret = 0;
    PyObject *object_reduce = NULL;
    PyObject *object_reduce_ex = NULL;
    PyObject *reduce = NULL;
    PyObject *reduce_ex = NULL;
    PyObject *reduce_cython = NULL;
    PyObject *setstate = NULL;
    PyObject *setstate_cython = NULL;
#if CYTHON_USE_PYTYPE_LOOKUP
    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto GOOD;
#else
    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto GOOD;
#endif
#if CYTHON_USE_PYTYPE_LOOKUP
    object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto BAD;
#else
    object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto BAD;
#endif
    reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto BAD;
    if (reduce_ex == object_reduce_ex) {
#if CYTHON_USE_PYTYPE_LOOKUP
        object_reduce = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto BAD;
#else
        object_reduce = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto BAD;
#endif
        reduce = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce); if (unlikely(!reduce)) goto BAD;
        if (reduce == object_reduce || __Pyx_setup_reduce_is_named(reduce, __pyx_n_s_reduce_cython)) {
            reduce_cython = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_cython); if (unlikely(!reduce_cython)) goto BAD;
            ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto BAD;
            ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto BAD;
            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
            if (!setstate) PyErr_Clear();
            if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
                setstate_cython = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate_cython); if (unlikely(!setstate_cython)) goto BAD;
                ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto BAD;
                ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto BAD;
            }
            PyType_Modified((PyTypeObject*)type_obj);
        }
    }
    goto GOOD;
BAD:
    if (!PyErr_Occurred())
        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
    ret = -1;
GOOD:
#if !CYTHON_USE_PYTYPE_LOOKUP
    Py_XDECREF(object_reduce);
    Py_XDECREF(object_reduce_ex);
#endif
    Py_XDECREF(reduce);
    Py_XDECREF(reduce_ex);
    Py_XDECREF(reduce_cython);
    Py_XDECREF(setstate);
    Py_XDECREF(setstate_cython);
    return ret;
}

/* TypeImport */
#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
    size_t size, enum __Pyx_ImportType_CheckSize check_size)
{
    PyObject *result = 0;
    char warning[200];
    Py_ssize_t basicsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
#endif
    result = PyObject_GetAttrString(module, class_name);
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%.200s.%.200s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if ((size_t)basicsize < size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        goto bad;
    }
    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        goto bad;
    }
    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility. "
            "Expected %zd from C header, got %zd from PyObject",
            module_name, class_name, size, basicsize);
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(result);
    return NULL;
}
#endif

/* GetNameInClass */
static PyObject *__Pyx_GetGlobalNameAfterAttributeLookup(PyObject *name) {
    PyObject *result;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
        return NULL;
    __Pyx_PyErr_Clear();
    __Pyx_GetModuleGlobalNameUncached(result, name);
    return result;
}
static PyObject *__Pyx__GetNameInClass(PyObject *nmspace, PyObject *name) {
    PyObject *result;
    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
    if (!result) {
        result = __Pyx_GetGlobalNameAfterAttributeLookup(name);
    }
    return result;
}

/* CLineInTraceback */
#ifndef CYTHON_CLINE_IN_TRACEBACK
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
    PyObject *use_cline;
    PyObject *ptype, *pvalue, *ptraceback;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject **cython_runtime_dict;
#endif
    if (unlikely(!__pyx_cython_runtime)) {
        return c_line;
    }
    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
#if CYTHON_COMPILING_IN_CPYTHON
    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
    if (likely(cython_runtime_dict)) {
        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
            use_cline, *cython_runtime_dict,
            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
    } else
#endif
    {
      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
      if (use_cline_obj) {
        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
        Py_DECREF(use_cline_obj);
      } else {
        PyErr_Clear();
        use_cline = NULL;
      }
    }
    if (!use_cline) {
        c_line = 0;
        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
    }
    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
        c_line = 0;
    }
    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
    return c_line;
}
#endif

/* CodeObjectCache */
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    if (c_line) {
        c_line = __Pyx_CLineForTraceback(tstate, c_line);
    }
    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        tstate,            /*PyThreadState *tstate,*/
        py_code,           /*PyCodeObject *code,*/
        __pyx_d,    /*PyObject *globals,*/
        0                  /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntFromPyVerify */
#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) ((int) 0 - (int) 1), const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_enum__redukti_3a__3a_BusinessCenter(enum redukti::BusinessCenter value) {
    const enum redukti::BusinessCenter neg_one = (enum redukti::BusinessCenter) ((enum redukti::BusinessCenter) 0 - (enum redukti::BusinessCenter) 1), const_zero = (enum redukti::BusinessCenter) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(enum redukti::BusinessCenter) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(enum redukti::BusinessCenter) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum redukti::BusinessCenter) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(enum redukti::BusinessCenter) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(enum redukti::BusinessCenter) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(enum redukti::BusinessCenter),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_PY_LONG_LONG(PY_LONG_LONG value) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG) ((PY_LONG_LONG) 0 - (PY_LONG_LONG) 1), const_zero = (PY_LONG_LONG) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(PY_LONG_LONG) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(PY_LONG_LONG) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(PY_LONG_LONG) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(PY_LONG_LONG),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) ((int) 0 - (int) 1), const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* CIntFromPy */
static CYTHON_INLINE unsigned int __Pyx_PyInt_As_unsigned_int(PyObject *x) {
    const unsigned int neg_one = (unsigned int) ((unsigned int) 0 - (unsigned int) 1), const_zero = (unsigned int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(unsigned int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(unsigned int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (unsigned int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (unsigned int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(unsigned int, digit, digits[0])
                case 2:
                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) >= 2 * PyLong_SHIFT) {
                            return (unsigned int) (((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) >= 3 * PyLong_SHIFT) {
                            return (unsigned int) (((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) >= 4 * PyLong_SHIFT) {
                            return (unsigned int) (((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (unsigned int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(unsigned int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(unsigned int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (unsigned int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(unsigned int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(unsigned int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(unsigned int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
                            return (unsigned int) (((unsigned int)-1)*(((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(unsigned int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
                            return (unsigned int) ((((((unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(unsigned int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
                            return (unsigned int) (((unsigned int)-1)*(((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(unsigned int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
                            return (unsigned int) ((((((((unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(unsigned int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
                            return (unsigned int) (((unsigned int)-1)*(((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(unsigned int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(unsigned int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(unsigned int) - 1 > 4 * PyLong_SHIFT) {
                            return (unsigned int) ((((((((((unsigned int)digits[3]) << PyLong_SHIFT) | (unsigned int)digits[2]) << PyLong_SHIFT) | (unsigned int)digits[1]) << PyLong_SHIFT) | (unsigned int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(unsigned int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(unsigned int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(unsigned int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            unsigned int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (unsigned int) -1;
        }
    } else {
        unsigned int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (unsigned int) -1;
        val = __Pyx_PyInt_As_unsigned_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to unsigned int");
    return (unsigned int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to unsigned int");
    return (unsigned int) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::PeriodUnit __Pyx_PyInt_As_enum__redukti_3a__3a_PeriodUnit(PyObject *x) {
    const enum redukti::PeriodUnit neg_one = (enum redukti::PeriodUnit) ((enum redukti::PeriodUnit) 0 - (enum redukti::PeriodUnit) 1), const_zero = (enum redukti::PeriodUnit) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::PeriodUnit) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::PeriodUnit) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::PeriodUnit) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::PeriodUnit) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) (((((enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::PeriodUnit) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) (((((((enum redukti::PeriodUnit)digits[2]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::PeriodUnit) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) (((((((((enum redukti::PeriodUnit)digits[3]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[2]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::PeriodUnit) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::PeriodUnit) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::PeriodUnit, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::PeriodUnit) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::PeriodUnit, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::PeriodUnit) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) (((enum redukti::PeriodUnit)-1)*(((((enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::PeriodUnit) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) ((((((enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) (((enum redukti::PeriodUnit)-1)*(((((((enum redukti::PeriodUnit)digits[2]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::PeriodUnit) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) ((((((((enum redukti::PeriodUnit)digits[2]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) (((enum redukti::PeriodUnit)-1)*(((((((((enum redukti::PeriodUnit)digits[3]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[2]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::PeriodUnit) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PeriodUnit, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PeriodUnit) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::PeriodUnit) ((((((((((enum redukti::PeriodUnit)digits[3]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[2]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[1]) << PyLong_SHIFT) | (enum redukti::PeriodUnit)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::PeriodUnit) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::PeriodUnit, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::PeriodUnit) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::PeriodUnit, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::PeriodUnit val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::PeriodUnit) -1;
        }
    } else {
        enum redukti::PeriodUnit val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::PeriodUnit) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_PeriodUnit(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::PeriodUnit");
    return (enum redukti::PeriodUnit) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::PeriodUnit");
    return (enum redukti::PeriodUnit) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::BusinessDayConvention __Pyx_PyInt_As_enum__redukti_3a__3a_BusinessDayConvention(PyObject *x) {
    const enum redukti::BusinessDayConvention neg_one = (enum redukti::BusinessDayConvention) ((enum redukti::BusinessDayConvention) 0 - (enum redukti::BusinessDayConvention) 1), const_zero = (enum redukti::BusinessDayConvention) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::BusinessDayConvention) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::BusinessDayConvention) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::BusinessDayConvention) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) (((((enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) (((((((enum redukti::BusinessDayConvention)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) (((((((((enum redukti::BusinessDayConvention)digits[3]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::BusinessDayConvention) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::BusinessDayConvention) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::BusinessDayConvention, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::BusinessDayConvention) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::BusinessDayConvention, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::BusinessDayConvention) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) (((enum redukti::BusinessDayConvention)-1)*(((((enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) ((((((enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) (((enum redukti::BusinessDayConvention)-1)*(((((((enum redukti::BusinessDayConvention)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) ((((((((enum redukti::BusinessDayConvention)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) (((enum redukti::BusinessDayConvention)-1)*(((((((((enum redukti::BusinessDayConvention)digits[3]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::BusinessDayConvention) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessDayConvention, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessDayConvention) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::BusinessDayConvention) ((((((((((enum redukti::BusinessDayConvention)digits[3]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessDayConvention)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::BusinessDayConvention) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::BusinessDayConvention, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::BusinessDayConvention) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::BusinessDayConvention, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::BusinessDayConvention val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::BusinessDayConvention) -1;
        }
    } else {
        enum redukti::BusinessDayConvention val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::BusinessDayConvention) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_BusinessDayConvention(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::BusinessDayConvention");
    return (enum redukti::BusinessDayConvention) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::BusinessDayConvention");
    return (enum redukti::BusinessDayConvention) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::BusinessCenter __Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(PyObject *x) {
    const enum redukti::BusinessCenter neg_one = (enum redukti::BusinessCenter) ((enum redukti::BusinessCenter) 0 - (enum redukti::BusinessCenter) 1), const_zero = (enum redukti::BusinessCenter) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::BusinessCenter) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::BusinessCenter) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::BusinessCenter) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::BusinessCenter) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) (((((enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::BusinessCenter) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) (((((((enum redukti::BusinessCenter)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::BusinessCenter) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) (((((((((enum redukti::BusinessCenter)digits[3]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::BusinessCenter) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::BusinessCenter) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::BusinessCenter, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::BusinessCenter) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::BusinessCenter, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::BusinessCenter) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) (((enum redukti::BusinessCenter)-1)*(((((enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::BusinessCenter) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) ((((((enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) (((enum redukti::BusinessCenter)-1)*(((((((enum redukti::BusinessCenter)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::BusinessCenter) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) ((((((((enum redukti::BusinessCenter)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) (((enum redukti::BusinessCenter)-1)*(((((((((enum redukti::BusinessCenter)digits[3]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::BusinessCenter) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::BusinessCenter, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::BusinessCenter) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::BusinessCenter) ((((((((((enum redukti::BusinessCenter)digits[3]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[2]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[1]) << PyLong_SHIFT) | (enum redukti::BusinessCenter)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::BusinessCenter) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::BusinessCenter, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::BusinessCenter) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::BusinessCenter, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::BusinessCenter val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::BusinessCenter) -1;
        }
    } else {
        enum redukti::BusinessCenter val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::BusinessCenter) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_BusinessCenter(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::BusinessCenter");
    return (enum redukti::BusinessCenter) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::BusinessCenter");
    return (enum redukti::BusinessCenter) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::DayCountFraction __Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(PyObject *x) {
    const enum redukti::DayCountFraction neg_one = (enum redukti::DayCountFraction) ((enum redukti::DayCountFraction) 0 - (enum redukti::DayCountFraction) 1), const_zero = (enum redukti::DayCountFraction) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::DayCountFraction) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::DayCountFraction) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::DayCountFraction) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::DayCountFraction) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) (((((enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::DayCountFraction) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) (((((((enum redukti::DayCountFraction)digits[2]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::DayCountFraction) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) (((((((((enum redukti::DayCountFraction)digits[3]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[2]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::DayCountFraction) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::DayCountFraction) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::DayCountFraction, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::DayCountFraction) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::DayCountFraction, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::DayCountFraction) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) (((enum redukti::DayCountFraction)-1)*(((((enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::DayCountFraction) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) ((((((enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) (((enum redukti::DayCountFraction)-1)*(((((((enum redukti::DayCountFraction)digits[2]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::DayCountFraction) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) ((((((((enum redukti::DayCountFraction)digits[2]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) (((enum redukti::DayCountFraction)-1)*(((((((((enum redukti::DayCountFraction)digits[3]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[2]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::DayCountFraction) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::DayCountFraction, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::DayCountFraction) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::DayCountFraction) ((((((((((enum redukti::DayCountFraction)digits[3]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[2]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[1]) << PyLong_SHIFT) | (enum redukti::DayCountFraction)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::DayCountFraction) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::DayCountFraction, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::DayCountFraction) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::DayCountFraction, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::DayCountFraction val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::DayCountFraction) -1;
        }
    } else {
        enum redukti::DayCountFraction val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::DayCountFraction) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_DayCountFraction(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::DayCountFraction");
    return (enum redukti::DayCountFraction) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::DayCountFraction");
    return (enum redukti::DayCountFraction) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::IsdaIndex __Pyx_PyInt_As_enum__redukti_3a__3a_IsdaIndex(PyObject *x) {
    const enum redukti::IsdaIndex neg_one = (enum redukti::IsdaIndex) ((enum redukti::IsdaIndex) 0 - (enum redukti::IsdaIndex) 1), const_zero = (enum redukti::IsdaIndex) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::IsdaIndex) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::IsdaIndex) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::IsdaIndex) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::IsdaIndex) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) (((((enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::IsdaIndex) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) (((((((enum redukti::IsdaIndex)digits[2]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::IsdaIndex) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) (((((((((enum redukti::IsdaIndex)digits[3]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[2]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::IsdaIndex) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::IsdaIndex) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IsdaIndex, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::IsdaIndex) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IsdaIndex, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::IsdaIndex) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) (((enum redukti::IsdaIndex)-1)*(((((enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::IsdaIndex) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) ((((((enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) (((enum redukti::IsdaIndex)-1)*(((((((enum redukti::IsdaIndex)digits[2]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::IsdaIndex) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) ((((((((enum redukti::IsdaIndex)digits[2]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) (((enum redukti::IsdaIndex)-1)*(((((((((enum redukti::IsdaIndex)digits[3]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[2]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::IsdaIndex) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IsdaIndex, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IsdaIndex) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::IsdaIndex) ((((((((((enum redukti::IsdaIndex)digits[3]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[2]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[1]) << PyLong_SHIFT) | (enum redukti::IsdaIndex)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::IsdaIndex) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IsdaIndex, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::IsdaIndex) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IsdaIndex, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::IsdaIndex val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::IsdaIndex) -1;
        }
    } else {
        enum redukti::IsdaIndex val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::IsdaIndex) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_IsdaIndex(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::IsdaIndex");
    return (enum redukti::IsdaIndex) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::IsdaIndex");
    return (enum redukti::IsdaIndex) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::Tenor __Pyx_PyInt_As_enum__redukti_3a__3a_Tenor(PyObject *x) {
    const enum redukti::Tenor neg_one = (enum redukti::Tenor) ((enum redukti::Tenor) 0 - (enum redukti::Tenor) 1), const_zero = (enum redukti::Tenor) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::Tenor) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::Tenor) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::Tenor) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::Tenor) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) (((((enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::Tenor) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) (((((((enum redukti::Tenor)digits[2]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::Tenor) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) (((((((((enum redukti::Tenor)digits[3]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[2]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::Tenor) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::Tenor) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::Tenor, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::Tenor) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::Tenor, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::Tenor) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::Tenor,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::Tenor) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) (((enum redukti::Tenor)-1)*(((((enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::Tenor) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) ((((((enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::Tenor) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) (((enum redukti::Tenor)-1)*(((((((enum redukti::Tenor)digits[2]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::Tenor) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) ((((((((enum redukti::Tenor)digits[2]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::Tenor) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) (((enum redukti::Tenor)-1)*(((((((((enum redukti::Tenor)digits[3]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[2]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::Tenor) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Tenor, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Tenor) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::Tenor) ((((((((((enum redukti::Tenor)digits[3]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[2]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[1]) << PyLong_SHIFT) | (enum redukti::Tenor)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::Tenor) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::Tenor, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::Tenor) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::Tenor, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::Tenor val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::Tenor) -1;
        }
    } else {
        enum redukti::Tenor val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::Tenor) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_Tenor(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::Tenor");
    return (enum redukti::Tenor) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::Tenor");
    return (enum redukti::Tenor) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::Currency __Pyx_PyInt_As_enum__redukti_3a__3a_Currency(PyObject *x) {
    const enum redukti::Currency neg_one = (enum redukti::Currency) ((enum redukti::Currency) 0 - (enum redukti::Currency) 1), const_zero = (enum redukti::Currency) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::Currency) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::Currency) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::Currency) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::Currency, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::Currency) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::Currency) (((((enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::Currency) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::Currency) (((((((enum redukti::Currency)digits[2]) << PyLong_SHIFT) | (enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::Currency) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::Currency) (((((((((enum redukti::Currency)digits[3]) << PyLong_SHIFT) | (enum redukti::Currency)digits[2]) << PyLong_SHIFT) | (enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::Currency) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::Currency) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::Currency, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::Currency) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::Currency, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::Currency) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::Currency, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::Currency,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::Currency) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::Currency) (((enum redukti::Currency)-1)*(((((enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::Currency) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::Currency) ((((((enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::Currency) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::Currency) (((enum redukti::Currency)-1)*(((((((enum redukti::Currency)digits[2]) << PyLong_SHIFT) | (enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::Currency) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::Currency) ((((((((enum redukti::Currency)digits[2]) << PyLong_SHIFT) | (enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::Currency) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::Currency) (((enum redukti::Currency)-1)*(((((((((enum redukti::Currency)digits[3]) << PyLong_SHIFT) | (enum redukti::Currency)digits[2]) << PyLong_SHIFT) | (enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::Currency) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::Currency, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::Currency) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::Currency) ((((((((((enum redukti::Currency)digits[3]) << PyLong_SHIFT) | (enum redukti::Currency)digits[2]) << PyLong_SHIFT) | (enum redukti::Currency)digits[1]) << PyLong_SHIFT) | (enum redukti::Currency)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::Currency) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::Currency, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::Currency) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::Currency, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::Currency val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::Currency) -1;
        }
    } else {
        enum redukti::Currency val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::Currency) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_Currency(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::Currency");
    return (enum redukti::Currency) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::Currency");
    return (enum redukti::Currency) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::IndexFamily __Pyx_PyInt_As_enum__redukti_3a__3a_IndexFamily(PyObject *x) {
    const enum redukti::IndexFamily neg_one = (enum redukti::IndexFamily) ((enum redukti::IndexFamily) 0 - (enum redukti::IndexFamily) 1), const_zero = (enum redukti::IndexFamily) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::IndexFamily) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::IndexFamily) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::IndexFamily) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::IndexFamily) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) (((((enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::IndexFamily) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) (((((((enum redukti::IndexFamily)digits[2]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::IndexFamily) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) (((((((((enum redukti::IndexFamily)digits[3]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[2]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::IndexFamily) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::IndexFamily) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IndexFamily, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::IndexFamily) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IndexFamily, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::IndexFamily) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::IndexFamily) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) (((enum redukti::IndexFamily)-1)*(((((enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::IndexFamily) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) ((((((enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::IndexFamily) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) (((enum redukti::IndexFamily)-1)*(((((((enum redukti::IndexFamily)digits[2]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::IndexFamily) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) ((((((((enum redukti::IndexFamily)digits[2]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::IndexFamily) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) (((enum redukti::IndexFamily)-1)*(((((((((enum redukti::IndexFamily)digits[3]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[2]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::IndexFamily) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IndexFamily, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IndexFamily) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::IndexFamily) ((((((((((enum redukti::IndexFamily)digits[3]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[2]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[1]) << PyLong_SHIFT) | (enum redukti::IndexFamily)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::IndexFamily) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IndexFamily, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::IndexFamily) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IndexFamily, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::IndexFamily val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::IndexFamily) -1;
        }
    } else {
        enum redukti::IndexFamily val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::IndexFamily) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_IndexFamily(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::IndexFamily");
    return (enum redukti::IndexFamily) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::IndexFamily");
    return (enum redukti::IndexFamily) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::InterpolatorType __Pyx_PyInt_As_enum__redukti_3a__3a_InterpolatorType(PyObject *x) {
    const enum redukti::InterpolatorType neg_one = (enum redukti::InterpolatorType) ((enum redukti::InterpolatorType) 0 - (enum redukti::InterpolatorType) 1), const_zero = (enum redukti::InterpolatorType) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::InterpolatorType) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::InterpolatorType) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::InterpolatorType) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::InterpolatorType) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) (((((enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::InterpolatorType) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) (((((((enum redukti::InterpolatorType)digits[2]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::InterpolatorType) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) (((((((((enum redukti::InterpolatorType)digits[3]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[2]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::InterpolatorType) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::InterpolatorType) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::InterpolatorType, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::InterpolatorType) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::InterpolatorType, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::InterpolatorType) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) (((enum redukti::InterpolatorType)-1)*(((((enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::InterpolatorType) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) ((((((enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) (((enum redukti::InterpolatorType)-1)*(((((((enum redukti::InterpolatorType)digits[2]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::InterpolatorType) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) ((((((((enum redukti::InterpolatorType)digits[2]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) (((enum redukti::InterpolatorType)-1)*(((((((((enum redukti::InterpolatorType)digits[3]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[2]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::InterpolatorType) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::InterpolatorType, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::InterpolatorType) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::InterpolatorType) ((((((((((enum redukti::InterpolatorType)digits[3]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[2]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[1]) << PyLong_SHIFT) | (enum redukti::InterpolatorType)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::InterpolatorType) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::InterpolatorType, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::InterpolatorType) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::InterpolatorType, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::InterpolatorType val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::InterpolatorType) -1;
        }
    } else {
        enum redukti::InterpolatorType val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::InterpolatorType) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_InterpolatorType(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::InterpolatorType");
    return (enum redukti::InterpolatorType) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::InterpolatorType");
    return (enum redukti::InterpolatorType) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::PricingCurveType __Pyx_PyInt_As_enum__redukti_3a__3a_PricingCurveType(PyObject *x) {
    const enum redukti::PricingCurveType neg_one = (enum redukti::PricingCurveType) ((enum redukti::PricingCurveType) 0 - (enum redukti::PricingCurveType) 1), const_zero = (enum redukti::PricingCurveType) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::PricingCurveType) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::PricingCurveType) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::PricingCurveType) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::PricingCurveType) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) (((((enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::PricingCurveType) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) (((((((enum redukti::PricingCurveType)digits[2]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::PricingCurveType) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) (((((((((enum redukti::PricingCurveType)digits[3]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[2]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::PricingCurveType) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::PricingCurveType) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::PricingCurveType, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::PricingCurveType) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::PricingCurveType, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::PricingCurveType) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) (((enum redukti::PricingCurveType)-1)*(((((enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::PricingCurveType) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) ((((((enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) (((enum redukti::PricingCurveType)-1)*(((((((enum redukti::PricingCurveType)digits[2]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::PricingCurveType) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) ((((((((enum redukti::PricingCurveType)digits[2]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) (((enum redukti::PricingCurveType)-1)*(((((((((enum redukti::PricingCurveType)digits[3]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[2]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::PricingCurveType) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::PricingCurveType, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::PricingCurveType) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::PricingCurveType) ((((((((((enum redukti::PricingCurveType)digits[3]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[2]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[1]) << PyLong_SHIFT) | (enum redukti::PricingCurveType)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::PricingCurveType) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::PricingCurveType, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::PricingCurveType) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::PricingCurveType, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::PricingCurveType val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::PricingCurveType) -1;
        }
    } else {
        enum redukti::PricingCurveType val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::PricingCurveType) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_PricingCurveType(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::PricingCurveType");
    return (enum redukti::PricingCurveType) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::PricingCurveType");
    return (enum redukti::PricingCurveType) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::MarketDataQualifier __Pyx_PyInt_As_enum__redukti_3a__3a_MarketDataQualifier(PyObject *x) {
    const enum redukti::MarketDataQualifier neg_one = (enum redukti::MarketDataQualifier) ((enum redukti::MarketDataQualifier) 0 - (enum redukti::MarketDataQualifier) 1), const_zero = (enum redukti::MarketDataQualifier) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::MarketDataQualifier) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::MarketDataQualifier) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::MarketDataQualifier) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) (((((enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) (((((((enum redukti::MarketDataQualifier)digits[2]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) (((((((((enum redukti::MarketDataQualifier)digits[3]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[2]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::MarketDataQualifier) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::MarketDataQualifier) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::MarketDataQualifier, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::MarketDataQualifier) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::MarketDataQualifier, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::MarketDataQualifier) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) (((enum redukti::MarketDataQualifier)-1)*(((((enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) ((((((enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) (((enum redukti::MarketDataQualifier)-1)*(((((((enum redukti::MarketDataQualifier)digits[2]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) ((((((((enum redukti::MarketDataQualifier)digits[2]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) (((enum redukti::MarketDataQualifier)-1)*(((((((((enum redukti::MarketDataQualifier)digits[3]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[2]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::MarketDataQualifier) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::MarketDataQualifier, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::MarketDataQualifier) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::MarketDataQualifier) ((((((((((enum redukti::MarketDataQualifier)digits[3]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[2]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[1]) << PyLong_SHIFT) | (enum redukti::MarketDataQualifier)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::MarketDataQualifier) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::MarketDataQualifier, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::MarketDataQualifier) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::MarketDataQualifier, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::MarketDataQualifier val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::MarketDataQualifier) -1;
        }
    } else {
        enum redukti::MarketDataQualifier val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::MarketDataQualifier) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_MarketDataQualifier(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::MarketDataQualifier");
    return (enum redukti::MarketDataQualifier) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::MarketDataQualifier");
    return (enum redukti::MarketDataQualifier) -1;
}

/* CIntFromPy */
static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_As_PY_LONG_LONG(PyObject *x) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG) ((PY_LONG_LONG) 0 - (PY_LONG_LONG) 1), const_zero = (PY_LONG_LONG) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(PY_LONG_LONG) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (PY_LONG_LONG) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (PY_LONG_LONG) 0;
                case  1: __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, digit, digits[0])
                case 2:
                    if (8 * sizeof(PY_LONG_LONG) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) >= 2 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((((PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(PY_LONG_LONG) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) >= 3 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((((((PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(PY_LONG_LONG) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) >= 4 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((((((((PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (PY_LONG_LONG) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(PY_LONG_LONG) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(PY_LONG_LONG, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(PY_LONG_LONG, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (PY_LONG_LONG) 0;
                case -1: __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(PY_LONG_LONG,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(PY_LONG_LONG) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((PY_LONG_LONG)-1)*(((((PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(PY_LONG_LONG) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) ((((((PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((PY_LONG_LONG)-1)*(((((((PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(PY_LONG_LONG) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) ((((((((PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((PY_LONG_LONG)-1)*(((((((((PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(PY_LONG_LONG) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) ((((((((((PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(PY_LONG_LONG) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(PY_LONG_LONG, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(PY_LONG_LONG, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            PY_LONG_LONG val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (PY_LONG_LONG) -1;
        }
    } else {
        PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (PY_LONG_LONG) -1;
        val = __Pyx_PyInt_As_PY_LONG_LONG(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to PY_LONG_LONG");
    return (PY_LONG_LONG) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to PY_LONG_LONG");
    return (PY_LONG_LONG) -1;
}

/* CIntFromPy */
static CYTHON_INLINE enum redukti::IRRateType __Pyx_PyInt_As_enum__redukti_3a__3a_IRRateType(PyObject *x) {
    const enum redukti::IRRateType neg_one = (enum redukti::IRRateType) ((enum redukti::IRRateType) 0 - (enum redukti::IRRateType) 1), const_zero = (enum redukti::IRRateType) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(enum redukti::IRRateType) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (enum redukti::IRRateType) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::IRRateType) 0;
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, digit, digits[0])
                case 2:
                    if (8 * sizeof(enum redukti::IRRateType) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) >= 2 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) (((((enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::IRRateType) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) >= 3 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) (((((((enum redukti::IRRateType)digits[2]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::IRRateType) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) >= 4 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) (((((((((enum redukti::IRRateType)digits[3]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[2]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (enum redukti::IRRateType) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(enum redukti::IRRateType) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IRRateType, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::IRRateType) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IRRateType, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (enum redukti::IRRateType) 0;
                case -1: __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(enum redukti::IRRateType) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) (((enum redukti::IRRateType)-1)*(((((enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(enum redukti::IRRateType) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) - 1 > 2 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) ((((((enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(enum redukti::IRRateType) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) (((enum redukti::IRRateType)-1)*(((((((enum redukti::IRRateType)digits[2]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(enum redukti::IRRateType) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) - 1 > 3 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) ((((((((enum redukti::IRRateType)digits[2]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(enum redukti::IRRateType) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) (((enum redukti::IRRateType)-1)*(((((((((enum redukti::IRRateType)digits[3]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[2]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(enum redukti::IRRateType) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(enum redukti::IRRateType, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(enum redukti::IRRateType) - 1 > 4 * PyLong_SHIFT) {
                            return (enum redukti::IRRateType) ((((((((((enum redukti::IRRateType)digits[3]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[2]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[1]) << PyLong_SHIFT) | (enum redukti::IRRateType)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(enum redukti::IRRateType) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IRRateType, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(enum redukti::IRRateType) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(enum redukti::IRRateType, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            enum redukti::IRRateType val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (enum redukti::IRRateType) -1;
        }
    } else {
        enum redukti::IRRateType val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (enum redukti::IRRateType) -1;
        val = __Pyx_PyInt_As_enum__redukti_3a__3a_IRRateType(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to enum redukti::IRRateType");
    return (enum redukti::IRRateType) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to enum redukti::IRRateType");
    return (enum redukti::IRRateType) -1;
}

/* CIntFromPy */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) ((long) 0 - (long) 1), const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* FastTypeChecks */
#if CYTHON_COMPILING_IN_CPYTHON
static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
    while (a) {
        a = a->tp_base;
        if (a == b)
            return 1;
    }
    return b == &PyBaseObject_Type;
}
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
    PyObject *mro;
    if (a == b) return 1;
    mro = a->tp_mro;
    if (likely(mro)) {
        Py_ssize_t i, n;
        n = PyTuple_GET_SIZE(mro);
        for (i = 0; i < n; i++) {
            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                return 1;
        }
        return 0;
    }
    return __Pyx_InBases(a, b);
}
#if PY_MAJOR_VERSION == 2
static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
    PyObject *exception, *value, *tb;
    int res;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&exception, &value, &tb);
    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
    if (unlikely(res == -1)) {
        PyErr_WriteUnraisable(err);
        res = 0;
    }
    if (!res) {
        res = PyObject_IsSubclass(err, exc_type2);
        if (unlikely(res == -1)) {
            PyErr_WriteUnraisable(err);
            res = 0;
        }
    }
    __Pyx_ErrRestore(exception, value, tb);
    return res;
}
#else
static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
    if (!res) {
        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
    }
    return res;
}
#endif
static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    assert(PyExceptionClass_Check(exc_type));
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        PyObject *t = PyTuple_GET_ITEM(tuple, i);
        #if PY_MAJOR_VERSION < 3
        if (likely(exc_type == t)) return 1;
        #endif
        if (likely(PyExceptionClass_Check(t))) {
            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
        } else {
        }
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
    if (likely(err == exc_type)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        if (likely(PyExceptionClass_Check(exc_type))) {
            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
        } else if (likely(PyTuple_Check(exc_type))) {
            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
        } else {
        }
    }
    return PyErr_GivenExceptionMatches(err, exc_type);
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
    assert(PyExceptionClass_Check(exc_type1));
    assert(PyExceptionClass_Check(exc_type2));
    if (likely(err == exc_type1 || err == exc_type2)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
    }
    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
}
#endif

/* CheckBinaryVersion */
static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* InitStrings */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        if (PyObject_Hash(*t->p) == -1)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
#if !CYTHON_PEP393_ENABLED
static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    char* defenc_c;
    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
    if (!defenc) return NULL;
    defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    {
        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
        char* c;
        for (c = defenc_c; c < end; c++) {
            if ((unsigned char) (*c) >= 128) {
                PyUnicode_AsASCIIString(o);
                return NULL;
            }
        }
    }
#endif
    *length = PyBytes_GET_SIZE(defenc);
    return defenc_c;
}
#else
static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    if (likely(PyUnicode_IS_ASCII(o))) {
        *length = PyUnicode_GET_LENGTH(o);
        return PyUnicode_AsUTF8(o);
    } else {
        PyUnicode_AsASCIIString(o);
        return NULL;
    }
#else
    return PyUnicode_AsUTF8AndSize(o, length);
#endif
}
#endif
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
        return __Pyx_PyUnicode_AsStringAndSize(o, length);
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
    int retval;
    if (unlikely(!x)) return -1;
    retval = __Pyx_PyObject_IsTrue(x);
    Py_DECREF(x);
    return retval;
}
static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
#if PY_MAJOR_VERSION >= 3
    if (PyLong_Check(result)) {
        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
                "__int__ returned non-int (type %.200s).  "
                "The ability to return an instance of a strict subclass of int "
                "is deprecated, and may be removed in a future version of Python.",
                Py_TYPE(result)->tp_name)) {
            Py_DECREF(result);
            return NULL;
        }
        return result;
    }
#endif
    PyErr_Format(PyExc_TypeError,
                 "__%.4s__ returned non-%.4s (type %.200s)",
                 type_name, type_name, Py_TYPE(result)->tp_name);
    Py_DECREF(result);
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_Check(x) || PyLong_Check(x)))
#else
  if (likely(PyLong_Check(x)))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = m->nb_int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = m->nb_long(x);
  }
  #else
  if (likely(m && m->nb_int)) {
    name = "int";
    res = m->nb_int(x);
  }
  #endif
#else
  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
    res = PyNumber_Int(x);
  }
#endif
  if (likely(res)) {
#if PY_MAJOR_VERSION < 3
    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
#else
    if (unlikely(!PyLong_CheckExact(res))) {
#endif
        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(b);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
